<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:tei="http://www.tei-c.org/ns/1.0"
  xmlns:dhq="http://www.digitalhumanities.org/ns/dhq"
  exclude-result-prefixes="#all" 
  version="3.0">
  
  <!--
      This stylesheet generates a webpage containing a table of all DHQ articles in 
      the TOC, sorted by ID, volume+issue, or title. It includes the preview and 
      internal (unpublished) articles, as well as test/example articles. It is 
      intended for proofing by DHQ editors.
    -->
  
  <xsl:import href="sidenavigation.xsl"/>
  <xsl:import href="topnavigation.xsl"/>
  <xsl:import href="footer.xsl"/>
  <xsl:import href="head.xsl"/>
  <xsl:import href="dhq2html.xsl"/>
  
  <xsl:output method="xhtml" omit-xml-declaration="yes" indent="yes" encoding="UTF-8"/>
  
  <xsl:param name="fpath"/>
  <xsl:param name="sort" select="'id'" as="xs:string"/>
  <xsl:param name="direction" select="'asc'" as="xs:string"/>
  
  
  <xsl:template match="/">
    <html>
      <!-- code to retrieve document title from the html file and pass it to the template -->
      <xsl:call-template name="head">
        <xsl:with-param name="title" select="'Article List'"/>
      </xsl:call-template>
      <body>
        <!-- Call different templates to put the banner, footer, top and side navigation elements -->
        <xsl:call-template name="topnavigation"/>
        <div id="main">
          <div id="leftsidebar">
            <xsl:call-template name="sidenavigation"/>
            <!-- moved tapor toolbar to the article level toolbar in dhq2html xslt -->
          </div>
          <div id="mainContent">
            <p>&lt;&lt; <a href="index.html">Back to Editorial Table of Contents</a></p>
            <h1 id="article_list_heading">DHQ Article List</h1>
            <!-- Create links to the other pages with other sort settings applied. -->
            <xsl:call-template name="make-sort-navigation"/>
            <!-- 2024, AMC: Removed @summary, which is deprecated. Instead, I put in 
              @aria-labelledby, which is more specific in saying that the <h1> above 
              is describing the table. If the navigation links above are ever 
              removed, the attribute would be overkill and could be removed too. -->
            <table id="article_list" aria-labelledby="article_list_heading">
              <!-- 2024, AMC: Removed links to other sort options in favor of the 
                navigation links created above the table. For accessibility, it's 
                easier to have column headings that are labels only, not labels AND 
                controls. -->
              <tr id="heading">
                <th>Article Number</th>
                <th>Volume and Issue</th>
                <th>Article Title</th>
                <th>Authors</th>
              </tr>
              <!-- Make and sort all rows of the table. -->
              <xsl:call-template name="make-rows-for-all-articles"/>
            </table>
            <p>&lt;&lt; <a href="index.html">Back to Editorial Table of Contents</a></p>
            <!-- Use the URL generated to pass to the footer -->
            <xsl:call-template name="footer">
              <xsl:with-param name="docurl" select="$fpath"/>
            </xsl:call-template>
          </div>
        </div>
      </body>
    </html>
  </xsl:template>
  
  <!-- Create a list of links to the other pages generated by this stylesheet, with 
    different sort settings applied. -->
  <xsl:template name="make-sort-navigation">
    <!-- Set up a map with all the links necessary for each sort method. -->
    <xsl:variable name="sortLinks" as="map(*)">
      <xsl:map>
        <xsl:map-entry key="'id'">
          <xsl:sequence>
            <a href="articles.html">article ID</a> 
            <a href="articles_desc.html">descending</a>
          </xsl:sequence>
        </xsl:map-entry>
        <xsl:map-entry key="'issue'">
          <xsl:sequence>
            <a href="articles_issue.html">volume and issue</a> 
            <a href="articles_issue_desc.html">descending</a>
          </xsl:sequence>
        </xsl:map-entry>
        <xsl:map-entry key="'title'">
          <xsl:sequence>
            <a href="articles_title.html">title</a>
            <a href="articles_title_desc.html">descending</a>
          </xsl:sequence>
        </xsl:map-entry>
      </xsl:map>
    </xsl:variable>
    <!-- <nav> isn't valid for the XHTML doctype we're claiming to use, but it would 
      be the semantic choice here. -->
    <div style="margin-left:2rem;">
      <span>Sort by:</span>
      <ul>
        <!-- For each sort method, create a list item with the "ascending" and 
          "descending" links for that sort method. -->
        <xsl:for-each select="('id', 'issue', 'title')">
          <xsl:variable name="sortMethod" select="."/>
          <xsl:variable name="isRequestedMethod" select=". eq $sort"/>
          <xsl:variable name="linkSeq" select="$sortLinks?($sortMethod)"/>
          <li>
            <!-- We don't need a link to the current page. Instead, we can just 
              output the text content of <a>. -->
            <xsl:choose>
              <xsl:when test="$isRequestedMethod and $direction eq 'asc'">
                <xsl:value-of select="$linkSeq[1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$linkSeq[1]"/>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:text> (</xsl:text>
            <xsl:choose>
              <xsl:when test="$isRequestedMethod and $direction eq 'desc'">
                <xsl:value-of select="$linkSeq[2]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$linkSeq[2]"/>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:text>)</xsl:text>
          </li>
        </xsl:for-each>
      </ul>
    </div>
  </xsl:template>
  
  <!-- Generate a sorted sequence of rows for all DHQ articles in the TOC. -->
  <xsl:template name="make-rows-for-all-articles">
    <!-- Sort the articles by ID, or by volume and issue. Rather than sort by title 
      here, we sort again after the rows have been created, drawing in data from the 
      articles' XML. -->
    <xsl:variable name="allRows" as="node()*">
      <xsl:choose>
        <xsl:when test="$sort eq 'id'">
          <xsl:for-each select="//item">
            <xsl:sort select="@id"/>
            <xsl:call-template name="make-row-for-article"/>
          </xsl:for-each>
        </xsl:when>
        <xsl:otherwise>
          <xsl:for-each select="//item">
            <xsl:sort select="ancestor::journal/@vol/xs:integer(.)"/>
            <xsl:sort select="ancestor::journal/@issue/xs:integer(.)"/>
            <xsl:call-template name="make-row-for-article"/>
          </xsl:for-each>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <!-- Now that we've got a sequence of rows, we can sort by title if that was 
      requested. Otherwise, we just use the existing sequence from $allRows. -->
    <xsl:variable name="allRows" as="node()*">
      <xsl:choose>
        <xsl:when test="$sort eq 'title'">
          <!-- Construct a regular expression to remove stopwords from the beginning 
            of the title. -->
          <xsl:variable name="stopwordsRegex">
            <xsl:variable name="stoplist" 
              select="doc('../../toc/stoplist.xml')/stoplist/ignore/xs:string(.)"/>
            <xsl:sequence select="'^('||string-join($stoplist, '|')||')'"/>
          </xsl:variable>
          <xsl:variable name="punctuationToRemove"
            >[/\].,+-=*~@#$%^(){}`"'!?&amp;&lt;&gt;</xsl:variable>
          <!-- The sort key of each row will be the contents of its "Title" cell: 
            lower-cased, with whitespace normalized, punctuation removed, and 
            stopwords removed from the beginning of the title. -->
          <xsl:sequence select="sort($allRows, (), function ($row) {
              $row//*:td[3]/lower-case(.)
                => normalize-space()
                => translate($punctuationToRemove, '')
                => replace($stopwordsRegex, '')
            })"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$allRows"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <!-- Now, if the request was for rows in "descending" order, we can just reverse 
      the sequence. Otherwise, we return the sequence of rows as-is. -->
    <xsl:choose>
      <xsl:when test="$direction eq 'desc'">
        <xsl:sequence select="reverse($allRows)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$allRows"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <!-- Create a row representing one DHQ article. -->
  <xsl:template name="make-row-for-article">
    <xsl:variable name="id" select="@id/data(.)"/>
    <xsl:variable name="vol" select="ancestor::journal/@vol/data(.)"/>
    <xsl:variable name="issue" select="ancestor::journal/@issue/data(.)"/>
    <xsl:variable name="path" select="concat('../../articles/',$id,'/',$id,'.xml')"/>
    <xsl:variable name="isInternalArticle" as="xs:boolean"
      select="exists(ancestor::journal/@editorial)"/>
    <xsl:variable name="isPreviewArticle" as="xs:boolean"
      select="exists(ancestor::journal/@preview)"/>
    <tr>
      <xsl:choose>
        <!-- When the article is not available on the expected path, we can fill in 
          the ID but nothing else. -->
        <xsl:when test="not(doc-available($path))">
          <!-- 2024: Ash changed these from @class="center" to inline CSS, because 
            the "center" class includes a `display: block;` rule that was causing 
            the cells to group up vertically. -->
          <td style="text-align:center;"><xsl:value-of select="@id"/></td>
          <td style="text-align:center;">[N/A]</td>
          <td>[N/A]</td>
          <td>[N/A]</td>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="article" select="doc($path)"/>
          <!-- ID column -->
          <td style="text-align:center;">
            <xsl:value-of select="@id"/>
          </td>
          <!-- Volume / issue column -->
          <td style="text-align:center;">
            <xsl:choose>
              <xsl:when test="$isInternalArticle">
                <a href="/dhq/editorial/index.html">Editorial</a>
              </xsl:when>
              <xsl:when test="$isPreviewArticle">
                <a href="/dhq/preview/index.html">
                  <xsl:value-of select="'v'||$vol||'n'||$issue"/>
                </a>
                <br/>
                <xsl:text>(Preview)</xsl:text>
              </xsl:when>
              <xsl:otherwise>
                <a href="{concat('/dhq/vol/',$vol,'/',$issue,'/index.html')}">
                  <xsl:value-of select="'v'||$vol||'n'||$issue"/>
                </a>
              </xsl:otherwise>
            </xsl:choose>
          </td>
          <!-- Title column (with article link) -->
          <td>
            <xsl:variable name="articleUrl" 
              select="if ( $isInternalArticle ) then
                        concat('/dhq/editorial/',$id,'.html')
                      else
                        concat('/dhq/vol/',$vol,'/',$issue,'/',$id,'/',$id,'.html')"/>
            <xsl:variable name="title" 
              select="$article//tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title"/>
            <xsl:choose>
              <xsl:when test="exists($title)">
                <a href="{$articleUrl}">
                  <xsl:value-of select="$title"/>
                </a>
              </xsl:when>
              <xsl:otherwise>
                <xsl:text>[No title]</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
          </td>
          <!-- Authors column -->
          <td>
            <xsl:variable name="authorInfoSeq" 
              select="$article//tei:teiHeader/tei:fileDesc/tei:titleStmt/dhq:authorInfo"/>
            <xsl:choose>
              <xsl:when test="exists($authorInfoSeq)">
                <ul>
                  <xsl:for-each select="$authorInfoSeq">
                    <xsl:variable name="thisAuthor" select="."/>
                    <li>
                      <xsl:apply-templates select="dhq:author_name"/>
                    </li>
                  </xsl:for-each>
                </ul>
                <!--<table summary="author list">
                  <xsl:for-each select="doc(concat('../../articles/',$id,'/',$id,'.xml'))//tei:teiHeader/tei:fileDesc/tei:titleStmt/dhq:authorInfo">
                    <tr><td class="author"><xsl:apply-templates select="dhq:author_name"/></td></tr>
                  </xsl:for-each>
                </table>-->
              </xsl:when>
              <xsl:otherwise>
                <xsl:text>[No author]</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
          </td>
        </xsl:otherwise>
      </xsl:choose>
    </tr>
  </xsl:template>
  
</xsl:stylesheet>
