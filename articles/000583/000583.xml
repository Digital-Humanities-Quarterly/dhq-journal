<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="../../common/schema/DHQauthor-TEI.rng" type="xml"?>
<?oxygen SCHSchema="../../common/schema/dhqTEI-ready.sch"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0"
	xmlns:cc="http://web.resource.org/cc/"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns:dhq="http://www.digitalhumanities.org/ns/dhq"
	xmlns:mml="http://www.w3.org/1998/Math/MathML">
	<teiHeader>
      <fileDesc>
         <titleStmt>
            <!--Author should supply the title and personal information-->
            <title type="article" xml:lang="en">Layers of Variation: a Computational Approach to
               Collating Texts with Revisions</title>
            <!--Add a <title> with appropriate @xml:lang for articles in languages other than English-->
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Elli <dhq:family>Bleeker</dhq:family>
               </dhq:author_name>
               <dhq:affiliation> Huygens Institute for Dutch History and Culture</dhq:affiliation>
               <email>elli.bleeker@huygens.knaw.nl</email>
               <dhq:bio>
                  <p>Elli Bleeker works as a researcher at the Huygens Institute for Dutch History
                     and Culture. She specializes in digital scholarly editing with a focus on
                     modern manuscripts, genetic criticism, and semi-automated collation.</p>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Bram <dhq:family>Buitendijk</dhq:family>
               </dhq:author_name>
               <dhq:affiliation>Royal Netherlands Academy of Arts and Sciences - Humanities Cluster,
                  Digital Infrastructure department.</dhq:affiliation>
               <email>bram.buitendijk@di.huc.knaw.nl</email>
               <dhq:bio>
                  <p>Bram Buitendijk is a software developer at the Humanities Cluster, part of the
                     Royal Netherlands Academy of Arts and Sciences. He works on transcription and
                     annotation software, collation software, and repository software.</p>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Ronald Haentjens <dhq:family>Dekker</dhq:family>
               </dhq:author_name>
               <dhq:affiliation>Huygens Institute for Dutch History and Culture</dhq:affiliation>
               <email>ronald.dekker@di.huc.knaw.nl</email>
               <dhq:bio>
                  <p>Ronald Haentjens Dekker is a software architect and lead engineer at the
                     Huygens Institute for Dutch History and Culture. He has worked on transcription
                     and annotation software, collation software, and repository software, and he is
                     the lead developer of the CollateX collation tool.</p>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Vincent <dhq:family>Neyt</dhq:family>
               </dhq:author_name>
               <dhq:affiliation>University of Antwerp</dhq:affiliation>
               <email>vincent.neyt@uantwerpen.be</email>
               <dhq:bio>
                  <p>Vincent Neyt is a member of the Antwerp Centre for Digital humanities and literary Criticism (ACDC) and the lead developer of the Beckett Digital Manuscript Project.</p>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Dirk Van <dhq:family>Hulle</dhq:family>
               </dhq:author_name>
               <dhq:affiliation>University of Oxford</dhq:affiliation>
               <email>dirk.vanhulle@ell.ox.ac.uk</email>
               <dhq:bio>
                  <p>Dirk Van Hulle is Professor of Bibliography and Modern Book History at the University of Oxford, chair of the Oxford Centre for Textual Editing and Theory (OCTET) and director of the Centre for Manuscript Genetics at the University of Antwerp. With Mark Nixon, he is co-director of the Beckett Digital Manuscript Project (www.beckettarchive.org).</p>
               </dhq:bio>
            </dhq:authorInfo>
         </titleStmt>
         <publicationStmt>
            <publisher>Alliance of Digital Humanities Organizations</publisher>
            <publisher>Association for Computers and the Humanities</publisher>
            <!--This information will be completed at publication-->
            <idno type="DHQarticle-id">000583</idno>
            <idno type="volume">016</idno>
            <idno type="issue">1</idno>
            <date when="2022-02-25">25 February 2022</date>
            <dhq:articleType>article</dhq:articleType>
            <availability status="CC-BY-ND">
               <cc:License rdf:about="http://creativecommons.org/licenses/by-nd/2.5/"/>
            </availability>
         </publicationStmt>
         <sourceDesc>
            <p>This is the source</p>
         </sourceDesc>
      </fileDesc>
      <encodingDesc>
         <classDecl>
            <taxonomy xml:id="dhq_keywords">
               <bibl>DHQ classification scheme; full list available at <ref
                     target="http://www.digitalhumanities.org/dhq/taxonomy.xml"
                     >http://www.digitalhumanities.org/dhq/taxonomy.xml</ref>
               </bibl>
            </taxonomy>
            <taxonomy xml:id="authorial_keywords">
               <bibl>Keywords supplied by author; no controlled vocabulary</bibl>
            </taxonomy>
         </classDecl>
      </encodingDesc>
      <profileDesc>
         <langUsage>
            <language ident="en" extent="original"/>
            <!--add <language> with appropriate @ident for any additional languages-->
         </langUsage>
         <textClass>
            <keywords scheme="#dhq_keywords">
               <!--Authors may suggest one or more keywords from the DHQ keyword list, visible at http://www.digitalhumanities.org/dhq/taxonomy.xml; these may be supplemented or modified by DHQ editors-->
               <list type="simple">
                  <item/>
               </list>
            </keywords>
            <keywords scheme="#authorial_keywords">
               <!--Authors may include one or more keywords of their choice-->
               <list type="simple">
                  <item/>
               </list>
            </keywords>
         </textClass>
      </profileDesc>
      <revisionDesc>
         <!--Each change should include @who and @when as well as a brief note on what was done.-->
         <change when="2022-08-02" who="BRG">fixed malformed header and other encoding errors</change>
      </revisionDesc>
   </teiHeader>
   <text xml:lang="en" type="original">
      <front>
         <dhq:abstract>
            <!--Include a brief abstract of the article-->
            <p>The article describes research into the automatic comparison of texts with revisions.
               The authors argue that in-text variation can best be modelled as nonlinear text, and
               that a collation tool needs to treat in-text variation differently from the way
               linear text is treated. They describe in detail how the modelling choices they made
               influence the development of HyperCollate, a collation software that is able to
               process TEI-XML transcriptions of texts with variation. Consequently, HyperCollate
               produces a more refined collation output that corresponds with a human interpretation
               of textual variance.</p>
         </dhq:abstract>
         <dhq:teaser>
            <!--Include a brief teaser, no more than a phrase or a single sentence-->
            <p>The development of a software program that interprets TEI-XML transcriptions of texts
               with variation provides a medium to examine the ways in which we model and study
               textual variance.</p>
         </dhq:teaser>
      </front>
      <body>
         <div xml:id="section1">
            <head>1. Introduction</head>
            <p>The act of comparing textual versions has always been central to textual criticism
               and manuscript research. The importance of this type of collation has only increased
               in the digital age. Most scholarly editors no longer produce collations by hand; they
               use the output generated by software, either as is, or as the starting point for
               manual correction. Still, in more complex cases such as manuscripts with revisions –
               i.e., textual variation within one text version – it remains difficult to have the
               collation software produce a result that corresponds with what a scholarly editor
               would produce. The reason for this is, simply put, that the collation software treats
               the input as linear text, whereas text with revisions is not completely linear. As a
               consequence, scholarly editors still need to do quite some manual work, such as
               preparing the input texts or adjusting the collation output. What is more, they lose
               information about the multilayered nature of the document and the physical traces of
               the writing process or transmission history. </p>
            <p>We therefore set out to create collation software that is able to compare texts with
               revisions. When working on this challenge, we soon realized that conveying our human
               interpretation of text with revisions to the computer is not merely a technical
               matter. It is, in fact, deeply rooted in philological questions: what do we
               understand by text with revisions? What type of revisions can we discern? And how do
               we expect the collation software to deal with them? Designing and developing a
               collation tool that understands in-text variation in a way similar to how scholarly
               editors understand it requires us to formalize our understanding of in-text
               variation. We argue that in-text variation can best be modelled as nonlinear text,
               and that a collation tool needs to treat this nonlinear text differently from the way
               linear text is treated. This will produce a more refined collation output that
               corresponds with a human interpretation of the textual variance.</p>
            <p>For the purposes of this article, we focus on in-text variation resulting from
               authorial revisions on modern manuscripts; revisions by multiple textual agents are
               not within the scope of this article. As a test-corpus we took small examples from a
               modern manuscript of Samuel Beckett featuring numerous deletions and additions that
               Beckett made at various stages in the writing process.<note>The examples selected for
                  this article are small for illustrative purposes, but HyperCollate is developed to
                  deal with larger texts.</note> Evidently, the feature of in-text variation is not
               unique to modern manuscripts: medieval and older manuscripts often contain
               indistinguishable layers of in-text revisions as well. When in-text revisions are
               made with the same writing tool they cannot be easily divided into separate revision
               campaigns. The challenges of automatically collating such multi-layered texts are,
               then, twofold: first, to adequately process a textual version that contains one or
               more revisions, and second, to return a collation output that corresponds with what a
               scholarly editor would intuitively produce. We will discuss our approach to these
               challenges in the context of HyperCollate, an automatic collation tool developed to
               take in-text revisions into account when calculating the best match between two
               textual versions.</p>
            <p><ref target="#section2">Section 2</ref> provides a theoretical background for the
               concepts and practices under discussion: versions, witnesses, in-text revision, and
               (non)linear text. It also provides a brief overview of the existing approaches to
               collating texts with in-text variation. <ref target="#section3">Section 3</ref>
               presents the collation tool HyperCollate. We describe its underlying data model – a
               hypergraph for textual variation – and how this data model differs from XML tree
               structures and regular variant graphs. A hypergraph for textual variation offers more
               flexibility in storing and processing information that is relevant to the study of
               textual variance. Subsequently, we single out two instances of in-text variation that
               occur frequently in manuscript texts – single deletions or additions and
               substitutions – and we describe for each type of variation what we, as human
               scholars, expect of the collation output (<ref target="#section3-2">section
               3.2</ref>). How do we wantt the collation tool to handle immediate revisions in a
               textual version? What do we expect to see in the output? The answer to such
               questions, i.e., our expectations, inform the rules for the collation program.
               HyperCollate’s performance with each type of variation is discussed in <ref
                  target="#section3-3">section 3.3</ref>. The evaluation (<ref target="#section3-4"
                  >section 3.4</ref>) includes the question of visualization, as existing
               visualizations could turn out to be inadequate in displaying the additional
               information in an insightful way. <ref target="#section4">Section 4</ref>, finally,
               discusses a number of areas in need of further research.</p>
            <p>As the development and use of collation tools requires us to clearly articulate what
               we understand by textual variation and what we expect from the collation, automated
               collation tools can provide us with a heightened awareness of, and confront us with
               our assumptions about, the notion of <term>text</term>. The workflow of a scholarly
               editor using an automated collation tool consists of seemingly straightforward steps
               (transcription ⇒ collation ⇒ visualization) but each step implies decision-making at
               several stages and substages (selection, tagging, tokenization, normalization, a
               definition of a match, etc.). The decisions made at one stage influence the outcome
               of a subsequent stage. Recognizing and understanding this heuristic process will
               prompt us to rethink our theories of text (cf. <ref target="#ciula2014" loc="36"
                  >Ciula and Eide 2014, 36</ref>) and how these theories correspond to the workings
               of a text analysis tool. </p>
            <p>By demonstrating, first, how we made our human definition of in-text variation
               computer-understandable and, subsequently, how this definition influences the
               operations as well as the results of a collation tool, we hope to provide our readers
               with a deeper understanding of the process of modeling textual variation. We intend
               to show how the development of a collation program has both a philological and a
               computational perspective. Accordingly, our study reflects a fruitful collaboration
               between textual scholars and software architects: their respective knowledge is
               essential in order to successfully store, process, and analyse text. It thus proves a
               worthy partnership for manuscript research and modelling textual variance.</p>
         </div>
         <div xml:id="section2">
            <head>2. Theoretical and Methodological Background</head>
            <p>In what follows we give an overview of the discussion around textual versions and
               witnesses (section 2.1), of the challenges of transcribing and modeling in-text
               variation (section 2.2 and 2.3), and of the current approaches to collating texts
               with internal revisions (section 2.4). </p>
            <div>
               <head>2.1. Text, Work, Versions, Witnesses, and In-text Revision</head>
               <p>A few working definitions of the terms <term>document,</term>
                  <term>version,</term>
                  <term>witness,</term>
                  <term>work,</term> and <term>text</term> are in order. Following Peter
                  Shillingsburg, we define a <term>document</term> as the <quote rend="inline"
                     >physical vessel</quote> that carries information <ptr
                     target="#shillingsburg1996" loc="174"/>. A <term>version</term> has <quote
                     rend="inline">no substantial existence</quote> as Shillingsburg puts it <ptr
                     target="#shillingsburg1996" loc="44"/>. As a theoretical construct, it implies
                  that there are at least two textual representations of the work. A
                     <term>witness</term> is a <quote rend="inline">written document that witnesses
                     a text’s genesis</quote> according to Almuth Grésillon <ptr
                     target="#gresillon1994" loc="246"/>.<note><quote rend="inline" xml:lang="fr"
                        >Témoin: document écrit qui témoigne de la genèse du texte</quote>
                     <ptr target="#gresillon1994" loc="246"/>. In medieval studies, the term witness
                     is usually reserved for copies that are not an autograph <ptr
                        target="#plachta1997" loc="139"/> and serve as a witness to an archetype
                        <ptr target="#kline1998" loc="274"/>. See the Lexicon of Scholarly Editing,
                        <ref target="https://lexiconse.uantwerpen.be/lexicon/witness.html"
                        >https://lexiconse.uantwerpen.be/lexicon/witness.html</ref> (last accessed
                     October 22, 2021).</note> A witness is therefore a physical object. Whereas the
                  term <term>document</term> considers the object in and of itself, the term
                     <term>witness</term> considers it in relation to a work. Different documents
                  that relate to the same work are witnesses of it. According to Siegfried Scheibe,
                     <quote rend="inline">Textual versions are achieved or unachieved elaborations
                     of the text that diverge from one another. They are related through textual
                     identity and distinct through variation.</quote>
                  <ptr target="#scheibe1995" loc="207"/>. In principle, this implies that a single
                  revision suffices to speak of two versions, or as Hans Zeller noted: <quote
                     rend="inline">In the most extreme case a version is constituted by a single
                     variant. A holograph with one alteration which does not simply correct an error
                     thus represents two versions of the text</quote>
                  <ptr target="#zeller1975" loc="236"/>. The notion of the <term>work</term> is used
                  in the sense of the <quote rend="inline">experience implied by the authoritative
                     versions of literary writing</quote>
                  <ptr target="#shillingsburg1996" loc="176"/>, a non-material concept that <quote
                     rend="inline">serves as a minimal denominator to identify its remaining
                     physical manifestations</quote>
                  <ptr target="#bordalejo2013" loc="71"/>. In the context of this article, the term
                     <term>text</term> will be employed to indicate not so much <quote rend="inline"
                     >the text of the work,</quote> but <quote rend="inline">the text of the
                     document,</quote> that is, the sequence of marks present in one particular
                  document <ptr target="#bordalejo2013" loc="67"/>.</p>
               <p>In textual scholarship, the notion of <term>version,</term>
                  <term>textual version</term> or <foreign xml:lang="de">Textfassung</foreign>
                  usually implies the entirety of a work, as in Peter Shillingsburg’s definition:
                     <quote rend="inline">A version is one specific form of the work – the one the
                     author intended at some particular moment in time</quote>
                  <ptr target="#shillingsburg1996" loc="44"/>. The problem, however, is that this
                     <q>moment in time</q> is hard to define. If the work is a long novel, it takes
                  a while for an author to revise the entire manuscript or to proofread the page
                  proofs. The revision may consist of more than one phase, or more than one revision
                  campaign (<foreign xml:lang="fr">campagne de révision</foreign>). There may be
                  only two versions of the opening chapter, but a dozen versions of the closing
                  chapter. Moreover, the unit of revision may vary considerably. Some writers’
                  preferred writing unit is a chapter, others tend to work and think in terms of
                  paragraphs.</p>
               <p>This reality makes it difficult to establish a general rule on which we can base
                  the collation algorithm. For the purposes of this article, we work with the
                  sentence as a relatively small unit of revision. Our examples are based on the
                  manuscripts of Samuel Beckett and the transcriptions in the Beckett Digital
                  Manuscript Project (BDMP).<note> See <ref target="https://www.beckettarchive.org/"
                        >https://www.beckettarchive.org/</ref>. (last accessed October 22,
                     2021)</note> These documents constitute what is usually referred to as “modern”
                  manuscripts, to distinguish these autographs from ancient and medieval
                  manuscripts, many of which were produced by scribes. Indeed the majority of
                  medieval manuscripts are copies and not autographs, but that does not mean that
                  all medieval manuscripts are copies. Medieval autographs do exist, and it is
                  perfectly possible to apply automatic collation to them. Instead of using the term
                     <term>modern manuscripts</term> we will therefore speak of <q>manuscripts with
                     revisions</q> or even more generally of <q>texts with revisions.</q>
                  <term>In-text</term> implies that we focus on textual variation within one version
                  of a text.</p>
            </div>
            <div>
               <head>2.2. Transcribing Linearity and Nonlinearity</head>
               <p>As mentioned in the introduction, studying manuscripts with revisions is
                  intrinsically linked to the act of linearizing text. Even when we read a text, we
                  mentally arrange the characters in a linear order; vertically or horizontally,
                  from left to right or vice versa, depending on the language. This perhaps
                  subconscious act of linearization is more striking when we make a transcription of
                  a complex text with revisions. Since the goal of a transcription is, in the first
                  place, to render a text more readable, linearizing the text on the document is
                  desirable – but not without cost. Texts with revisions contain traces of a writing
                  process over time; so when words and characters are placed in a linear order, the
                  manuscript page loses that diachronic aspect. The desire to preserve the nonlinear
                  nature of the text coupled with the need to make it readable (and processable)
                  confronts textual scholars with a dilemma. Accordingly, linearization has been the
                  topic of long debates in genetic criticism and textual scholarship <ptr
                     target="#gresillon1994"/>
                  <ptr target="#lebrave1992"/>
                  <ptr target="#vanhulle1999"/>
                  <ptr target="#vanhulle2004"/>
                  <ptr target="#ferrer2014"/>. The <q>flattening</q> or <q>de-manuscripting</q> of a
                  text is generally accepted as a necessary evil, although it is lamented that the
                  most typical feature of a written draft – its nonlinearity – is reduced to a
                  straightforward sequence of text. </p>
               <p>In print, nonlinear text can be indicated with certain diacritical marks or forms
                  of layout; in digital transcriptions the revisions can be captured with markup
                  elements and visualized with HTML and/or CSS.<note>We recognize that a TEI-XML
                     transcription is not synonymous with an embedded markup file; there exist
                     non-TEI and standoff approaches to transcribing manuscripts with revisions as
                     well. Still, TEI-XML files with embedded markup are considered to be the <hi
                        rend="italic">de facto</hi> standard for text encoding <ptr
                        target="#andrews2013"/>
                     <ptr target="#pierazzo2015" loc="130"/>, so in this contribution we focus on
                     this kind of digital text transcriptions. </note> The TEI Guidelines suggest
                  two ways of expressing an instance of nonlinear text: substitutions can be
                  recorded (1) by means of a <code>&lt;subst&gt;</code> element grouping one or more
                     <code>&lt;del&gt;</code> and <code>&lt;add&gt;</code> elements,<note>TEI
                     Guidelines chapter 11.3.1.5. <title rend="quotes">Substitutions.</title> See
                        <ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU</ref>.
                     (last accessed October 22, 2021)</note> or (2) by means of an
                     <code>&lt;app&gt;</code> element containing two or more
                     <code>&lt;rdg&gt;</code> elements.<note> TEI Guidelines chapter 12. <title
                        rend="quotes">Critical Apparatus.</title> See <ref
                        target="https://tei-c.org/release/doc/tei-p5-doc/en/html/TC.html"
                        >https://tei-c.org/release/doc/tei-p5-doc/en/html/TC.html</ref> (last
                     accessed October 22, 2021)</note>
               </p>
               <p>In both cases, a human encoder will think of these TEI elements as indicating the
                  momentary suspension of the linear sequence of text characters. The text stream
                  runs from left to right, diverges at the points where variation occurs (indicated
                  with an open tag <code>&lt;subst&gt;</code> or <code>&lt;app&gt;</code>) and
                  converges when the variation ends (indicated with a closing tag
                     <code>&lt;/subst&gt;</code> or <code>&lt;/app&gt;</code>). We can say that
                  there are multiple coexisting, simultaneous paths through the text. The start of
                  each path is marked with a <code>&lt;del&gt;</code>, an <code>&lt;add&gt;</code>,
                  or a <code>&lt;rdg&gt;</code> element; the end of each path with the corresponding
                     <code>&lt;/del&gt;</code>, <code>&lt;/add&gt;</code>, or
                     <code>&lt;/rdg&gt;</code>. By <q>coexisting</q> we mean that the textual
                  content of the <code>&lt;del&gt;</code>, <code>&lt;add&gt;</code>, or
                     <code>&lt;rdg&gt;</code> is in the same location in the sentence. This
                  corresponds with the TEI Guidelines’ remark that <quote rend="inline">Since the
                     purpose of this [the <code>&lt;subst&gt;</code>] element is solely to group its
                     child elements together, the order in which they are presented is not
                     significant.</quote><note> TEI Guidelines chapter 11.3.1.5, <title
                        rend="quotes">Substitutions.</title> See <ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU</ref>.
                     (last accessed October 22, 2021)</note>
               </p>
               <p>As described in <ref target="#section2-4">section 2.4</ref>, a current approach to
                  the automated collation of in-text revisions is to flatten the TEI-XML
                  transcription to a stream of plain text characters, thereby ignoring the TEI-XML
                  markup elements that indicate nonlinear text. In order to fully understand the
                  challenges that arise when we <hi rend="italic">do</hi> wish to avoid flattening
                  and instead take a text’s nonlinear features into account, we first need to take a
                  closer look at how in-text revisions can be modelled in TEI-XML. </p>
            </div>
            <div>
               <head>2.3. Modeling Nonlinearity</head>
               <p>A TEI-XML transcription of a straightforward text consists typically of <q>fully
                     ordered</q> data. For textual scholars, the value and meaning of this data are
                  primarily in the textual content, not in the TEI-XML elements. As a consequence,
                  the order of the TEI-XML elements is meaningful. In the TEI-XML expert below,
                  changing the order of the two <code>&lt;s&gt;</code> elements with their textual
                  content would alter the meaning of the text:
                     <eg lang="xml">
                        <![CDATA[
<p>
   <s>The sun shone, having no alternative, on the nothing new.</s>
   <s>Murphy sat out of it, as though he were free, in a mew in West Brompton.</s>
</p>]]></eg></p>
               <p>We have argued in the previous section that the textual data of a TEI-XML
                  transcription of a manuscript with in-text revisions can be understood as an
                  ordered stream of text characters, which splits into two or more paths when
                  textual variation occurs. Or, put metaphorically by Michael Sperberg-McQueen, this
                  type of text forms <quote rend="inline">curves that intersect, run together for a
                     while, and then split apart again, like the channels in a river delta</quote>
                  <ptr target="#sperberg-mcqueen1989"/>. By way of illustration, let’s take the
                  following TEI-XML example: 
                     <eg lang="xml"><![CDATA[
<p>
   <s>The
      <subst>
         <del>quick</del>
         <add>brown</add>
      </subst> fox.
   </s>
</p>]]></eg></p>
               <p>The stream of textual data starts by being fully ordered with <q>The.</q> At the
                  point in the text where variation occurs (marked with <code>&lt;subst&gt;</code>),
                  the stream splits into two paths that run parallel to one another. The textual
                  data <emph>within</emph> the two <code>&lt;del&gt;</code> and
                     <code>&lt;add&gt;</code> paths is again fully ordered as each path contains a
                  linear stream of text characters. From a purely informational perspective, the
                  deleted word <q>quick</q> is on the same level in the XML tree as the added word
                     <q>brown</q>: they are both the textual content of the child elements of the
                     <code>&lt;subst&gt;</code> element and they occur in the same place in the
                  text. In other words, their position vis-à-vis their parent element is the same.
                  At the end of the variation (marked with <code>&lt;/subst&gt;</code>) the two
                  paths converge again into one stream.</p>
               <p>The order in which TEI-XML elements are placed also carries philological or
                  semantic value. In the field of digital scholarly editing it is generally
                  acknowledged that markup represents valuable editorial knowledge and that the tags
                  reflect an interpretation of the inscriptions on the source document. Compare for
                  instance <eg lang="xml">
                     <![CDATA[
                     <s>The 
                        <subst>
                           <del>quick</del>
                           <add>brown</add>
                        </subst> fox.
                     </s>]]></eg> and <eg lang="xml">
                     <![CDATA[
                     <s>The 
                        <del>quick</del>
                        <add>brown</add> fox.
                     </s>]]></eg>In the first case, the encoder groups together the deletion and the
                  addition as part of one and the same revision. The elements
                     <code>&lt;del&gt;</code> and <code>&lt;add&gt;</code> are in the same
                  hierarchical location in the XML tree (again, both are children of the
                     <code>&lt;subst&gt;</code> element).<note> If the encoder wishes to indicate
                     the order in which they think the intervention took place, the TEI Guidelines
                     suggest to use the <code>@seq</code> attribute. See TEI Guidelines, chapter
                     11.3.1.4. <title rend="quotes">Additions and Deletions</title> (<ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHAD"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHAD</ref>).
                     (last accessed October 22, 2021)</note> In the second case, the deletion and
                  the addition are interpreted as seperate interventions. The
                     <code>&lt;del&gt;</code> element precedes the <code>&lt;add&gt;</code> element,
                  which denotes a chronological order: first the word <q>quick</q> was deleted, then
                  the word <q>brown</q> was added. In order for a collation tool to produce an
                  output that corresponds with this interpretation of in-text revision, it should
                  both recognize the start of parallel paths marked with <code>&lt;subst&gt;</code>
                  or <code>&lt;app&gt;</code>/<code>&lt;rdg&gt;</code>, and take into account the
                  chronological order implied by the order of the <code>&lt;del&gt;</code> and
                     <code>&lt;add&gt;</code> tags without a <code>&lt;subst&gt;</code> or
                     <code>&lt;app&gt;</code> parent.</p>
            </div>
            <div xml:id="section2-4">
               <head>2.4. Current Approaches to Collating In-text Revisions</head>
               <p>This section presents a concise discussion of the existing approaches to collating
                  in-text revisions. We leave aside the manual collation method of TEI Parallel
                  Segmentation and others and concentrate on the methods of automated
                     collation.<note> TEI Guidelines, chapter 12.2.3. <title rend="quotes">The
                        Parallel Segmentation Method.</title> See <ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/TC.html#TCAPPS"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/TC.html#TCAPPS</ref>.
                     (last accessed October 22, 2021)</note> As mentioned above, current automated
                  collation tools are generally text-centered and do not handle TEI-XML well: they
                  ignore all tags and attributes, or collate the elements as plain text. The
                  nonlinear aspect of texts with revisions as described above, is ignored. If a
                  scholar would want to automatically compare XML files, they could opt for (1)
                  passing along information marked as relevant to the study of in-text variation
                  (with CollateX, collation software; see <ref target="#section2-4-1">section
                     2.4.1</ref>), or (2) creating plain text files for each level of in-text
                  variation (for instance with MVD, a storage format for text; see <ref
                     target="#section2-4-2">section 2.4.2</ref>). As far as we know, both approaches
                  are implemented by at least one edition project.</p>
               <div xml:id="section2-4-1">
                  <head>2.4.1. Passing Along Relevant Markup Elements</head>
                  <p>The JSON input format of the collation tool CollateX allows for extra
                     properties to be added to words <ptr target="#collatex"/>. A number of projects
                     make use of the JSON input format to “pass along” additional information about
                     relevant markup elements through the collation pipeline. In a pre-processing
                     step, the text is tokenized and transformed into JSON word tokens. Editors make
                     a selection of elements that they wish to attach to the JSON token as a <hi
                        rend="italic">t</hi> property (<q>t</q> for token). The collation is
                     executed on the value of the token’s <hi rend="italic">n</hi> property
                        (<q>n</q> for normalized), but the <hi rend="italic">t</hi> property with
                     the tag(s) is included in the JSON alignment table output and can be processed
                     in the table’s visualization. This approach is used, among others, by the
                     aforementioned BDMP; the online critical edition of the Primary Chronicles, or
                        <title rend="italic">Povest’ vremennyx let</title>, created by David J.
                     Birnbaum; and the work on the <title rend="italic">Declamations</title> of
                     Calpurnius Flaccus done by Elisa Nury <ptr target="#birnbaum2015"/>
                     <ptr target="#nury2018" loc="7.1"/>. The advantages of this approach are,
                     first, that a witness with in-text variation can be collated as one text and,
                     secondly, that the method approximates the goal of having nonlinear revisions
                     marked as such in both in- and output. The main disadvantage is that the
                     collation algorithm still treats the input witness as linear text: the
                     witnesses are collated as such and any information about revision campaigns is
                     ignored during the collation process.</p>
               </div>
               <div xml:id="section2-4-2">
                  <head>2.4.2. Creating Separate Plain Text Files For Each Level of Variation</head>
                  <p>Another approach is to transcribe a manuscript with in-text revisions as two or
                     more separate plain text versions and then collate these temporary versions
                     against each other. The advantage of this method is that it succeeds in
                     aligning the two parts of a substitution vertically instead of horizontally
                     (which the previous approach is forced to do), but the drawback is that the
                     deletions and additions are spread over two or more (sub)versions. What is
                     more, the revisions on a manuscript do not always lend themselves to a clean
                     separation into different layers.</p>
                  <p>The approach is presented by Desmond Schmidt’s Multi-Version Document system,
                     as integrated into Ecdosis, <title rend="quotes">A CMS for scholarly
                        editors.</title><note>
                        <ref
                           target="http://charles-harpur.org/About/Technical%20design/Ecdosis%20CMS/"
                           >http://charles-harpur.org/About/Technical%20design/Ecdosis%20CMS/</ref>.
                        (last accessed October 22, 2021)</note> In a 2019 article, Schmidt describes
                     in detail how this layered approach also allows for the inclusion of in-text
                     variation <ptr target="#schmidt2019" loc="§60"/>. At the transcription phase, a
                     manuscript text is divided into <q>levels</q> by the scholarly editor. All
                     changes to the <q>baseline text</q> of a document (level 1) are grouped as
                     being on level 2. Subsequent changes to level 2 are grouped as level 3. For
                     each of these levels a separate text is created, a <q>layer:</q>
                     <quote rend="inline">We do not claim that a layer is a text the author ever
                        completed; it is not a <hi rend="italic">version</hi> as such,</quote>
                     explains Schmidt, <quote rend="inline">It is simply a compact way to capture
                        local changes.</quote><note> Desmond Schmidt in the <title rend="quotes"
                           >Technical Design</title> section of the online Charles Harpur Critical
                        Archive. See: <ref
                           target="https://charles-harpur.org/About/Technical%20design/Versions%20and%20layers/"
                           >https://charles-harpur.org/About/Technical%20design/Versions%20and%20layers/</ref>.
                        (last accessed October 22, 2021)</note> Each of these artificial layers is
                     fed into Ecdosis as plain text, with a few additional features encoded in
                     stand-off markup. The Ecdosis approach is implemented in the Charles Harpur
                     Critical Archive. For example, the text of Harpur’s poem <title rend="quotes"
                        >To the Comet</title> is divided into three layers. The document identifier
                        <q>english/harpur/poems/h595f/layer-2</q> points to the second layer of the
                     poem’s text. Layer 2 is followed by <q>h595f/layer-final,</q> in which
                     corrections on the third level are carried out on the text of layer 2.<note>
                        See <ref
                           target="https://charles-harpur.org/View/Singleview/?docid=english/harpur/poems/h595&amp;version1=/h595f/layer-final"
                           >https://charles-harpur.org/View/Singleview/?docid=english/harpur/poems/h595&amp;version1=/h595f/layer-final</ref>
                        for an overview of all versions of the text of <title rend="italic">The
                           Comet</title>. (last accessed October 22, 2021)</note> The scholarly
                     editors of the Charles Harpur Critical Archive see no issue in this
                        <q>mechanical</q> grouping of in-text variation: <cit><quote rend="block"
                           >Assignment to levels is mechanical and describes a purely local
                           succession of changes, which can almost always be determined. Authors
                           leave many clues as to the succession of variants: position (above the
                           line, then below, in the margin, on another page), the carrying over of
                           changed text between levels, sense and crossing-out. Where the local
                           temporal succession can’t be established this is usually because the
                           corrections themselves can’t be read.</quote>
                        <ref
                           target="https://charles-harpur.org/View/Singleview/?docid=english/harpur/poems/h595&amp;version1=/h595f/layer-final"
                              >(<hi rend="italic"
                     >Ibid</hi>.)</ref></cit><!-- check what happens here in original --> The
                     versions and layers in plain text are merged into one Multi-Version Document.
                     It stores the text shared by each version and layer only once. Note that the
                     comparison algorithm works at the character level, not at word level. In the
                     table visualization, therefore, words may be cut up (see <ref
                        target="#figure01">figure 1</ref>).</p>
                  <figure xml:id="figure01">
                     <head>Table visualization of the collation output of the artificial layers of
                           <title rend="italic">The Comet</title> by Charles Harpur. Text characters
                        added with respect to the base layer (not shown in this figure) are in
                        blue.</head>
                     <graphic url="resources/images/figure01.png"/>
                  </figure>
               </div>
               <div>
                  <head>2.4.3. Diff Algorithms to Compare XML Documents </head>
                  <p>Evidently, XML is a widely used standard for (online) publishing and
                     data-exchange, and there is a general need for comparing and versioning XML
                     documents. Accordingly, there exists a wide variety of <term>diff</term>
                     algorithms or <term>deltas</term> to find the differences between two XML
                     documents, each with its own strengths and focus <ptr target="#peters2005"/>.
                     Because most XML documents are data-centric and contain record-based data,
                     deltas typically consider XML documents as hierarchically structured trees and
                     compare them as such. Considering our type of material – text-centric XML
                     documents in which the left-to-right order of the siblings is significant – we
                     specifically focused on tools that can compare ordered XML trees.</p>
                  <p>We found a number of useful tools and algorithms, like the commercial tools
                     Microsoft’s XML Diff and Patch or the XML compare tool of DeltaXML, that can
                     compare both ordered and unordered XML trees.<note>Microsoft XML Diff 1.0 and
                        XML Patch 1.0 (see the documentation on <ref
                           target="https://documentation.help/Microsoft-XML-Diff/xmldiffpatch_namespace_intro_conc_0t0v.htm"
                           >https://documentation.help/Microsoft-XML-Diff/xmldiffpatch_namespace_intro_conc_0t0v.htm</ref>);
                        Delta XML Compare 11.0 (see the documentation on <ref
                           target="https://docs.deltaxml.com/xml-compare/latest/xml-compare-45122014.html"
                           >https://docs.deltaxml.com/xml-compare/latest/xml-compare-45122014.html</ref>).
                        (last accessed October 22, 2021)</note> Such tools can come in handy during
                     the making of a digital edition, for instance when scholarly editors wish to
                     compare and align TEI-XML transcriptions of the same text that were made by two
                     different scholars of the same project. Furthermore, there exist XML editors
                     with a built-in function to compare XML documents. Oxygen XML Editor, for
                     example, allows its users to compare two XML documents on the level of lines,
                     words, or characters, or to ignore attributes or namespaces.<note> Oxygen XML
                        Editor 24.0 (see <ref target="https://www.oxygenxml.com/"
                           >https://www.oxygenxml.com/</ref>). (last accessed October 22,
                        2021)</note></p>
                  <p>There is, however, an important difference between current XML comparison tools
                     and algorithms, and how we designed HyperCollate. Existing tools compare XML
                     documents and focus on the parent nodes, whereas HyperCollate <hi rend="italic"
                        >interprets</hi> XML documents in order to better compare the versions of a
                     text. It does not ignore the structure of the XML tree, but – in line with the
                     research objectives of scholarly editors – it focuses on comparing text and is
                     only concerned with the TEI-XML tags that determine the flow of a text with
                     revisions. Given this fundamental difference in premise, an extensive analysis
                     of the quality and use of diff algorithms and tools is beyond the scope of this
                        article.<note> We recommend the research by Gioele Barabucci on the topic
                        (see <ref target="#barabucci2016">Barabucci et al. [2016]</ref>; <ref
                           target="#barabucci2018">Barabucci [2018]</ref>, <ref
                           target="#barabucci2020">[2020]</ref>).</note>
                  </p>
               </div>
            </div>
         </div>
         <div xml:id="section3">
            <head>3. Automated Collation of Nonlinear Text</head>
            <div xml:id="section3-1">
               <head>3.1. Nonlinearity and Variant Graphs </head>
               <p>As the previous section showed, automated collation software usually does not take
                  in-text revisions into account. Yet we find that texts with revisions have a
                  complex richness that deserves to be treated with attention to detail, in
                  transcription as well as in collation, so as to produce a more accurate and
                  detailed record of the textual variance. The collation result of HyperCollate
                  needed to correspond with the scholarly editor’s interpretation of the in-text
                  variance, which meant that the tool should be able to recognize and respect the
                  nonlinear nature of the input text as it was expressed in TEI-XML markup.</p>
               <p>The first step we took in enabling a collation tool to recognize in-text variation
                  in a witness was establishing formal (i.e., exhaustive and unambiguous) rules for
                  the way in which the program needed to process it. As described in <ref
                     target="#section2-2">section 2.2</ref>, we regard a revision as a temporary
                  interruption in the linear text stream, so we wanted HyperCollate to be able to
                  treat it as such. In order for this to work, the collation tool would have to
                  recognize and interpret the markup elements indicating the start and end of
                  nonlinearity in the TEI-XML input transcription: <code>&lt;app&gt;</code> and
                     <code>&lt;subst&gt;</code>. Secondly, we regard the elements
                     <code>&lt;del&gt;</code>, <code>&lt;add&gt;</code>, or <code>&lt;rdg&gt;</code>
                  as indicators of the start of a separate path through the text – one <q>branch</q>
                  of the text stream – and we would want the collation program to select the best
                  match from these branches. </p>
               <p> A fitting model of nonlinear text is presented by the variant graph data
                  structure. The variant graph consists of a set of nodes that represent textual
                  objects, and edges that connect one node to another node in the graph. The graphs
                  are acyclic, which means that they are read from left to right without
                     <q>looping</q> back. As Tara Andrews and Caroline Macé write, a variant graph
                  is an elegant way to represent nonlinear text: <quote rend="inline">one may
                     imagine a text running from beginning to end with a number of points of
                     divergence, where each witness takes a single path through these
                     divergences</quote>
                  <ptr target="#andrews2013" loc="506"/>. Variant graphs are relatively well-known
                  in the field of automated collation and occur both as internal data model <ptr
                     target="#schmidt2009"/>
                  <ptr target="#collatex"/> and for visualization purposes (e.g., the stemma graph
                  or the variant graph, <ptr target="#andrews2013" loc="507, 510–1"/>). As Elisa
                  Nury writes, the first use of a variant graph to express textual variation can be
                  traced to E.C. Colwell and E.W. Tune in 1964, although it was with the 2009
                  article of Desmond Schmidt and Robert Colomb that the variant graph gained a
                  foothold in the field of textual scholarship <ptr target="#schmidt2009"/> (See
                     <ptr target="#nury2018" loc="73–7"/>). Their variant graph has the text and
                  sigla placed on the edges of the graph (<ref target="#figure02">figure 2</ref>).
                  Common text is merged, and variant text results in separate branches. </p>
               <figure xml:id="figure02">
                  <head>Representation of the variant graph data model of Schmidt and Colomb
                     (source: CollateX documentation, section <title rend="quotes">The Data Model:
                        Variant Graphs,</title> on <ref target="#https://collatex.net/doc/"
                        >https://collatex.net/doc/</ref>).</head>
                  <graphic url="resources/images/figure02.png"/>
               </figure>
               <p>CollateX adopted the variant graph, but modified it to place the text in the nodes
                  of the graph, and the sigla on the edges (see <ref target="#figure03">figure
                     3</ref>). This ensures not only a better readability, but also improves
                  processing as the edges have only one label (one or more sigla). </p>
               <p> There is another, more subtle yet important distinction between the variant graph
                  as proposed by Schmidt and Colomb, and the variant graph as implemented by
                  CollateX. The data structure of the variant graph in figure 3 appears simpler than
                  it is. At first glance, the textual content of the first node (<q>The</q>) appears
                  to be shared by witness 1 (W1) and witness 2 (W2). In fact, each node in the
                  CollateX variant graph represents <hi rend="italic">a set of text tokens</hi> that
                  originate from one or more versions; the tokens in a set are considered equal by
                  the CollateX collation algorithm. The main point being that the tokens are not
                  modeled on textual content, as is the case with the variant graph of Schmidt and
                  Colomb. In CollateX’s variant graph model, arbitrary tokens can be compared and
                  their correspondences, differences, and order can be represented in a variant
                  graph structure <ptr target="#collatex"/>. This seemingly small feature paves the
                  way for HyperCollate’s approach to collation.</p>
               <figure xml:id="figure03">
                  <head>Variant graph of CollateX: witness sigils on the edges and the text in the
                     nodes. Text that is considered as a match shares a node.</head>
                  <graphic url="resources/images/figure03.png"/>
               </figure>
               <p>HyperCollate uses a <hi rend="italic">hypergraph for textual variation</hi>. This
                  data structure is more flexible than trees, and it differs from regular variant
                  graphs in that it has <hi rend="italic">hyperedges</hi> which can connect multiple
                  nodes to one another. As a result, the nodes of a hypergraph can be traversed in
                  more than one order. Finally, the hypergraph data model of HyperCollate contains
                  text nodes as well as markup nodes. This means that the markup node of, say, a
                     <code>&lt;del&gt;</code> element can be connected to multiple text nodes which
                  do not immediately have to follow one another. As a result, it is possible to
                  express multiple, overlapping or nonlinear dimensions of a text in
                     markup.<note>For a more exhaustive discussion of the hypergraph model for
                     textual variation, see <ptr target="#bleeker2018"/> and <ptr
                        target="#bleeker2020"/>; for a discussion of the hypergraph for text see
                        <ptr target="#haentjens2017"/> and <ptr target="#haentjens2018"/>.</note>
                  Moreover, the hypergraph also enables the representation of individual witnesses
                  with in-text variance as a hypergraph (see <ref target="#figure04">figure
                  4</ref>).</p>
               <p>HyperCollate is trained on the two ways of encoding in-text revisions as proposed
                  by the TEI and discussed in section 2.2: it acts whenever it encounters either a
                     <code>&lt;subst&gt;</code>, an <code>&lt;app&gt;</code>, or their children
                     <code>&lt;del&gt;</code>, <code>&lt;add&gt;</code>, or
                  <code>&lt;rdg&gt;</code>. These TEI-XML elements are interpreted as instances of
                  nonlinear text, with the opening tags marking a break in the linear sequence of
                  the text characters, and the closing tags identifying the return to linearity.
                  Let's take for Witness 1 the same example of a simple TEI-XML transcription we
                  used above: 
                     <eg lang="xml"><![CDATA[
<s>The
   <subst>
      <del>quick</del>
      <add>brown</add>
   </subst> fox.
</s>]]></eg> Figure 4 shows the witness hypergraph of this example. Note that the
                  hypergraph contains not only information about the text of the witness, but also
                  its markup. In this visualization, the markup information is shown as an XPath. We
                  see, for instance, that the XPath of the text token <q>quick</q> is /s/subst/del. </p>
               <figure xml:id="figure04">
                  <head>Visualization of the hypergraph of Witness 1 (W1) as stored in
                     HyperCollate.</head>
                  <graphic url="resources/images/figure04.png"/>
               </figure>
               <p>Another way to visualize the hypergraph of Witness 1 is shown in <ref
                     target="#figure05">figure 5</ref>, below. Here, the tree of markup nodes is
                  projected onto the variant graph of the text. The text still reads from left to
                  right, with the stream of text temporarily separating into two concurrent
                  branches. The markup nodes that are associated with each text node in the XML tree
                  are visualized as colored nodes.</p>
               <figure xml:id="figure05">
                  <head>Different visualization of the hypergraphs of Witness 1 as stored by
                     HyperCollate, with the markup information visualized in colors.</head>
                  <graphic url="resources/images/figure05.png"/>
               </figure>
            </div>
            <div xml:id="section3-2">
               <head>3.2. HyperCollate</head>
               <p>Having illustrated how HyperCollate stores the information in a TEI-XML
                  transcription, we can now move on to demonstrate how this information is processed
                  and collated. </p>
               <figure xml:id="figure06">
                  <head>Schematic workflow of HyperCollate.</head>
                  <graphic url="resources/images/figure06.png"/>
               </figure>
               <p>Figure 6 represents the pipeline of HyperCollate. First, the TEI-XML transcribed
                  texts (here <q>XML witness 1</q> and <q>XML witness 2</q>) are transformed into
                  individual variant hypergraphs. These variant hypergraphs are subsequently
                  segmented and the resulting tokens are aligned. The alignment is carried out on
                  the level of the text; the markup elements <code>&lt;app&gt;</code> and
                     <code>&lt;subst&gt;</code> are recognized as occurrences of nonlinearity.
                  Subsequently, the resulting set of matches are merged with the two individual
                  hypergraph witnesses. The result of the collation is a collation hypergraph in
                  which all text nodes that are not aligned are unique to one of the two hypergraph
                  witnesses, and all the text nodes that are aligned are reduced to one node. There
                  are labels on the edges indicating which node is part of which hypergraph. For
                  every witness, then, there is always a fully connected path through the hypergraph
                  from the start text node to the end text node, following the sigils on the edges.
                  The collation hypergraph can be visualized or exported in alignment table format,
                  SVG, PNG, or dot format. If there are more than two witnesses, the result of that
                  first collation can be used as the basis of a new collation, following the method
                  of progressive alignment.<note> In short, the progressive alignment method of
                     collation means that two versions are compared, the result of which is stored
                     in a graph, against which a third version is collated. The result of that
                     comparison is merged into the graph, against which a fourth version is
                     collated, etc.</note>
               </p>
               <p>HyperCollate does not regard the input TEI-XML files as plain text files (which
                  would result in the aforementioned <q>flattening</q> of the input text): instead,
                  each input witness is transformed into a hypergraph and these individual witness
                  hypergraphs are subsequently collated against each other. In short, HyperCollate
                  can compare TEI-XML files with in-text revisions without having to convert them to
                  a plain text character string. During the alignment, HyperCollate looks at all
                  branches within each witness hypergraph. If the textual content of one branch (the
                  start of which is indicated by a <code>&lt;del&gt;</code>,
                     <code>&lt;add&gt;</code>, or an <code>&lt;rdg&gt;</code> open tag) has a match
                  in the other witness, the text is aligned; if not, the text remains in a separate
                  branch in the hypergraph. </p>
               <p>Furthermore, the tag names (<code>&lt;del&gt;</code>, <code>&lt;add&gt;</code>,
                     <code>&lt;rdg&gt;</code>, <code>&lt;subst&gt;</code>, and
                     <code>&lt;app&gt;</code>) are not only interpreted but preserved as well, in
                  order to enable further querying, transformation or visualization of the collation
                  result. The visualization of the information-rich collation hypergraph opens up
                  new possibilities and new questions. For example, if we visualize the collation
                  output as a variant graph, should we distinguish the paths that represent
                  variation within one witness from the paths constituted by variation between
                  different witnesses, and if so: how?</p>
               <p>As shown in section 3.3.3, <ref target="#figure20">figure 20</ref>, we have
                  currently opted for placing extra marks on the edges of the visualization of the
                  collation graph, right after the witness sigil: a minus [-] for an in-text
                  deletion and a plus [+] for an in-text addition. In case of an in-text
                  substitution within a substitution, this will lead to a sequence of multiple
                  [+][-] which may not lead to a clear visualization. Of course, we can say that at
                  this point the source manuscript text also presents a complex case of revision and
                  this complexity is merely reflected in the collation output. Nevertheless,
                  visualizing the collation produced by HyperCollate remains an interesting
                  challenge (see also <ptr target="#bleeker2019"/>).</p>
               <div>
                  <head>3.2.1 Deletions and Additions</head>
                  <p>Consider the example in <ref target="#figure07">figure 7</ref>, transcribed
                     first with the TEI <code>&lt;del&gt;</code>/<code>&lt;add&gt;</code> method,
                     and then with the TEI <code>&lt;app&gt;</code>/<code>&lt;rdg&gt;</code> method.
                        <figure xml:id="figure07">
                        <head>Reconstruction of a fragment from Samuel Beckett: Murphy, Draft
                           notebook, University of Reading, Cat. Nr. 5517/3, page 20r.</head>
                        <graphic url="resources/images/figure07.png"/>
                     </figure>
                     <dhq:example>
                        <head>Transcription using the TEI del/add method.</head><eg lang="xml"><![CDATA[
<xml>
   <s>& <add>finally</add> in what order he would eat the biscuits<del>, in the cockpit</del> when the time came.
   </s>
</xml>]]></eg></dhq:example>
                     <dhq:example>
                        <head>Transcription using the TEI app/rdg method.</head><eg lang="xml"><![CDATA[
<xml>
   <s>&
      <app>
         <rdg varSeq="1"/>
         <rdg varSeq="2">finally</rdg>
      </app> in what order he would eat the biscuits
      <app>
         <rdg varSeq="1">, in the cockpit</rdg>
         <rdg varSeq="2"/>
      </app> when the time came.
   </s>
</xml>]]></eg></dhq:example>
                  </p>
                  <div>
                     <head>Human expectations and algorithmic rules</head>
                     <p>With this TEI-XML transcription as one of the witnesses in the input for
                        HyperCollate, we expect that the collation output retains the information
                        about which words in a witness were in-text additions or deletions.
                        Additions or deletions demarcate the beginning of a split in HyperCollate’s
                        token stream. From that point on there are two substreams (the
                           <q>branches</q>): one with the <code>&lt;del&gt;</code> or
                           <code>&lt;add&gt;</code> and their textual content, and one without. The
                        substreams merge after the closing <code>&lt;/del&gt;</code> or
                           <code>/&lt;add&gt;</code> element.</p>
                  </div>
                  <div>
                     <head>Individual witness hypergraphs containing single addition(s) and
                        deletion(s)</head>
                     <p><ref target="#figure08">Figure 8</ref> shows the individual variant graph of
                        the witness with the <code>&lt;del&gt;</code>/<code>&lt;add&gt;</code>
                        tagging, and <ref target="#figure09">figure 9</ref> using the app/rdg method
                        of transcribing.</p>
                     <figure xml:id="figure08">
                        <head>Internal graph model of the del/add tagging of the example.</head>
                        <graphic url="resources/images/figure08.png"/>
                     </figure>
                     <figure xml:id="figure09">
                        <head>Internal graph model of the app/rdg tagging of the example.</head>
                        <graphic url="resources/images/figure09.png"/>
                     </figure>
                  </div>
               </div>
               <div>
                  <head>3.2.2 Instant Revisions</head>
                  <p><term>Instant revisions</term> or <foreign>currente calamo</foreign> changes
                     are revisions made within the initial writing of a sentence, with the change
                     occurring on the same line, made in one and the same writing session. They pose
                     a particular challenge for transcription, because they cannot be encoded as a
                     substitution: the demarcation of the added text is problematic. Would all of
                     the text following an instant deletion be an addition? The TEI Guidelines
                     propose to add the attribute @instant with the value <q>true</q>’ to the
                        <code>&lt;del&gt;</code> element, to distinguish between a regular
                     correction.</p>
                  <p>In the following example, Beckett wrote <quote rend="inline">threw up
                        his</quote> and then crossed the three words out to continue the sentence
                     with <quote rend="inline">gave such a jerk at Russell's arm that that poor
                        little man was nearly pulled off his feet.</quote></p>
                  <figure xml:id="figure10">
                     <head>Reconstruction of a fragment from Samuel Beckett: Murphy, Draft notebook,
                        University of Reading, Cat. Nr. 5517/2, page 16r</head>
                     <graphic url="resources/images/figure10.png"/>
                  </figure>
                  <p>In this case it not make sense to tag <q>gave such a jerk</q> as an addition,
                     not would it make sense to tag the rest of the sentence as such. </p>
                  <p>Hence we argue that an instant revision does <emph>not</emph> constitute a case
                     of nonlinear text. In contrast to regular in-text corrections and
                     substitutions, there is no other way of reading the text: the instant revision
                     is part of the same writing campaign as the text surrounding it. <dhq:example>
                        <head>Transcription using the TEI del/add method.</head>
                        <eg lang="xml"
                           ><![CDATA[<s>&amp; now <del instant="true">threw up his</del> gave such a jerk</s>]]>
                        </eg>
                     </dhq:example>
                  </p>
                  <div>
                     <head>Human expectations and algorithmic rules</head>
                     <p>Following our interpretation of an instant revision, we would
                           <emph>not</emph> want HyperCollate to treat it as an instance of
                        nonlinear text. An instant deletion should be considered to be part of the
                        same path as the text surrounding it. We do want the information about the
                        instant revision to be present in the output, so that we can visualize the
                        deletion appropriately. </p>
                  </div>
                  <div>
                     <head>Individual witness hypergraphs containing an instant revision</head>
                     <p>As the instant revision, encoded with <code>&lt;del
                           instant="true"&gt;</code>, does not trigger HyperCollate in the same way
                        a regular <code>&lt;del&gt;</code> does, the individual witness hypergraph
                        has only one path through the text. The information about the deletion is
                        retained (see <ref target="#figure11">figure 11</ref>).</p>
                     <figure xml:id="figure11">
                        <head>Internal graph model of an instant revision.</head>
                        <graphic url="resources/images/figure11.png"/>
                     </figure>
                  </div>
               </div>
               <div>
                  <head>3.2.3 Substitutions</head>
                  <p>Deletions followed by additions that are (semantically) related can be grouped
                     by means of a <code>&lt;subst&gt;</code> (substitution) element, or as two
                     readings in an <code>&lt;app&gt;</code> element. This can be illustrated with a
                     simple example from Beckett (see <ref target="#figure12">figure 12</ref>).
                        <figure xml:id="figure12">
                        <head>Reconstruction of a fragment from Samuel Beckett: Murphy, Draft
                           notebook, University of Reading, Cat. Nr. 5517/2, page 20r.</head>
                        <graphic url="resources/images/figure12.png"/>
                     </figure>
                     <dhq:example>
                        <head>Transcription using the TEI del/add method.</head><eg lang="xml"><![CDATA[
<xml>
   <subst>
      <del>Alice</del>
      <add>Cathleen</add>
   </subst> came.</p>
</xml>]]>
                        </eg></dhq:example>
                     <dhq:example>
                        <head>Transcription using the TEI app/rdg method.</head><eg lang="xml"><![CDATA[
<xml>
   <app>
      <rdg varSeq="1">Alice</rdg>
      <rdg varSeq="2">Cathleen</rdg>
   </app> came.</p>
</xml>]]></eg></dhq:example>
                  </p>
                  <div>
                     <head>Human expectations and algorithmic rules</head>
                     <p>With this TEI encoded input, we expect HyperCollate to recognize the
                        substitution as a break in the linearity of the text and to treat the two
                        parts in a nonlinear way. Moreover, since not all text encoders group
                           <code>&lt;del&gt;</code> and <code>&lt;add&gt;</code> elements within a
                           <code>&lt;subst&gt;</code> tag (see <ref target="#section2-3">section
                           2.3.</ref>, HyperCollate should differentiate between a substitution and
                        an unconnected deletion and addition by providing clear rules on how to
                        trigger its special treatment of substitutions for transcriptions that don’t
                        include <code>&lt;subst&gt;</code> elements. For now, HyperCollate
                        implements a heuristic: if a <code>&lt;del&gt;</code> element is directly
                        followed by an <code>&lt;add&gt;</code> element, unspaced, we take them as
                        belonging together, so the heuristic places a <code>&lt;subst&gt;</code>
                        around the two. If the <code>&lt;del&gt;</code> and <code>&lt;add&gt;</code>
                        elements are separated by a white space, they are not grouped together, and
                        treated in a linear way. Of course, as with all heuristics, this is not an
                        optimal solution, as some scholarly editors do use a white space between a
                           <code>&lt;del&gt;</code> and an <code>&lt;add&gt;</code> element, even if
                        they consider them to belong to the same substitution.</p>
                     <p>The <code>&lt;subst&gt;</code> or <code>&lt;app&gt;</code> element
                        demarcates the beginning of a split in HyperCollate’s token stream. From
                        that point on there are two substreams: one substream with the
                           <code>&lt;del&gt;</code> or first <code>&lt;rdg&gt;</code> element and
                        its textual content, and one substream with the <code>&lt;add&gt;</code> or
                        second <code>&lt;rdg&gt;</code> element and its textual content. The
                           <code>&lt;del&gt;</code>, <code>&lt;add&gt;</code>, and
                           <code>&lt;rdg&gt;</code> elements are unordered: they are at the same
                        distance gromfthe root node <code>&lt;xml&gt;</code>.</p>
                     <p>A <code>&lt;subst&gt;</code> element can contain more than one
                           <code>&lt;del&gt;</code> and more than one <code>&lt;add&gt;</code>
                        element. In principle each <code>&lt;del&gt;</code> and
                           <code>&lt;add&gt;</code> represents a new branch. A
                           <code>&lt;subst&gt;</code> can occur within another
                           <code>&lt;subst&gt;</code>, the result is simply that the stream of text
                        within that branch splits up again. </p>
                  </div>
                  <div>
                     <head>Hypergraph of a substitution</head>
                     <p><ref target="#figure13">Figure 13</ref> shows the internal graph model for
                        the substitution in the example encoded with the
                           <code>&lt;del&gt;</code>/<code>&lt;add&gt;</code> method.</p>
                     <figure xml:id="figure13">
                        <head>Internal hypergraph model of the <code>&lt;add&gt;</code>/
                              <code>&lt;del&gt;</code> tagging of the example. </head>
                        <graphic url="resources/images/figure13.png"/>
                     </figure>
                     <p>The <code>&lt;app&gt;</code>/<code>&lt;rdg&gt;</code> method equally divides
                        the token stream up into two paths (see <ref target="#figure14">figure
                           14</ref>).</p>
                     <figure xml:id="figure14">
                        <head>Internal hypergraph model of the app/rdg tagging of the
                           example.</head>
                        <graphic url="resources/images/figure14.png"/>
                     </figure>
                  </div>
               </div>
               <div xml:id="section3-2-4">
                  <head>3.2.4 Multiple Alignment Options in Longer Substitutions</head>
                  <p>In the case of the substitution of a group of words, there will usually be more
                     than one way to align the witnesses. The differences in alignment stem from a
                     difference in focus: does the scholarly editor want to give priority to the
                     unit of the substitution, or should the alignment of matching words receive
                     priority? The traditional approach in collation of starting from exact string
                     matches and grouping the variants in columns between the matches has the
                     advantage of accentuating the similarities between witnesses, but the unit of
                     the substitution can become obscured as it is spread over multiple columns.
                     Holding the substitution together in the alignment, on the other hand, keeps
                     the focus on the nonlinear nature of manuscripts as witnesses. It marks the
                     spot where <q>something happens</q> on the manuscript and the totality of a
                     textual operation is presented as one block. The drawback is a potential loss
                     of information if the occurrence of a matching word across witnesses is not
                     indicated in the collation output. </p>
                  <p>Consider the examples below. <figure xml:id="figure15">
                        <head>Reconstruction of a fragment from Samuel Beckett: Murphy, Draft
                           notebook, University of Reading, Cat. Nr. 5517/6, page 26r.</head>
                        <graphic url="resources/images/figure15.png"/>
                     </figure>
                     <dhq:example>
                        <head>Transcription using the TEI del/add method.</head>
                        <eg lang="xml"><![CDATA[
<xml>Murphy
   <subst>
      <del>seized him by the arm.</del>
      <add>stayed his hand.</add>
   </subst>
</xml>]]>
                        </eg></dhq:example>
                     <dhq:example>
                        <head>Transcription using the TEI app/rdg method.</head>
                        <eg lang="xml"><![CDATA[
<xml>Murphy
   <app>
      <rdg varSeq="1">seized him by the arm.</rdg>
      <rdg varSeq="2">stayed his hand.</rdg>
   </app>
</xml>]]></eg></dhq:example></p>
                  <p>Given a collation with two slightly different witnesses (B: <q>Murphy stayed
                        his hand.</q>, C: <q>Murphy stayed the arm.</q>), different scholarly
                     editors might arrive at different alignment tables, but they will largely fall
                     into one of two categories: alignment on matching tokens or on the unit of the
                     substitution. Currently, HyperCollate aligns the witnesses on the unit of
                     substitution and will produce the following alignment table:</p>
                  <figure xml:id="figure16">
                     <head>Collation output expressed in an ascii table with the alignment favouring
                        the unit of the substitution.</head>
                     <graphic url="resources/images/figure16.png"/>
                  </figure>
                  <p>In the future, HyperCollate aims to offer users two options in its output
                     alignment: to give dominance to the matching of tokens, or to preserve the unit
                     of the substitution as much as possible. Users will be then able to indicate
                     their preference by way of a parameter in the collation command. The collation
                     hypergraph and the two possible alignment options are discussed further in <ref
                        target="#section3-3-4">section 3.3.4</ref>.</p>
               </div>
            </div>

            <div xml:id="section3-3">
               <head>3.3. Collation Output Visualization</head>
               <p>Now that we have established the types of instances of nonlinearity and made our
                  expectations explicit of how HyperCollate should handle such instances, it is time
                  to discuss the current visualizations of the output of HyperCollate. </p>
               <div>
                  <head>3.3.1 Deletions and Additions</head>
                  <p>The collation hypergraph can be visualized, among other formats, as an
                     alignment table (see <ref target="#figure17">figure 17</ref>). </p>

                  <figure xml:id="figure17">
                     <head>ASCII alignment table of the collation output. In the TEI-XML
                        transcription, the in-text revisions in witness <q>A</q> were tagged with
                           <code>&lt;add&gt;</code> and <code>&lt;del&gt;</code>.</head>
                     <graphic url="resources/images/figure17.png"/>
                  </figure>
                  <p>In figure 16 the <q>[+]</q> and <q>[-]</q> in the <q>A</q> version correspond
                     to the <code>&lt;add&gt;</code> and <code>&lt;del&gt;</code> elements in the
                     input XML. In the case of the <code>&lt;app&gt;</code>/<code>&lt;rdg&gt;</code>
                     method, the value of the <code>@varSeq</code> attribute is included in the
                     output, as shown in <ref target="#figure18">figure 18</ref>.</p>
                  <figure xml:id="figure18">
                     <head>ASCII alignment table of the collation output, with the in-text revisions
                        in witness <q>A</q> coded with <code>&lt;app&gt;</code> and
                           <code>&lt;rdg&gt;</code>. </head>
                     <graphic url="resources/images/figure18.png"/>
                  </figure>

               </div>
               <div>
                  <head>3.3.2 Instant Revisions</head>
                  <p>Collated against a fictional second witness B, the instant revision produces
                     the following ASCII alignment table (<ref target="#figure19">figure 19</ref>).
                     Note that the visualization options of the ASCII alignment table are limited,
                     which is why the instant deletion is visualized as a regular deletion and the
                     text that follows, <q>gave such a,</q> is placed in the same cell and directly
                     above the instant deletion.</p>
                  <figure xml:id="figure19">
                     <head>ASCII alignment tables of the collation output of an instant
                        revision.</head>
                     <graphic url="resources/images/figure19.png"/>
                  </figure>
                  <p>The HTML alignment table is more expressive and produces a more accurate
                     visualization of the collation result (see <ref target="#figure20">figure
                        20</ref>).</p>
                  <figure xml:id="figure20">
                     <head>HTML alignment tables of the collation output of an instant
                        revision.</head>
                     <graphic url="resources/images/figure20.png"/>
                  </figure>
                  <p>The collation hypergraph visualization (<ref target="#figure21">figure
                     21</ref>), finally, demonstrates once more that the instant deletion does not
                     produce an alternative path through the text of witness A. The graph also shows
                     that even though the text tokens <q>&amp;</q> and <q>and</q> as well as
                        <q>jerk</q> and <q>pull</q> are aligned in the alignment table
                     visualization, they are not considered a match by the collation algorithm.</p>
                  <figure xml:id="figure21">
                     <head>Collation hypergraph of the collation output of an instant
                        revision.</head>
                     <graphic url="resources/images/figure21.png"/>
                  </figure>
               </div>
               <div>
                  <head>3.3.3 Substitutions</head>
                  <p><ref target="#figure22">Figure 22</ref> shows the ASCII alignment tables for a
                     collation of Beckett’s substitution of <q>Alice</q> with <q>Cathleen</q>
                     against another version stating <q>Cathleen came.</q> When the substitution is
                     encoded with the <code>&lt;del&gt;</code>/<code>&lt;add&gt;</code> method, the
                     word in the <code>&lt;del&gt;</code> element is preceded by <q>[-]</q>, and the
                     word in the <code>&lt;add&gt;</code> element with <q>[+]</q>. In the case of a
                     transcription that uses the <code>&lt;app&gt;</code>/<code>&lt;rdg&gt;</code>
                     method, HyperCollate reproduces the values of the <code>@varSeq</code>
                     attributes in the <code>&lt;rdg&gt;</code> elements.</p>
                  <figure xml:id="figure22">
                     <head>ASCII alignment tables of the collation output, del/add method on the
                        left, app/rdg on the right.</head>
                     <graphic url="resources/images/figure22.png"/>
                  </figure>
                  <p>The collation hypergraph (see <ref target="#figure23">figure 23</ref>), from
                     which the ASCII alignment tables are derived, holds the most contextual
                     information: each node contains a full XPath expression. In a case where two
                     witnesses match on a word, but are not on the same level of the XML tree, two
                     different XPath expressions are listed in the node, bringing both the
                     similarities and the differences to the user’s attention.</p>
                  <figure xml:id="figure23">
                     <head>The collation hypergraph of the substitution example.</head>
                     <graphic url="resources/images/figure23.png"/>
                  </figure>
                  <p>The instance of nonlinear text is visualized by two separate edges and nodes
                     labeled with the same siglum, <q>A</q>. In order to make it easier to follow
                     the path of a certain revision campaign, the edges contain not only information
                     about the witness sigil, but also whether the text is part of a deleted or
                     added branch. This information is visualized on the edges with [-] and [+]
                     signs for deletions and additions respectively. Furthermore, information that
                     is shared by more than one witness is given a thicker edge and node border (see
                     e.g., <ref target="#janicke2015">Jänicke et al. [2015]</ref>). In this example,
                     the words <q>Cathleen</q> and <q>came</q> are considered matches between A and
                     B and thus share text nodes with a thicker border. Finally, the information
                     about the location of the tag in the XML tree is added to the node as an XPath
                     expression.</p>
               </div>
               <div xml:id="section3-3-4">
                  <head>3.3.4 Longer Substitutions</head>
                  <p>In the case of a collation of the Beckett example shown in <ref
                        target="#figure15">figure15</ref> with two other witnesses (B: <q>Murphy
                        stayed his hand.</q>, C: <q>Murphy stayed the arm.</q>), the collation
                     hypergraph identifies two variant groups across the witnesses (<ref
                        target="#figure24">figure 24</ref>).</p>
                  <figure xml:id="figure24">
                     <head>Collation hypergraph of an example with three witnesses, one of which
                        contains a long substitution. </head>
                     <graphic url="resources/images/figure24.png"/>
                  </figure>
                  <p>HyperCollate can express this graph in two possible alignment tables.</p>
                  <div>
                     <head>Alignment on matching tokens</head>
                     <p>The first option presents an alignment of each of the matching tokens in a
                        separate column (<ref target="#figure25">figure 25</ref>). It splits the
                        substitution up into token-per-token units in which a deleted and added
                        token are placed together in a column based solely on their position in the
                        token stream. <figure xml:id="figure25">
                           <head>Collation output expressed in an ascii table with the alignment
                              favouring matching tokens.</head>
                           <graphic url="resources/images/figure25.png"/>
                        </figure> This alignment maximally emphasizes the matching words across
                        witnesses. </p>
                  </div>
                  <div>
                     <head>Alignment on the unit of the substitution</head>
                     <p>Alternatively, HyperCollate can take its lead from the unit of the
                        substitution to group words together in its output options, as in <ref
                           target="#figure26">figure 26</ref>. <figure xml:id="figure26">
                           <head>Collation output expressed in an ascii table with the alignment
                              favouring the unit of the substitution.</head>
                           <graphic url="resources/images/figure26.png"/>
                        </figure> In this particular example the two variant groups from the
                        collation graph are presented as separate columns without further
                        subdivision. A variant of the output in an HTML table draws attention to the
                        matching words in these columns (<q>stayed,</q>
                        <q>his hand</q> and <q>the arm</q>) by way of a corresponding background
                        color (see <ref target="#figure27">figure 27</ref>).</p>
                  </div>
               </div>
            </div>
            <figure xml:id="figure27">
               <head>Collation output expressed in an alignment table in HTML. </head>
               <graphic url="resources/images/figure27.png"/>
            </figure>
            <div xml:id="section3-4">
               <head>3.4. Evaluation</head>
               <p>In its genetic modules, the BDMP offers users the option of collating all the
                  prepublication versions of one particular sentence in a work by incorporating
                  on-the-fly collation with CollateX 1.7.1. By using CollateX’s pre-tokenized JSON
                  input feature and attaching the extra properties <q>del</q> and <q>add</q> to
                  tokens (<ref target="#section2-4-1">section 2.4.1</ref>), the BDMP can visualize
                  additions and deletions in the generated alignment tables in the same way as it
                  does in the transcription visualizations: deletions struck through and additions
                  in superscript. A comparison of the alignment tables from CollateX and
                  HyperCollate can illustrate the improvement of HyperCollate’s treatment of
                  witnesses in the collation process (see <ref target="#figure28">figure
                  28</ref>).</p>
               <figure xml:id="figure28">
                  <head>CollateX alignment (left) versus HyperCollate alignment (right) of the
                     example from section 3.2.3. </head>
                  <graphic url="resources/images/figure28.png"/>
               </figure>
               <p>Although the CollateX table adequately intuits the in-text revision on the
                  manuscript through the formatting convention, the alignment that CollateX outputs
                  is still conceptually less correct than a visualization that places <q>Alice</q>
                  and <q>Cathleen</q> on the same level. HyperCollate combines the advantages of the
                  two current approaches described in sections <ref target="#section2-4-1"
                     >2.4.1</ref> and <ref target="#section2-4-2">2.4.2</ref> and does not
                  have the drawbacks. A witness with in-text variation is treated as one witness
                  both in input and output, and the collation algorithm is able to align the two
                  parts of the substitution vertically instead of horizontally in its output by
                  treating them as unordered during alignment, which is a considerable step forward. </p>
               <figure xml:id="figure29">
                  <head>CollateX alignment (left) versus HyperCollate alignment (right) of the
                     example from section 3.2.4.</head>
                  <graphic url="resources/images/figure29.png"/>
               </figure>
               <p>In the case of the example discussed in sections <ref target="#section3-2-4"
                     >3.2.4</ref> and <ref target="#section3-3-4">3.3.4</ref>, the method of
                  collating as one linear witness with markup <q>passed along</q> (<ref
                     target="#section2-4-1">section 2.4.1</ref>), the CollateX output is inadequate,
                  as the alignment table in <ref target="#figure29">figure 28</ref> shows. Treating
                  the two parts of the substitution in a linear way is detrimental to the alignment.
                  The words <q>the arm</q> and <q>stayed</q> are transposed between the first and
                  third witness, and as <q>the arm</q> occurs first in the first witness, CollateX
                  marks <q>the arm</q> as invariant between those two witnesses in favor of aligning
                     <q>stayed</q> which occurs in all three witnesses. The HyperCollate output
                  succeeds quite well in conveying the nonlinearity in the first witness and
                  grouping and aligning the differences with the subsequent witnesses.</p>
               <p> Splitting the first version up into two (sub)versions as discussed in <ref
                     target="#section2-4-2">section 2.4.2</ref> produces the desired alignment (<ref
                     target="#figure30">figure 30</ref>), but misrepresents the manuscript by
                  including the word <q>Murphy</q> in version <q>A-layer1</q> as well as in
                     <q>A-layer2,</q> as the word <q>Murphy</q> only occurs once on the
                  document.</p>
               <figure xml:id="figure30">
                  <head>CollateX alignment table output with the substitution in version <q>A</q>
                     split up into two (sub)versions.</head>
                  <graphic url="resources/images/figure30.png"/>
               </figure>
            </div>
         </div>
         <div xml:id="section4">
            <head>4. Future Work</head>
            <p>At the moment of writing, HyperCollate can already be used via Github or in a Kotlin
                  notebook.<note> See the GitHub of the project here: <ref
                     target="https://github.com/HuygensING/hyper-collate"
                     >https://github.com/HuygensING/hyper-collate</ref>. HyperCollate can be tested
                  with small XML-TEI samples in this binder: <ref
                     target="https://mybinder.org/v2/gh/HuygensING/hyper-collate/master?filepath=notebooks%2Fhyper-collate-readme.ipynb"
                     >https://mybinder.org/v2/gh/HuygensING/hyper-collate/master?filepath=notebooks%2Fhyper-collate-readme.ipynb</ref>.
                  (last accessed October 22, 2021)</note> The collation tool is still in a prototype
               state and we can identify several areas of further development. On the one hand,
               these developments regard the tool’s functionalities, such as generating different
               output formats and collating witnesses regardless of the order in which they are
               inputted (<q>order independent collation</q>). At the moment, we use the progressive
               alignment method, which means that the order in which the witnesses are fed to the
               collation program influences the outcome. Evidently, we do not want the order in
               which the witnesses are inputted to affect the collation output, but this is a
               computationally highly complex issue for which as of yet no clear-cut solution has
               been found. </p>
            <p>Another area of future work is more philological, concerning questions such as <q>How
                  should HyperCollate handle open variants?</q> and <q>Can we include other types of
                  markup in the collation?</q> In the following paragraphs, we will briefly expand
               on these and other questions. </p>
            <div>
               <head>4.1. Output Formats</head>
               <p>The output of collation software is often used as the basis for further processing
                  or editorial correction. It is therefore important to offer a myriad of options
                  that can be edited afterwards. HyperCollate can currently output collations either
                  as a hypergraph (expressed in SVG, dot, PNG formats) or as an alignment table in
                  ASCII. An HTML implementation of a comparable table format is in development. </p>
               <p> We are also working on output expressed in XML. With the encoding schema we hope
                  to stay as close to the TEI parallel segmentation method as possible. As a
                  starting point we envisage the following: 
                     <eg lang="xml"><![CDATA[
   <app>
		<rdg wit="#A-" type="deletion" varSeq="1">
			<del>Alice</del>
		</rdg>
		<rdgGrp type="tag_variation_only">
			<rdg wit="#A+" type="addition" varSeq="2">
				<add>Cathleen</add></rdg>
			<rdg wit="#B">Cathleen</rdg>
		</rdgGrp>
	</app> came.]]></eg></p>
               <p>This encoding complies with the TEI guidelines except that, like in the collation
                  hypergraphs, a <q>+</q> or a <q>-</q> is added to the siglum <q>A</q> when that
                  version splits up into two branches which are placed in two
                     <code>&lt;rdg&gt;</code> elements. As the XML counterpart of a node in the
                  graph where the witnesses have the same text but a different XML context, they are
                  placed as separate readings in a reading group (<code>&lt;rdgGrp&gt;</code>). The
                  element has a @type attribute with the value <q>tag_variantion_only</q> to
                  indicate that the readings only differ in the level of the XML elements. The
                  schema is feasible when it concerns simple substitutions, but we will need to
                  determine how well it handles long substitutions or substitutions within
                  substitutions.</p>
            </div>
            <div>
               <head>4.2. Substitutions Within a Word</head>
               <p>Substitutions on the character-level within a word constitute a particular
                  challenge to the automatic collation process. HyperCollate works at the
                  granularity level of the word as a token, and revisions within a word produce
                  isolated characters as tokens.</p>

               <figure xml:id="figure31">
                  <head>Samuel Beckett: Murphy, Typescript, Harry Ransom Center, Cat. Nr. SB 5/2,
                     page 11r.</head>
                  <graphic url="resources/images/figure31.jpg"/>
               </figure>
               <p>In TEI-XML, Beckett’s typo in <q>Scratch</q> (<ref target="#figure31">figure
                     31</ref>) could be transcribed as:
                     Scratc<code>&lt;del&gt;</code>g<code>&lt;/del&gt;</code><code>&lt;add&gt;</code>h<code>&lt;/add&gt;</code>.
                  Currently this encoding produces three separate tokens: <q>Scratc,</q>
                  <q>g</q> and <q>h,</q> none of which will be aligned with the occurrence of
                     <q>Scratch</q> in another version. This is a very challenging problem for any
                  collation algorithm, because it creates the need for an alignment within an
                  alignment: aligning words in a first step and characters subsequently.</p>
               <p>There are a few avenues of development to consider. An approach of
                     <q>near-matching</q> might produce adequate results. Another option would be to
                  encode the entire word within a <code>&lt;mod&gt;</code> element:
                     &lt;mod&gt;Scratc&lt;del&gt;g&lt;/del&gt;&lt;add&gt;h&lt;/add&gt;&lt;/mod&gt;,<note>
                     Here we choose &lt;mod&gt; instead of &lt;subst&gt; because a &lt;subst&gt;
                     element cannot contain text.</note> which could trigger HyperCollate to
                  translate this into
                     <code>&lt;subst&gt;</code><code>&lt;del&gt;</code>Scratcg<code>&lt;/del&gt;</code><code>&lt;add&gt;</code>Scratch<code>&lt;/add&gt;</code><code>&lt;/subst&gt;</code>.
                  Finally, using the <code>&lt;app&gt;</code>/<code>&lt;rdg&gt;</code> transcription
                  method, a construction with an extra reading, <code>&lt;rdg
                     type="lit"&gt;</code>,<note>Cf. Barbara Bordalejo: <title rend="quotes">The
                        Commedia Project Encoding System</title>
                     <ref
                        target="http://sd-editions.com/AnaServer?commedia+6215691+viewarticle.anv+printdoc=1"
                        >http://sd-editions.com/AnaServer?commedia+6215691+viewarticle.anv+printdoc=1</ref>.
                     (last accessed October 22, 2021)</note> might be considered: </p>
               
                  <eg lang="xml"><![CDATA[
       <app>
          <rdg wit="A" varSeq="1">Scratcg</rdg>
          <rdg wit="B" varSeq="2">Scratch</rdg>
          <rdg type="lit">Scratc<del>g</del><add>h</add></rdg>
       </app>.
]]></eg>
               
            </div>
            <div>
               <head>4.3. Open Variants</head>
               <p>Open variants are also an example of nonlinearity in text. The TEI guidelines
                  suggest that open variants should be encoded with a <code>&lt;seg&gt;</code>
                  element around the inline part of the open variant, followed by one or more
                     <code>&lt;add&gt;</code> elements. For HyperCollate to apply the same treatment
                  to open variants as to substitutions, it will need to recognize a
                     <code>&lt;seg&gt;</code> element and treat it in a similar way to
                     <code>&lt;del&gt;</code> or <code>&lt;add&gt;</code>. Because the
                     <code>&lt;seg&gt;</code> is a general element with several uses, HyperCollate
                  will have to look for a <code>&lt;seg&gt;</code> element with a @type attribute
                  with the value <q>alternative.</q>
               </p>
            </div>
            <div>
               <head>4.4. Transpositions</head>
               <p>A transposition <quote rend="inline">occurs when metamarks are found in a document
                     indicating that passages should be moved to a different position.</quote><note>
                     <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#transpo"
                        >https://tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#transpo</ref>.
                     (last accessed October 22, 2021)</note>
               </p>
               <figure xml:id="figure32">
                  <head>Samuel Beckett: Malone Dies, Typescript, Washington University, Cat. Nr.
                     MSS008/2/47, page 49r.</head>
                  <graphic url="resources/images/figure32.png"/>
               </figure>
               <p>To tag transpositions, the TEI proposes that both parts be tagged in an element
                  with a @xml:id attribute (the element most commonly used is
                     <code>&lt;seg&gt;</code>), and that the two tags be declared as a transposition
                  inside the teiHeader, in a <code>&lt;transpose&gt;</code> element within a
                     <code>&lt;listTranspose&gt;</code>. The use of
                     <code>@type="transposition"</code> inside the <code>&lt;seg&gt;</code> is not
                  required.</p>
               <p>A transposition can be said to be a nonlinear textual feature; it signals two
                  possible readings of a fragment with a difference in word order. Transposition
                  metamarks, however, do not violate the linearity of the text, as the text fragment
                  does not have two alternatives for one word or phrase, but merely suggests a
                  reordering of two or more words. A special treatment by HyperCollate of this
                  textual feature is not needed to provide a meaningful result. Currently, the
                  source XML is handled by HyperCollate linearly like all other material. The actual
                  word order is collated, and the second, implied order can still be deduced from
                  the markup in the transcription. The same applies to transpositions of letters
                  within words.</p>
               <p>Making the two word orders explicit in the
                     <code>&lt;app&gt;</code>/<code>&lt;rdg&gt;</code> method of transcription,
                  however, will allow for the two versions to be collated: 
                     <eg lang="xml"><![CDATA[
<s>and saw it could <app type="transposition"><rdg varSeq="1">be still</rdg><rdg varSeq="2">still be</rdg></app> made to serve.</s>]]></eg>
                  
               </p>
            </div>
         </div>
         <div xml:id="section5">
            <head>5. Conclusion</head>
            <p>In-text variation is essential for the study of textual variance and the TEI
               Guidelines offer several ways to encode this kind of information. Consequently, the
               need to include the information in the automatic collation of manuscript texts is
               apparent. Up to now, including in-text variation was only possible through
               workarounds that either require significant coding skills from the users – passing
               along markup tags as shadow-tokens on the JSON input of CollateX – or by manually
               creating pseudo-versions from the layers of in-text variation and treating them as
               regular versions. These approaches do ensure that information about the in-text
               variation is present in the collation output so that the nonlinear features of the
               individual witnesses can be visually reconstructed. However, the information is not
               part of the alignment process itself: the collation tools treat the input texts as a
               linear, ordered stream of characters and thus ignore the multilayered character of
               manuscript text.</p>
            <p>In this paper, we argued that in-text variation provides meaningful information about
               the temporality of the writing process. We demonstrated that this type of variation
               constitutes nonlinear, partially ordered data and we argued that it should be treated
               as such by collation software. We therefore set out to develop a collation program,
               HyperCollate, that understands each witness as a stream of text tokens that splits
               into two or more <q>branches</q> at the point where the internal variation occurs and
               converges at the end of the variation. The occurrences of variation are marked by the
               scholarly editor with designated TEI-XML tags. HyperCollate thus produces a collation
               output that represents the multidimensional nature of the source text more adequately
               and thus corresponds with how the in-text variation was conceptualized and encoded. </p>
            <p>The paper began with a description of our understanding of different types of in-text
               variation, and subsequently illustrated how that understanding translates logically.
               We then illustrated how the input of HyperCollate, TEI-XML transcriptions, are
               transformed into individual witness hypergraphs with partially ordered textual data.
               HyperCollate compares two witness hypergraphs and finds the best match between the
               branches of text. In case of more witnesses, HyperCollate compares them
               progressively. Accordingly, the TEI-XML transcriptions that hold so much scholarly
               information can be used as direct input without any need for pre-processing or
               flattening. We concluded that including the in-text variation produces a more refined
               output that more accurately represents the textual variation as interpreted by the
               scholarly editor during the transcription phase.</p>
            <p>One interesting finding is that in case of a longer substitution, the best way to
               collate versions with in-text variation depends on the preference of the scholarly
               editor. They can either prefer to have the collation program align on the unit of
               substitution, or to align on the individual words within the substitution. Future
               users of HyperCollate will be able to indicate their preference in the collation
               command. We also found that the visualization of HyperCollate’s in- and output may
               depend on the user’s preference. Both the input (a witness hypergraph) and the output
               (a collation hypergraph) of HyperCollate can be visualized as variant hypergraphs
               with or without markup nodes as colored hyperedges.</p>
            <p>The visualizations are an attempt to provide more insight into the text and its
               revisions, but visualizing such a complex data structure is quite challenging. The
               output of HyperCollate simply contains a lot of information, and it is difficult to
               visualize all that information in a clear and insightful way. This becomes evident
               with the alignment table visualization: the alignment table allows scholarly editors
               to see at a glance which words are added and deleted, but at the same time using the
               [-] and [+] signs for in-text deletions and additions simplify the revision process.
               Still, an alignment table is generally easier to read than a collation hypergraph,
               and so far user-testing has shown that the alignment table does feel intuitive to
               scholarly editors. We will continue to experiment with the visualizations of the
               collation hypergraph, e.g., by adding [-] and [+] signs on the edges of the collation
               hypergraph or by using thicker edges if a token is present in many versions. </p>
            <p>In conclusion, this article aimed to show how formalizing our understanding of
               in-text variation as nonlinear, partially ordered text can help to communicate our
               human understanding to a collation tool. We trained HyperCollate on two TEI encoding
               suggestions for in-text variation, app/rdg and subst/del/add, in order to illustrate
               that the formalization can work for different encoding styles. The larger argument
               made in this article concerns the benefits of reflecting upon our textual models and
               to what extent they impact our encoding models and subsequently the in- and output of
               text analysis tools. </p>
            <p>The development of HyperCollate was propelled by a knowledge exchange between textual
               scholars and research software engineers. This exchange took the form of long
               discussions, much prototyping, experimenting, and testing. Realizing the value of our
               collaboration and ongoing knowledge exchange, we have tried to be transparent about
               our methodology and detailed our textual theories and expectations of the software as
               well as the decision making process of HyperCollate. Indeed, we found collaborating
               on the development of a collation program an insightful, iterative learning process
               that emphasizes the benefits of including computational methods in manuscript
               research. </p>
         </div>
      </body>
      <back>
         <listBibl>
            <bibl xml:id="andrews2013" label="Andrews 2013">Andrews, Tara. 2013. <title
                  rend="quotes">The third way: philology and critical edition in the digital
                  age.</title>
               <title rend="italic">Variants</title>, vol. 10, pp. 61–76.</bibl>
            <bibl xml:id="andrewsmace2013" label="Andrews and Macé 2013">Andrews, Tara L. and Macé,
               Caroline, 2013. <title rend="quotes">Beyond the tree of texts: Building an empirical
                  model of scribal variation through graph analysis of texts and stemmata.</title>
               <title rend="italic">Literary and Linguistic Computing</title>, vol. 28, issue 4, pp.
               504-521.</bibl>
            <bibl xml:id="barabucci2013" label="Barabucci et al. 2013">Barabucci, Gioele, Borghoff,
               Uwe, Di Iorio, Angelo and Schimmler, Sonja. 2013. <title rend="quotes">Document
                  Changes: Modeling; Detection; Storing and Visualization (DChanges).</title>
               Presented at the 2013 ACM Symposium on Document Engineering (DocEng 2013) in
               September 10-13, 2013, Florence, Italy. DOI: <ref
                  target="http://dx.doi.org/10.1145/2494266.2494322"
                  >http://dx.doi.org/10.1145/2494266.2494322</ref>. </bibl>
            <bibl xml:id="barabucci2018" label="Barabucci 2018">Barabucci, Gioele. 2018. <title
                  rend="quotes">Diffi: diff improved; a preview.</title> Presented at the 2018 ACM
               Symposium on Document Engineering (DocEng 2018), August 28-31, 2018, Halifax, Canada.
                  <title rend="italic">Proceedings of the ACM Symposium on Document Engineering
                  2018</title>, pp. 1-4.</bibl>
            <bibl xml:id="barabucci2020" label="Barabucci 2020">Barabucci, Gioele. 2020. <title
                  rend="quotes">The CMV+ P Document Model, Linear Version.</title>
               <title rend="italic">Versioning Cultural Objects: Digital Approaches</title>, vol.
               13, pp. 153-170.</bibl>
            <bibl xml:id="birnbaum2015" label="Birnbaum 2015">Birnbaum, David. 2015. <title
                  rend="quotes">Using CollateX with XML: Recognizing and Tracking Markup Information
                  During Collation.</title> Computer-supported collation with CollateX. Online: <ref
                  target="http://collatex.obdurodon.org/xml-json-conversion.xhtml"
                  >http://collatex.obdurodon.org/xml-json-conversion.xhtml</ref> (last accessed
               October 22, 2021).]</bibl>
            <bibl xml:id="bleeker2018" label="Bleeker et al. 2018">Bleeker, Elli, Bram Buitendijk,
               Ronald Haentjens Dekker, and Astrid Kulsdom. <title rend="quotes">Including XML
                  markup in the automated collation of literary text.</title> Presented at the XML
               Prague conference 2018, February 8-10, 2018. <title rend="italic">XML Prague
                  Conference Proceedings</title>, pp. 77-96. Available at <ref
                  target="http://archive.xmlprague.cz/2018/files/xmlprague-2018-proceedings.pdf#page=89"
                  >http://archive.xmlprague.cz/2018/files/xmlprague-2018-proceedings.pdf#page=89</ref>
               (last accessed October 22, 2021).</bibl>
            <bibl xml:id="bleeker2019" label="Bleeker et al. 2019">Bleeker, Elli, Bram Buitendijk,
               and Ronald Haentjens Dekker. 2019. <title rend="quotes">From Graveyard to Graph:
                  Visualisation of Textual Collation in a Digital Paradigm.</title>
               <title rend="italic">International Journal of Digital Humanities / Special Issue on
                  Digital Scholarly Editing</title>, vol. 1, issue 2, pp. 141-163.</bibl>
            <bibl xml:id="bleeker2020" label="Bleeker 2020">Bleeker, Elli, Bram Buitendijk and
               Ronald Haentjens Dekker. <title rend="quotes">Marking up microrevisions with major
                  implications: Non-linear text in TAG.</title> 2020. Presented at Balisage: The
               Markup Conference 2020, Washington, DC, July 27 - 31, 2020. <title rend="italic"
                  >Proceedings of Balisage: The Markup Conference 2020. Balisage Series on Markup
                  Technologies</title>, vol. 25. <ref
                  target="https://doi.org/10.4242/BalisageVol25.Bleeker01"
                  >https://doi.org/10.4242/BalisageVol25.Bleeker01</ref>. </bibl>
            <bibl xml:id="bordalejo2013" label="Bordalejo 2013">Bordalejo, Barbara. 2013. <title
                  rend="quotes">The Texts We See and the Works We Imagine: The Shift of Focus of
                  Textual Scholarship in the Digital Age.</title>
               <title rend="italic">Ecdotica </title>10: 64-76.</bibl>
            <bibl xml:id="ciula2014" label="Ciula and Eide 2014">Ciula, Arianna, And Øyvind Eide.
               2014. <title rend="quotes">Reflections on Cultural Heritage and Digital Humanities:
                  Modelling in Practice and Theory.</title>
               <title rend="italic">Proceedings of the First International Conference on Digital
                  Access to Textual Cultural Heritage</title>. New York: ACM.</bibl>
            <bibl xml:id="collatex" label="CollateX">Haentjens Dekker, Ronald and Gregor Middell.
               2015. The Interedition Development Group <title rend="italic">CollateX</title>
               (version 1.7.1). [Computer program]. Available at: <ref
                  target="https://collatex.net/">https://collatex.net/</ref> and <ref
                  target="https://mvnrepository.com/artifact/eu.interedition/collatex/1.7.1"
                  >https://mvnrepository.com/artifact/eu.interedition/collatex/1.7.1</ref>.</bibl>
            <bibl xml:id="colwell1964" label="Colwell and Tune 1964">Colwell, Ernest C., and Ernest
               W. Tune. 1964. <title rend="quotes">Variant Readings: Classification and Use.</title>
               <title rend="italic">Journal of Biblical Literature</title> 83.3, pp. 253-261.</bibl>
            <bibl xml:id="derose2004" label="DeRose 2004">DeRose, Steve. 2004. <title rend="quotes"
                  >Markup Overlap: a review and a horse.</title> Presented at <title rend="italic"
                  >Extreme Markup Languages 2004</title>. Montréal, Québec, August 2-6, 2004. <ref
                  target="http://xml.coverpages.org/DeRoseEML2004.pdf"
                  >http://xml.coverpages.org/DeRoseEML2004.pdf</ref> (last accessed October 22,
               2021).</bibl>
            <bibl xml:id="ferrer2014" label="Ferrer 2014">Ferrer, Daniel. 2014. <title rend="italic"
                  >James Joyce: Brouillons d’un baiser. Premiers pas vers Finnegans Wake</title>.
               Paris: Editions Gallimard.</bibl>
            <bibl xml:id="gresillon1994" label="Grésillon 1994">Grésillon, Almuth. 1994. <title
                  rend="italic">Eléments de critique génétique lire les manuscrits modernes.</title>
               Paris: Presses universitaires de France.</bibl>
            <bibl xml:id="haentjens2017" label="Haentjens Dekker and Birnbaum 2017">Haentjens
               Dekker, Ronald, and David J. Birnbaum. 2017. <title rend="quotes">It's more than just
                  overlap: Text As Graph.</title> Presented at Balisage: The Markup Conference 2017,
               Washington, DC, August 1 - 4, 2017. <title rend="italic">Proceedings of Balisage: The
                  Markup Conference 2017. Balisage Series on Markup Technologies</title>, vol. 19.
                  <ref target="https://doi.org/10.4242/BalisageVol19.Dekker01"
                  >https://doi.org/10.4242/BalisageVol19.Dekker01</ref>. </bibl>
            <bibl xml:id="haentjens2018" label="Haentjens et al. 2018">Haentjens Dekker, Ronald,
               Elli Bleeker, Bram Buitendijk, Astrid Kulsdom and David J. Birnbaum. 2018. <title
                  rend="quotes">TAGML: A markup language of many dimensions.</title> Presented at
               Balisage: The Markup Conference 2018, Washington, DC, July 31 - August 3, 2018.
                  <title rend="italic">Proceedings of Balisage: The Markup Conference 2018. Balisage
                  Series on Markup Technologies</title>, vol. 21. <ref
                  target="https://doi.org/10.4242/BalisageVol21.HaentjensDekker01"
                  >https://doi.org/10.4242/BalisageVol21.HaentjensDekker01</ref>.</bibl>
            <bibl xml:id="janicke2015" label="Janicke et al. 2015">Jänicke, Stefan, Annette Geßner,
               Greta Franzini, Melissa Terras, Simon Mahony, and Gerik Scheuermann. 2015. <title
                  rend="quotes">TRAViz: A visualization for variant graphs.</title>
               <title rend="italic">Digital Scholarship in the Humanities</title> vol. 30, issue
               suppl. 1, pp. i83-99.</bibl>
            <bibl xml:id="kline1998" label="Kline 1998">Kline, Mary-Jo. 1998. <title rend="italic">A
                  Guide to Documentary Editing.</title> Baltimore: John Hopkin's University
               Press.</bibl>
            <bibl xml:id="lebrave1992" label="Lebrave 1992">Lebrave, Jean-Louis. 1992. <title
                  rend="quotes">La critique génétique: une discipline nouvelle ou un avatar de la
                  philologie?</title>
               <title rend="italic">Genesis</title> 1, pp. 33-72. </bibl>
            <bibl xml:id="nury2018" label="Nury 2018">Nury, Elisa. 2018. <title rend="italic"
                  >Automated Collation and Digital Editions: From Theory to Practice</title>. PhD
               thesis, London: King's College London. Available at: <ref
                  target="https://kclpure.kcl.ac.uk/portal/en/theses/automated-collation-and-digital-editions(1ffc4aa0-5ad5-4ca1-869a-ab3d528eed4a).html"
                  >https://kclpure.kcl.ac.uk/portal/en/theses/automated-collation-and-digital-editions(1ffc4aa0-5ad5-4ca1-869a-ab3d528eed4a).html</ref>
               (last accessed October 22, 2021).</bibl>
            <bibl xml:id="peters2005" label="Peters 2005">Peters, Luuk. 2005. <title rend="quotes"
                  >Change detection in XML trees: a survey.</title>
               <title rend="italic">3rd Twente Student Conference on IT</title>. Available at <ref
                  target="http://www-poleia.lip6.fr/~gancarsk/grbd09/2005_03_B_Peters,L.J.-Change_detection_in_XML_trees_a_survey.pdf"
                  >http://www-poleia.lip6.fr/~gancarsk/grbd09/2005_03_B_Peters,L.J.-Change_detection_in_XML_trees_a_survey.pdf</ref>
               (last accessed October 22, 2021). </bibl>
            <bibl xml:id="pierazzo2015" label="Pierazzo 2015">Pierazzo, Elena. 2015. <title
                  rend="italic">Digital Scholarly Editing: Theories, Models and Methods</title>.
               Surrey: Ashgate Publishing, Ltd.</bibl>
            <bibl xml:id="plachta1997" label="Plachta 1997">Plachta, Bodo. 1997. <title
                  rend="italic">Editionswissenschaft: eine Einführung in Methode und Praxis der
                  Edition neuerer Texte</title>. Stuttgart: Reclam.</bibl>
            <bibl xml:id="scheibe1995" label="Scheibe 1995">Scheibe, Siegfried. 1995. <title
                  rend="quotes">On the Editorial Problem of the Text.</title>
               <title rend="italic">Contemporary German Editorial Theory</title>. eds. Hans Walter
               Gabler, George Bornstein and Gillian Borland Pierce. Ann Arbor: The University of
               Michigan Press.</bibl>
            <bibl xml:id="schmidt2009" label="Schmidt and Colomb 2009">Schmidt, Desmond and Robert
               Colomb. 2009. <title rend="quotes">A data structure for representing multi-version
                  texts online.</title>
               <title rend="italic">International Journal of Human-Computer Studies</title>, vol.
               67, issue 6, pp. 497-514. <ref target="http://dx.doi.org/10.1016/j.ijhcs.2009.02.001"
                  >http://dx.doi.org/10.1016/j.ijhcs.2009.02.001</ref>
            </bibl>
            <bibl xml:id="schmidt2019" label="Schmidt 2019">Schmidt, Desmond. 2019. <title
                  rend="quotes">A Model of Versions and Layers.</title> In <title rend="italic"
                  >Digital Humanities Quarterly</title>, vol. 13, no. 3, available from <ref
                  target="http://digitalhumanities.org/dhq/vol/13/3/000430/000430.html"
                  >http://digitalhumanities.org/dhq/vol/13/3/000430/000430.html</ref>. </bibl>
            <bibl xml:id="shillingsburg1996" label="Shillingsburg 1996">Shillingsburg, Peter. 1996.
                  <title rend="italic">Scholarly Editing in the Computer Age: Theory and
                  Practice</title> (3rd Edition). Ann Arbor, Mich.: University of Michigan
               Press.</bibl>
            <bibl xml:id="sperberg-mcqueen1989" label="Sperberg-McQueen 1989">Sperberg-McQueen, C.
               1989. <title rend="quotes">A directed-graph data structure for text
                  manipulation</title>. Paper presented at the <title rend="italic">The 9th
                  International Conference on Computers and the Humanities (ICCH) and 16th
                  International Association for Literary and Linguistic Computing (ALLC)
                  Conference</title>, University of Toronto, June 1989. Available from <ref
                  target="http://www.w3.org/People/cmsmcq/1989/rhine-delta-abstract.html"
                  >http://www.w3.org/People/cmsmcq/1989/rhine-delta-abstract.html</ref>.</bibl>
            <bibl xml:id="vanhulle1999" label="Van Hulle 1999">Van Hulle, Dirk. 1999. <title
                  rend="quotes">Authenticity or hyperreality in hypertext editions: notes towards a
                  searcheable recherche.</title>
               <title rend="italic">Human IT: journal for information technology studies as a human
                  science</title>, vol. 1, pp. 227-244.</bibl>
            <bibl xml:id="vanhulle2004" label="Van Hulle 2004">Van Hulle, Dirk. 2004. <title
                  rend="quotes">Compositional Variants in Modern Manuscripts.</title>
               <title rend="italic">Digital Technology and Philological Disciplines</title>, pp.
               513-527.</bibl>
            <bibl xml:id="zeller1975" label="Zeller 1975">Zeller, Hans. 1975. <title rend="quotes">A
                  New Approach to the Critical Constitution of Literary Texts</title>. <title
                  rend="italic">Studies in Bibliography</title>, vol. 28, pp. 231-264.</bibl>
         </listBibl>
      </back>
   </text>
</TEI>
