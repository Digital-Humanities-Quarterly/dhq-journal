<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="../../common/schema/DHQauthor-TEI.rng" type="xml"?>
<?oxygen SCHSchema="../../common/schema/dhqTEI-ready.sch"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:cc="http://web.resource.org/cc/"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:dhq="http://www.digitalhumanities.org/ns/dhq"
   xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <!--Author should supply the title and personal information-->
            <title type="article" xml:lang="en">Layers of Variation: a Computational Approach to
               Collating Texts with Revisions</title>
            <!--Add a <title> with appropriate @xml:lang for articles in languages other than English-->
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Elli <dhq:family>Bleeker</dhq:family>
               </dhq:author_name>
               <dhq:affiliation/>
               <email>elli.bleeker@di.huc.knaw.nl</email>
               <dhq:bio>
                  <p/>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Bram <dhq:family>Buitendijk</dhq:family>
               </dhq:author_name>
               <dhq:affiliation/>
               <email>bram.buitendijk@di.huc.knaw.nl</email>
               <dhq:bio>
                  <p/>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Ronald Haentjens <dhq:family>Dekker</dhq:family>
               </dhq:author_name>
               <dhq:affiliation/>
               <email>ronald.dekker@di.huc.knaw.nl</email>
               <dhq:bio>
                  <p/>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Vincent <dhq:family>Neyt</dhq:family>
               </dhq:author_name>
               <dhq:affiliation/>
               <email>vincent.neyt@uantwerpen.be</email>
               <dhq:bio>
                  <p/>
               </dhq:bio>
            </dhq:authorInfo>
            <dhq:authorInfo>
               <!--Include a separate <dhq:authorInfo> element for each author-->
               <dhq:author_name>Dirk Van <dhq:family>Hulle</dhq:family>
               </dhq:author_name>
               <dhq:affiliation/>
               <email>dirk.vanhulle@ell.ox.ac.uk</email>
               <dhq:bio>
                  <p/>
               </dhq:bio>
            </dhq:authorInfo>
         </titleStmt>
         <publicationStmt>
            <publisher>Alliance of Digital Humanities Organizations</publisher>
            <publisher>Association for Computers and the Humanities</publisher>
            <!--This information will be completed at publication-->
            <idno type="DHQarticle-id">000583</idno>
            <idno type="volume">015</idno>
            <idno type="issue">4</idno>
            <date/>
            <dhq:articleType>article</dhq:articleType>
            <availability>
               <cc:License rdf:about="http://creativecommons.org/licenses/by-nd/2.5/"/>
            </availability>
         </publicationStmt>
         <sourceDesc>
            <p>This is the source</p>
         </sourceDesc>
      </fileDesc>
      <encodingDesc>
         <classDecl>
            <taxonomy xml:id="dhq_keywords">
               <bibl>DHQ classification scheme; full list available at <ref
                     target="http://www.digitalhumanities.org/dhq/taxonomy.xml"
                     >http://www.digitalhumanities.org/dhq/taxonomy.xml</ref>
               </bibl>
            </taxonomy>
            <taxonomy xml:id="authorial_keywords">
               <bibl>Keywords supplied by author; no controlled vocabulary</bibl>
            </taxonomy>
         </classDecl>
      </encodingDesc>
      <profileDesc>
         <langUsage>
            <language ident="en" extent="original"/>
            <!--add <language> with appropriate @ident for any additional languages-->
         </langUsage>
         <textClass>
            <keywords scheme="#dhq_keywords">
               <!--Authors may suggest one or more keywords from the DHQ keyword list, visible at http://www.digitalhumanities.org/dhq/taxonomy.xml; these may be supplemented or modified by DHQ editors-->
               <list type="simple">
                  <item/>
               </list>
            </keywords>
            <keywords scheme="#authorial_keywords">
               <!--Authors may include one or more keywords of their choice-->
               <list type="simple">
                  <item/>
               </list>
            </keywords>
         </textClass>
      </profileDesc>
      <revisionDesc>
         <!--Each change should include @who and @when as well as a brief note on what was done.-->
         <change/>
      </revisionDesc>
   </teiHeader>
   <text xml:lang="en" type="original">
      <front>
         <dhq:abstract>
            <!--Include a brief abstract of the article-->
            <p/>
         </dhq:abstract>
         <dhq:teaser>
            <!--Include a brief teaser, no more than a phrase or a single sentence-->
            <p/>
         </dhq:teaser>
      </front>
      <body>
         <div>
            <head>1. Introduction</head>
            <p>The act of comparing textual versions has always been central to textual criticism
               and manuscript research. The importance of this type of collation has only increased
               in the digital age. Most scholarly editors no longer produce collations by hand; they
               use the output generated by software, either as is, or as the starting point for
               manual correction. Still, in more complex cases such as manuscripts with in-text
               variation – i.e., textual variation within one text version – it remains difficult to
               have the software produce a collation result that corresponds with what a scholarly
               editor would produce. The reason for this is, simply put, that the collation software
               treats the input as linear text, whereas text with revisions is not completely
               linear. As a consequence, scholarly editors still need to do quite some manual work,
               such as preparing the input texts or adjusting the collation output. What is more,
               they lose information about the multilayered nature of the document and the physical
               traces of the writing process or transmission history. </p>
            <p>We therefore set out to create collation software that is able to compare texts with
               revisions. When working on this challenge, we soon realized that conveying our human
               interpretation of text with revisions to the computer is not merely a technical
               matter. It is, in fact, deeply rooted in philological questions: what do we
               understand by text with revisions? What type of revisions can we discern? And how do
               we expect the collation software to deal with them? Designing and developing a
               collation tool that understands in-text variation in a way similar to how scholarly
               editors understand it requires us to formalize our understanding of in-text
               variation. We argue that in-text variation can best be modelled as nonlinear text,
               and that a collation tool needs to treat in-text variation differently from the way
               linear text is treated. This will produce a more refined collation output that
               corresponds with a human interpretation of the textual variance.</p>
            <p>For the purposes of this article, we limit the in-text variation to authorial
               revisions, not (yet) including revisions by multiple textual agents. We will
               introduce HyperCollate, an automatic collation tool developed to take in-text
               revisions into account when calculating the best match between two textual versions.
               As a test-corpus we took small examples from a modern manuscript of Samuel Beckett
               which features numerous deletions and additions, made at various stages in the
               writing process.<note> The examples selected for this article are small for
                  illustrative purposes, but HyperCollate is developed to deal with larger texts.
               </note> Evidently, the feature of in-text variation is not unique to modern
               manuscripts: medieval and older manuscripts often contain indistinguishable layers of
               in-text revisions as well. When in-text revisions are all made with the same writing
               tool, they cannot be easily divided into separate revision campaigns. The challenges
               of automatically collating such multi-layered texts are, then, twofold: first, to
               adequately process a textual witness that contains one or more revisions, and second,
               to return a collation output that corresponds with what a scholarly editor would
               intuitively produce. </p>
            <p>Section 2 provides a theoretical background for the concepts and practices under
               discussion: versions, witnesses, in-text revision, and (non)linear text. We then
               briefly discuss the existing approaches to collating texts with in-text variation.
               Section 3 presents the collation tool HyperCollate. We describe its underlying data
               model – a hypergraph for textual variation – and how this data model differs from XML
               tree structures and regular variant graphs. A hypergraph for textual variation offers
               more flexibility in storing and processing information that is relevant to the study
               of textual variance. Subsequently, we single out two instances of in-text variation
               that occur frequently in manuscript texts – single deletions or additions and
               substitutions – and we describe for each type of variation what we, as human
               scholars, expect of the collation output (sections 3.2). How do we want the collation
               tool to handle immediate revisions in a textual version? What do we expect to see in
               the output? The answer to such questions, i.e., our expectations, inform the rules
               for the collation program. HyperCollate’s performance with each type of variation is
               discussed in section 3.3. The discussion and evaluation (section 3.4) includes the
               question of visualization, as existing visualizations could turn out to be inadequate
               in displaying the additional information in an insightful way. The fourth and final
               section of the article discusses a number of areas in need of further research.</p>
            <p>As the development and use of collation tools requires us to clearly articulate what
               we understand by textual variation and what we expect from the collation, automated
               collation tools can provide us with a heightened awareness of, and confront us with
               our assumptions about, the notion of “text”. For instance, when we integrate a
               collation tool into the workflow of a scholarly editor, the seemingly straightforward
               steps of “transcription ⇒ collation ⇒ visualization” imply decision-making at several
               stages and substages (e.g., about tagging, tokenization, normalization, a definition
               of a match). The decisions made at one stage influence the outcome of a subsequent
               stage. Once we recognize and understand this heuristic process, we are prompted to
               rethink our theories of text (cf. Ciula and Eide 2014, 36) and how these correspond
               to the workings of a text analysis tool. </p>
            <p>By demonstrating, first, how we made our human definition of in-text variation
               computer-understandable and, subsequently, how this definition influences the
               operations as well as the results of a collation tool, we hope to provide our readers
               with a deeper understanding of the process of modeling textual variation. We intend
               to show how the development of a collation program has both a philological and a
               computational perspective. Accordingly, our study reflects a fruitful collaboration
               between textual scholars and software architects: their respective knowledge is
               essential in order to successfully store, process, and analyse text. It thus proves a
               worthy partnership for manuscript research and modelling textual variance.</p>
         </div>
         <div>
            <head>2. Theoretical and Methodological Background</head>
            <p>In what follows we give an overview of the discussion around textual versions and
               witnesses (section 2.1), of the challenges of transcribing and modeling in-text
               variation (section 2.2 and 2.3), and of the current approaches to collating texts
               with internal revisions (section 2.4). </p>
            <div>
               <head>2.1. Text, Work, Versions, Witnesses, and In-text Revision</head>
               <p>A few working definitions of the terms “document,” “version”, “witness”, “work”,
                  and “text” are in order. Following Peter Shillingsburg, we define a document as
                  the “physical vessel” that carries information (Shillingsburg 1996, 174). A
                  version has “no substantial existence” as Shillingsburg puts it (44). As a
                  theoretical construct, it implies that there are at least two textual
                  representations of the work. A witness is a “written document that witnesses a
                  text’s genesis” according to Almuth Grésillon (1994, 246).<note> “Témoin: document
                     écrit qui témoigne de la genèse du texte” (Grésillon 1994, 246). In medieval
                     studies, the term “witness” is usually reserved for copies that are not an
                     autograph (Plachta 1997, 139) and serve as a witness to an archetype (Kline
                     1998, 274). See the Lexicon of Scholarly Editing, <ref
                        target="https://lexiconse.uantwerpen.be/lexicon/witness.html"
                        >https://lexiconse.uantwerpen.be/lexicon/witness.html</ref> (last accessed
                     October 22, 2021).</note> A witness is therefore a physical object. Whereas the
                  term “document” considers the object in and of itself, the term “witness”
                  considers it in relation to a work. Different documents that relate to the same
                  work are witnesses of it. According to Siegfried Scheibe, “Textual versions are
                  achieved or unachieved elaborations of the text that diverge from one another.
                  They are related through textual identity and distinct through variation.”
                  (Scheibe 1995, 207). In principle, this implies that a single revision suffices to
                  speak of two versions, or as Hans Zeller noted: “In the most extreme case a
                  version is constituted by a single variant. A holograph with one alteration which
                  does not simply correct an error thus represents two versions of the text” (Zeller
                  1975, 236). The notion of the “work” is used in the sense of the “experience
                  implied by the authoritative versions of literary writing” (Shillingsburg 1996,
                  176), a non-material concept that “serves as a minimal denominator to identify its
                  remaining physical manifestations” (Bordalejo 2013, 71). In the context of this
                  article, the term “text” will be employed to indicate not so much “the text of the
                  work,” but “the text of the document,” that is, the sequence of marks present in
                  one particular document (67). </p>
               <p>In textual scholarship, the notion of “version”, “textual version” or <hi
                     rend="italic">Textfassung</hi> usually implies the entirety of a work, as in
                  Peter Shillingsburg’s definition: “A version is one specific form of the work –
                  the one the author intended at some particular moment in time” (Shillingsburg
                  1996, 44). The problem, however, is that this “moment in time” is hard to define.
                  If the work is a long novel, it takes a while for an author to revise the entire
                  manuscript or to proofread the page proofs. The revision may consist of more than
                  one phase, or more than one revision campaign (<hi rend="italic">campagne de
                     révision</hi>). There may be only two versions of the opening chapter, but a
                  dozen versions of the closing chapter. Moreover, the unit of revision may vary
                  considerably. Some writers’ preferred writing unit is a chapter, others tend to
                  work and think in terms of paragraphs.</p>
               <p>This reality makes it difficult to establish a general rule on which we can base
                  the collation algorithm. For the purposes of this article, we work with the
                  sentence as a relatively small unit of revision. Our examples are based on the
                  manuscripts of Samuel Beckett and the transcriptions in the Beckett Digital
                  Manuscript Project (BDMP).<note> See <ref target="https://www.beckettarchive.org/"
                        >https://www.beckettarchive.org/</ref>. (last accessed October 22,
                     2021)</note> These documents constitute what is usually referred to as “modern”
                  manuscripts, to distinguish these autographs from ancient and medieval
                  manuscripts, many of which were produced by scribes. Indeed the majority of
                  medieval manuscripts are copies and not autographs, but that does not mean that
                  all medieval manuscripts are copies. Medieval autographs do exist, and it is
                  perfectly possible to apply automatic collation to them. Instead of using the term
                  “modern manuscripts” we will therefore speak of “manuscripts with revisions”, or
                  even more generally of “texts with revisions”. “In-text” implies that we focus on
                  textual variation within one version of a text.</p>
            </div>
            <div>
               <head>2.2. Transcribing Linearity and Nonlinearity</head>
               <p>As mentioned in the introduction, studying manuscripts with revisions is
                  intrinsically linked to the act of linearizing text. Even when we read a text, we
                  mentally arrange the characters in a linear order; vertically or horizontally,
                  from left to right or vice versa, depending on the language. This perhaps
                  subconscious act of linearization is more striking when we make a transcription of
                  a complex text with revisions. Since the goal of a transcription is, in the first
                  place, to render a text more readable, linearizing the text on the document is
                  desirable – but not without cost. Texts with revisions contain traces of a writing
                  process over time; so when words and characters are placed in a linear order, the
                  manuscript page loses that diachronic aspect. The desire to preserve the nonlinear
                  nature of the text coupled with the need to make it readable (and processable)
                  confronts textual scholars with a dilemma. Accordingly, linearization has been the
                  topic of long debates in genetic criticism and textual scholarship (Grésillon
                  1994; Lebrave 1992; Van Hulle 1999, 2004; Ferrer 2014). The “flattening” or
                  “de-manuscripting” of a text is generally accepted as a necessary evil, although
                  it is lamented that the most typical feature of a written draft – its nonlinearity
                  – is reduced to a straightforward sequence of text. </p>
               <p>In print, nonlinear text can be indicated with certain diacritical marks or forms
                  of layout; in digital transcriptions the revisions can be captured with markup
                  elements and visualized with HTML and/or CSS.<note> We recognize that a TEI-XML
                     transcription is not synonymous with an embedded markup file; there exist
                     non-TEI and standoff approaches to transcribing manuscripts with revisions as
                     well. Still, TEI-XML files with embedded markup are considered to be the <hi
                        rend="italic">de facto</hi> standard for text encoding (Andrews, 2013;
                     Pierazzo, 2015, 130), so in this contribution we focus on this kind of digital
                     text transcriptions. </note> The TEI Guidelines suggest two ways of expressing
                  an instance of nonlinear text: substitutions can be recorded (1) by means of a
                  &lt;subst&gt; element grouping one or more &lt;del&gt; and &lt;add&gt;
                     elements,<note> TEI Guidelines chapter 11.3.1.5. "Substitutions". See <ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU</ref>.
                     (last accessed October 22, 2021)</note> or (2) by means of an &lt;app&gt;
                  element containing two or more &lt;rdg&gt; elements.<note> TEI Guidelines chapter
                     12. “Critical Apparatus”. See <ref
                        target="https://tei-c.org/release/doc/tei-p5-doc/en/html/TC.html"
                        >https://tei-c.org/release/doc/tei-p5-doc/en/html/TC.html</ref> (last
                     accessed October 22, 2021)</note>
               </p>
               <p>In both cases, a human encoder will think of these TEI elements as indicating the
                  momentary suspension of the linear sequence of text characters. The text stream
                  runs from left to right, diverges at the points where variation occurs (indicated
                  with an open tag &lt;subst&gt; or &lt;app&gt;) and converges when the variation
                  ends (indicated with a closing tag &lt;/subst&gt; or &lt;/app&gt;). We can say
                  that there are multiple coexisting, simultaneous paths through the text. The start
                  of each path is marked with a &lt;del&gt;, an &lt;add&gt;, or a &lt;rdg&gt;
                  element; the end of each path with the corresponding &lt;/del&gt;, &lt;/add&gt;,
                  or &lt;/rdg&gt;. By “coexisting” we mean that the textual content of the
                  &lt;del&gt;, &lt;add&gt;, or &lt;rdg&gt; is in the same location in the sentence.
                  This corresponds with the TEI Guidelines’ remark that “Since the purpose of this
                  [the &lt;subst&gt;] element is solely to group its child elements together, the
                  order in which they are presented is not significant.”<note> TEI Guidelines
                     chapter 11.3.1.5, "Substitutions". See <ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHSU</ref>.
                     (last accessed October 22, 2021)</note>
               </p>
               <p>As described in section 2.4, a current approach to the automated collation of
                  in-text revisions is to flatten the TEI-XML transcription to a stream of plain
                  text characters, thereby ignoring the TEI-XML markup elements that indicate
                  nonlinear text. In order to fully understand the challenges that arise when we <hi
                     rend="italic">do</hi> wish to take a text’s nonlinear features into account, we
                  first need to take a closer look at the way in-text revisions can be modelled in
                  TEI-XML. </p>
            </div>
            <div>
               <head>2.3. Modeling Nonlinearity</head>
               <p>A TEI-XML transcription of a straightforward text consists typically of “fully
                  ordered” data. For textual scholars, the value and meaning of this data are
                  primarily in the textual content, not in the TEI-XML elements. As a consequence,
                  the order of the TEI-XML elements is meaningful. In the TEI-XML expert below,
                  changing the order of the two &lt;s&gt; elements with their textual content below
                  would alter the meaning of the text: </p>
               <p>&lt;p&gt;</p>
               <p>&lt;s&gt;The sun shone, having no alternative, on the nothing new.&lt;/s&gt;</p>
               <p>&lt;s&gt;Murphy sat out of it, as though he were free, in a mew in West
                  Brompton.&lt;/s&gt;</p>
               <p>&lt;/p&gt;</p>
               <p>We have argued in the previous section that the textual data of a TEI-XML
                  transcription of a manuscript with in-text revisions can be understood as an
                  ordered stream of text characters, which splits into two or more paths when
                  textual variation occurs. Or, put metaphorically by Michael Sperberg-McQueen, this
                  type of text forms “curves that intersect, run together for a while, and then
                  split apart again, like the channels in a river delta” (Sperberg-McQueen 1989). By
                  way of illustration, let’s take the following TEI-XML example:</p>
               <p>&lt;p&gt;</p>
               <p>&lt;s&gt;The </p>
               <p>&lt;subst&gt;</p>
               <p>&lt;del&gt;quick&lt;/del&gt;</p>
               <p>&lt;add&gt;brown&lt;/add&gt;</p>
               <p>&lt;/subst&gt; fox.</p>
               <p>&lt;/s&gt;</p>
               <p>&lt;/p&gt;</p>
               <p>The stream of textual data starts by being fully ordered with “The”. At the point
                  in the text where variation occurs (marked with &lt;subst&gt;), the stream splits
                  into two paths that run parallel to one another. The textual data <hi
                     rend="italic">within</hi> the two &lt;del&gt; and &lt;add&gt; paths is again
                  fully ordered as each path contains a linear stream of text characters. From a
                  purely informational perspective, the deleted word “quick” is on the same level in
                  the XML tree as the added word “brown”: they are both the textual content of the
                  child elements of the &lt;subst&gt; element and they occur in the same place in
                  the text. In other words, their position vis-à-vis their parent element is the
                  same. At the end of the variation (marked with &lt;/subst&gt;) the two paths
                  converge again into one stream.</p>
               <p>The order in which TEI-XML elements are placed also carries philological or
                  semantic value. It is generally acknowledged that markup represents valuable
                  editorial knowledge and that the tags reflect an interpretation of the
                  inscriptions on the source document. For example, “the quick brown fox” can be
                  encoded in TEI-XML as </p>
               <p>&lt;s&gt;the
                  &lt;subst&gt;&lt;del&gt;quick&lt;/del&gt;&lt;add&gt;brown&lt;/add&gt;&lt;/subst&gt;
                  fox&lt;/s&gt; </p>
               <p>But, if the encoder does not interpret the deletion and the addition as part of
                  one and the same revision, the intervention can be encoded as </p>
               <p>&lt;s&gt;the &lt;del&gt;quick&lt;/del&gt;&lt;add&gt;brown&lt;/add&gt;
                  fox&lt;/s&gt;. </p>
               <p>In the first case, the elements &lt;del&gt; and &lt;add&gt; are in the same
                  hierarchical location in the XML tree (again, both are children of the
                  &lt;subst&gt; element).<note> If the encoder wishes to indicate the order in which
                     they think the intervention took place, the TEI Guidelines suggest to use the
                     @seq attribute. See TEI Guidelines, chapter 11.3.1.4. “Additions and Deletions”
                        (<ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHAD"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#PHAD</ref>).
                     (last accessed October 22, 2021)</note> In the second case, the &lt;del&gt;
                  element precedes the &lt;add&gt; element, which denotes a certain order: first the
                  word “quick” was deleted, then the word “brown” was added. In order for a
                  collation tool to produce an output that corresponds with this interpretation of
                  in-text revision, it should both recognize the start of parallel paths marked with
                  &lt;subst&gt; or &lt;app&gt;/&lt;rdg&gt;, and take into account the chronological
                  order implied by the order of the &lt;del&gt; and &lt;add&gt; tags without a
                  &lt;subst&gt; or &lt;app&gt; parent.</p>
            </div>
            <div>
               <head>2.4. Current Approaches to Collating In-text Revisions</head>
               <p>This section presents a concise discussion of the existing approaches to collating
                  in-text revisions. As we concentrate on the methods of automated collation, we
                  leave aside the manual collation method of TEI Parallel Segmentation and
                     others.<note> TEI Guidelines, chapter 12.2.3. “The Parallel Segmentation
                     Method”. See <ref
                        target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/TC.html#TCAPPS"
                        >https://www.tei-c.org/release/doc/tei-p5-doc/en/html/TC.html#TCAPPS</ref>.
                     (last accessed October 22, 2021)</note> As mentioned above, current automated
                  collation tools are generally text-centered and do not handle TEI-XML well: they
                  ignore all tags and attributes, or collate the elements as plain text. The
                  nonlinear aspect of texts with revisions as described above, is ignored. We can
                  distinguish roughly two different approaches to the automatic comparison of XML
                  files: (1) passing along information marked as relevant to the study of in-text
                  variation (with CollateX, collation software; see 2.4.1), and (2) creating plain
                  text files for each level of in-text variation (for instance with MVD, a storage
                  format for text; see 2.4.2). As far as we know, both approaches are implemented by
                  at least one edition project.</p>
               <p>2.4.1. Passing Along Relevant Markup Elements</p>
               <p>The JSON input format for CollateX allows for extra properties to be added to
                  words. A number of projects make use of the JSON input format to “pass along”
                  additional information about relevant markup elements through the collation
                  pipeline. In a pre-processing step, the text is tokenized and transformed into
                  JSON word tokens. Editors make a selection of elements that they wish to attach to
                  the JSON token as a <hi rend="italic">t</hi> property (“t” for token). The
                  collation is executed on the value of the token’s <hi rend="italic">n</hi>
                  property (“n” for normalized), but the <hi rend="italic">t</hi> property with the
                  tag(s) is included in the JSON alignment table output and can be processed in the
                  table’s visualization. This approach is used, among others, by the Beckett Digital
                  Manuscript Project; the online critical edition of the Primary Chronicles, or <hi
                     rend="italic">Povest’ vremennyx let</hi>, created by David J. Birnbaum; and the
                  work on the <hi rend="italic">Declamations</hi> of Calpurnius Flaccus done by
                  Elisa Nury (Birnbaum 2015; Nury 2018, chapter 7.1). The advantages of this
                  approach are, first, that a witness with in-text variation can be collated as one
                  text and, secondly, that the method approximates the goal of having nonlinear
                  revisions marked as such in both in- and output. The main disadvantage is that the
                  collation algorithm still treats the input witness as linear text: the witnesses
                  are collated as such and any information about revision campaigns is ignored. </p>
               <p>2.4.2. Creating Separate Plain Text Files For Each Level of Variation</p>
               <p>Another approach is to transcribe a manuscript with in-text revisions as two or
                  more separate plain text versions and then collate these temporary versions
                  against each other. The advantage of this method is that it succeeds in aligning
                  the two parts of a substitution vertically instead of horizontally (which the
                  previous approach is forced to do), but the drawback is that the deletions and
                  additions are spread over two or more (sub)versions. </p>
               <p>The approach is presented by Desmond Schmidt’s Multi-Version Document system, as
                  integrated into Ecdosis, “A CMS for scholarly editors”.<note>
                     <ref target="http://charles-harpur.org/About/Technical%20design/Ecdosis%20CMS/"
                        >http://charles-harpur.org/About/Technical%20design/Ecdosis%20CMS/</ref>.
                     (last accessed October 22, 2021)</note> In a 2019 article, Schmidt describes in
                  detail how this layered approach also allows for the inclusion of in-text
                  variation (2019, §60). At the transcription phase, a manuscript text is divided
                  into “levels” by the scholarly editor. All changes to the “baseline text” of a
                  document (level 1) are grouped as being on level 2. Subsequent changes to level 2
                  are grouped as level 3. For each of these levels a separate text is created, a
                  “layer”: “We do not claim that a layer is a text the author ever completed; it is
                  not a <hi rend="italic">version</hi> as such," explains Schmidt, "It is simply a
                  compact way to capture local changes.”<note> Desmond Schmidt in the “Technical
                     Design”-section of the online Charles Harpur Critical Archive. See: <ref
                        target="https://charles-harpur.org/About/Technical%20design/Versions%20and%20layers/"
                        >https://charles-harpur.org/About/Technical%20design/Versions%20and%20layers/</ref>.
                     (last accessed October 22, 2021)</note> Via the editor view in the CMS each of
                  these artificial layers is fed into Ecdosis as plain text, with a few additional
                  features encoded in stand-off markup. The Ecdosis approach is implemented in the
                  Charles Harpur Critical Archive. For example, the text of Harpur’s poem “To the
                  Comet” is divided into three layers. The document identifier
                  “english/harpur/poems/h595f/layer-2” points to the second layer of the poem’s
                  text. Layer 2 is followed by “h595f/layer-final”, in which corrections on the
                  third level are carried out on the text of layer 2.<note> See <ref
                        target="https://charles-harpur.org/View/Singleview/?docid=english/harpur/poems/h595&amp;version1=/h595f/layer-final"
                        >https://charles-harpur.org/View/Singleview/?docid=english/harpur/poems/h595&amp;version1=/h595f/layer-final</ref>
                     for an overview of all versions of the text of <hi rend="italic">The
                     Comet</hi>. (last accessed October 22, 2021)</note> The scholarly editors of
                  the Charles Harpur Critical Archive see no issue in this “mechanical” grouping of
                  in-text variation: </p>
               <p>Assignment to levels is mechanical and describes a purely local succession of
                  changes, which can almost always be determined. Authors leave many clues as to the
                  succession of variants: position (above the line, then below, in the margin, on
                  another page), the carrying over of changed text between levels, sense and
                  crossing-out. Where the local temporal succession can’t be established this is
                  usually because the corrections themselves can’t be read (ibid). </p>
               <p>The versions and layers in plain text are merged into one Multi-Version Document.
                  It stores the text shared by each version and layer only once. Note that the
                  comparison algorithm works at the character level, not at word level. In the table
                  visualization, therefore, words may be cut up (see figure 1).</p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 1: table visualization of the collation output of the
                     artificial layers of “the Comet” by Charles Harpur. Text characters added with
                     respect to the base layer (not shown in this figure) are in blue.</hi>
               </p>
               <p>2.4.3. Diff Algorithms to Compare XML Documents </p>
               <p>During the development of HyperCollate, we also studied the existing tools and
                  algorithms used for the comparison of XML documents. XML is a widely used standard
                  for (online) publishing and data-exchange, so there is a significant need for
                  comparing and versioning XML documents. There exists a wide variety of “diff”
                  algorithms or “deltas” to find the differences in XML documents, each with its own
                  strengths and focus (Peters 2005). Because most XML documents are data-centric and
                  contain record-based data, deltas typically consider XML documents as
                  hierarchically structured trees and compare them as such. Considering our type of
                  material – text-centric XML documents in which the left-to-right order of the
                  siblings is significant – we specifically focused on tools that can compare
                  ordered XML trees.</p>
               <p>We found a number of useful tools and algorithms, like the commercial tools
                  Microsoft’s XML Diff and Patch or the XML compare tool of DeltaXML, that can
                  compare both ordered and unordered XML trees.<note> Microsoft XML Diff 1.0 and XML
                     Patch 1.0 (see the documentation on <ref
                        target="https://documentation.help/Microsoft-XML-Diff/xmldiffpatch_namespace_intro_conc_0t0v.htm"
                        >https://documentation.help/Microsoft-XML-Diff/xmldiffpatch_namespace_intro_conc_0t0v.htm</ref>);
                     Delta XML Compare 11.0 (see the documentation on <ref
                        target="https://docs.deltaxml.com/xml-compare/latest/xml-compare-45122014.html"
                        >https://docs.deltaxml.com/xml-compare/latest/xml-compare-45122014.html</ref>).
                     (last accessed October 22, 2021)</note> Such tools can come in handy during the
                  making of a digital edition, for instance when scholarly editors wish to compare
                  and align the TEI-XML transcriptions of a text that were made by two different
                  scholars of the same project. Furthermore, there exist XML editors with a built-in
                  function to compare XML documents. Oxygen XML Editor, for example, allows its
                  users to adjust parameters for a better comparison between two XML documents,
                  e.g., to compare documents on the level of lines, words, or characters, or to
                  ignore attributes or namespaces.<note> Oxygen XML Editor 24.0 (see <ref
                        target="https://www.oxygenxml.com/">https://www.oxygenxml.com/</ref>). (last
                     accessed October 22, 2021)</note> There is, however, an important difference
                  between current XML comparison tools and algorithms, and how we designed
                  HyperCollate. Existing tools compare XML documents and focus on the parent nodes,
                  whereas HyperCollate <hi rend="italic">interprets</hi> XML documents in order to
                  better compare the versions of a text. It does not ignore the structure of the XML
                  tree, but – in line with the research objectives of scholarly editors – it focuses
                  on comparing text and is only concerned with the TEI-XML tags that determine the
                  flow of the text. Given this fundamental difference in premise, an extensive
                  analysis of the quality and use of diff algorithms and tools is beyond the scope
                  of this article.<note> We recommend the research by Gioele Barabucci on the topic
                     (see Barabucci et al. 2016; Barabucci 2018; 2020).</note>
               </p>
            </div>
         </div>
         <div>
            <head>3. Automated Collation of Nonlinear Text</head>
            <div>
               <head>3.1. Nonlinearity and Variant Graphs </head>
               <p>As the previous section showed, automated collation software usually does not take
                  in-text revisions into account. Yet we find that texts with revisions have a
                  complex richness that deserves to be treated with attention to detail, in
                  transcription as well as in collation, so as to produce a more accurate and
                  detailed record of the textual variance. The collation result of HyperCollate
                  needed to correspond with the scholarly editor’s interpretation of the in-text
                  variance, which meant that the tool should be able to recognize and respect the
                  nonlinear nature of the input text as it was expressed in TEI-XML markup.</p>
               <p>The first step we took in enabling a collation tool to recognize in-text variation
                  in a witness was establishing formal (i.e., exhaustive and unambiguous) rules for
                  the way in which the program needed to process it. We regard a deletion as a
                  temporary interruption in the linear text stream (see section 2.2), so we wanted
                  HyperCollate to be able to treat it as such. In order for this to work, the
                  collation tool would have to recognize and interpret the markup elements
                  indicating the start and end of nonlinearity in the TEI-XML input transcription:
                  &lt;app&gt; and &lt;subst&gt;. Secondly, we regard the elements &lt;del&gt;,
                  &lt;add&gt;, or &lt;rdg&gt; as indicators of the start of a separate path through
                  the text – one “branch” of the text stream – and we would want the collation
                  program to select the best match from these branches. </p>
               <p> A fitting model of nonlinear text is presented by the variant graph data
                  structure. The variant graph consists of a set of nodes that represent textual
                  objects, and edges that connect one node to another node in the graph. The graphs
                  are acyclic, which means that they are read from left to right without “looping”
                  back. As Tara Andrews and Caroline Macé write, a variant graph is an elegant way
                  to represent nonlinear text: “one may imagine a text running from beginning to end
                  with a number of points of divergence, where each witness takes a single path
                  through these divergences” (2013, 506). Variant graphs are relatively well-known
                  in the field of automated collation and occur both as internal data model
                  (NMerge/Compare, Schmidt and Colomb 2009; CollateX, Dekker and Middell 2011) and
                  for visualization purposes (e.g., the stemma graph or the variant graph, Andrews
                  and Macé 2013, 507, 510 - 511). As Elisa Nury writes, the first use of a variant
                  graph to express textual variation can be traced to E.C. Colwell and E.W. Tune in
                  1964, although it was with the 2009 article of Desmond Schmidt and Robert Colomb
                  that the variant graph gained a foothold in the field of textual scholarship
                  (Schmidt and Colomb 2009; see Nury 2016, 73-77). Their variant graph has the text
                  and sigla placed on the edges of the graph (figure 2). Common text is merged, and
                  variant text results in separate branches. </p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 2: representation of the variant graph data model of
                     Schmidt and Colomb (source: CollateX documentation, section “The Data Model:
                     Variant Graphs”, on https://collatex.net/doc/).</hi>
               </p>
               <p>CollateX adopted the variant graph, but modified it to place the text in the nodes
                  of the graph, and the sigla on the edges (see figure 3). This ensures not only a
                  better readability, but also improves processing as the edges have only one label
                  (one or more sigla). </p>
               <p> There is another, more subtle yet important distinction between the variant graph
                  as proposed by Schmidt and Colomb, and the variant graph as implemented by
                  CollateX. The data structure of the variant graph in figure 3 appears simpler than
                  it is. At first glance, the textual content of the first node (“The”) appears to
                  be shared by witness 1 (W1) and witness 2 (W2). In fact, each node in the CollateX
                  variant graph represents <hi rend="italic">a set of text tokens</hi> that
                  originate from one or more versions; the tokens in a set are considered equal by
                  the CollateX collation algorithm. The main point being that the tokens are not
                  modeled on textual content, as is the case with the variant graph of Schmidt and
                  Colomb. In CollateX’s variant graph model, arbitrary tokens can be compared and
                  their correspondences, differences, and order can be represented in a variant
                  graph structure (CollateX documentation). This seemingly small feature paves the
                  way for HyperCollate’s approach to collation.</p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 3: variant graph of CollateX: witness sigils on the edges
                     and the text in the nodes. Text that is considered as a match shares a
                     node.</hi>
               </p>
               <p>HyperCollate uses a <hi rend="italic">hypergraph for textual variation</hi>. This
                  data structure is more flexible than trees, and it differs from regular variant
                  graphs in that it has <hi rend="italic">hyperedges</hi> which can connect multiple
                  nodes to one another. As a result, the nodes of a hypergraph can be traversed in
                  more than one order. Finally, the hypergraph data model of HyperCollate contains
                  text nodes as well as markup nodes. This means that the markup node of, say, a
                  &lt;del&gt; element can be connected to multiple text nodes which do not
                  immediately have to follow one another. As a result, it is possible to express
                  multiple, overlapping or nonlinear dimensions of a text in markup.<note> For a
                     more exhaustive discussion of the hypergraph model for textual variation, see
                     Bleeker et al. 2018 and Bleeker et al. 2020; for a discussion of the hypergraph
                     for text see Haentjens Dekker and Birnbaum 2017 and Haentjens Dekker et al.
                     2018.</note>Moreover, the hypergraph also enables the representation of
                  individual witnesses with in-text variance as a hypergraph (see figure 4). </p>
               <p>HyperCollate is trained on the two ways of encoding in-text revisions as proposed
                  by the TEI and discussed in section 2.2: it acts whenever it encounters either a
                  &lt;subst&gt;, an &lt;app&gt;, or their children &lt;del&gt;, &lt;add&gt;, or
                  &lt;rdg&gt;. These TEI-XML elements are interpreted as instances of nonlinear
                  text, with the opening tags marking a break in the linear sequence of the text
                  characters, and the closing tags identifying the return to linearity. Let's take
                  for Witness 1 the same example of a simple TEI-XML transcription we used
                  above:</p>
               <p>&lt;s&gt;The </p>
               <p>&lt;subst&gt;</p>
               <p>&lt;del&gt;quick&lt;/del&gt;</p>
               <p>&lt;add&gt;brown&lt;/add&gt;</p>
               <p>&lt;/subst&gt; fox.</p>
               <p>&lt;/s&gt; </p>
               <p>Figure 4 shows the witness hypergraph of this example. Note that the hypergraph
                  contains not only information about the text of the witness, but also its markup.
                  In this visualization, the markup information is shown as an XPath. We see, for
                  instance, that the XPath of the text token “quick” is /s/subst/del. </p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 4: visualization of the hypergraph of Witness 1 (W1) as
                     stored in HyperCollate.</hi>
               </p>
               <p>Another way to visualize the hypergraph of Witness 1 is shown in figure 5, below.
                  Here, the tree of markup nodes is projected onto the variant graph of the text.
                  The text still reads from left to right, with the stream of text temporarily
                  separating into two concurrent branches. The markup nodes that are associated with
                  each text node in the XML tree are visualized as colored nodes.</p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 5: different visualization of the hypergraphs of Witness
                     1 as stored by HyperCollate, with the markup information visualized in
                     colors.</hi>
               </p>
            </div>
            <div>
               <head>3.2. HyperCollate</head>
               <p>Having illustrated how HyperCollate stores the information in a TEI-XML
                  transcription, we can now move on to demonstrate how this information is processed
                  and collated. </p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 6: schematic workflow of HyperCollate</hi>
               </p>
               <p>Figure 6 represents the pipeline of HyperCollate. First, the TEI-XML transcribed
                  texts (here “XML witness 1” and “XML witness 2”) are transformed into individual
                  variant hypergraphs. These variant hypergraphs are subsequently segmented and the
                  resulting tokens are aligned. The alignment is carried out on the level of the
                  text; the markup elements &lt;app&gt; and &lt;subst&gt; are recognized as
                  occurrences of nonlinearity. Subsequently, the resulting set of matches are merged
                  with the two individual hypergraph witnesses. The result of the collation is a
                  collation hypergraph in which all text nodes that are not aligned are unique to
                  one of the two hypergraph witnesses, and all the text nodes that are aligned are
                  reduced to one node. There are labels on the edges indicating which node is part
                  of which hypergraph. For every witness, then, there is always a fully connected
                  path through the hypergraph from the start text node to the end text node,
                  following the sigils on the edges. The collation hypergraph can be visualized or
                  exported in alignment table format, SVG, PNG, or dot format. If there are more
                  than two witnesses, the result of that first collation can be used as the basis of
                  a new collation, following the method of progressive alignment.<note> In short,
                     the progressive alignment method of collation means that two versions are
                     compared, the result of which is stored in a graph, against which a third
                     version is collated. The result of that comparison is merged into the graph,
                     against which a fourth version is collated, etc.</note>
               </p>
               <p>HyperCollate does not regard the input TEI-XML files as plain text files (which
                  would result in the aforementioned “flattening” of the input text): instead, each
                  input witness is transformed into a hypergraph and these individual witness
                  hypergraphs are subsequently collated against each other. In short, HyperCollate
                  can compare TEI-XML files without having to convert them to a plain text character
                  string. This means that TEI-XML transcriptions of texts with in-text revisions can
                  be collated without flattening them. During the alignment, HyperCollate looks at
                  all branches within each witness hypergraph. If the textual content of one branch
                  (the start of which is indicated by a &lt;del&gt;, &lt;add&gt;, or an &lt;rdg&gt;
                  open tag) has a match in the other witness, the text is aligned; if not, the text
                  remains in a separate branch in the hypergraph. </p>
               <p>Furthermore, the tag names (&lt;del&gt;, &lt;add&gt;, &lt;rdg&gt;, &lt;subst&gt;,
                  and &lt;app&gt;) are not only interpreted but preserved as well, in order to
                  enable further querying, transformation or visualization of the collation result.
                  The visualization of the information-rich collation hypergraph opens up new
                  possibilities and new questions. For example, if we visualize the collation output
                  as a variant graph, should we distinguish the paths that represent variation
                  within one witness from the paths constituted by variation between different
                  witnesses, and if so: how? As shown in section 3.3.3, figure 20, the variant graph
                  visualization of HyperCollate currently places extra marks on the edges, right
                  after the witness sigil: a minus [-] for an in-text deletion and a plus [+] for an
                  in-text addition. In case of an in-text substitution within a substitution, this
                  will lead to a sequence of multiple [+][-] which may not lead to a clear
                  visualization. Of course, we can say that at this point the source manuscript text
                  also presents a complex case of revision and this complexity is merely reflected
                  in the collation output. Nevertheless, visualizing the collation produced by
                  HyperCollate remains an interesting challenge (see also Bleeker et al., 2019).</p>
               <div>
                  <head>3.2.1 Deletions and Additions</head>
                  <p>Consider the example in figure 7, transcribed first with the TEI
                     &lt;del&gt;/&lt;add&gt; method, and then with the TEI &lt;app&gt;/&lt;rdg&gt;
                     method.</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 7: reconstruction of a fragment from Samuel Beckett:
                        Murphy, Draft notebook, University of Reading, Cat. Nr. 5517/3, page
                        20r</hi>
                  </p>
                  <div>
                     <head>Transcription using the TEI del/add method:</head>
                     <p>&lt;xml&gt;</p>
                     <p>&lt;s&gt;&amp;amp; &lt;add&gt;finally&lt;/add&gt; in what order he would eat
                        the biscuits&lt;del&gt;, in the cockpit&lt;/del&gt; when the time came.</p>
                     <p>&lt;/s&gt;</p>
                     <p>&lt;/xml&gt;</p>
                  </div>
                  <div>
                     <head>Transcription using the TEI app/rdg method:</head>
                     <p>&lt;s&gt;&amp;amp; </p>
                     <p>&lt;app&gt;</p>
                     <p>&lt;rdg varSeq="1"/&gt;</p>
                     <p>&lt;rdg varSeq="2"&gt;finally&lt;/rdg&gt;</p>
                     <p>&lt;/app&gt; in what order he would eat the biscuits</p>
                     <p>&lt;app&gt;</p>
                     <p>&lt;rdg varSeq="1"&gt;, in the cockpit&lt;/rdg&gt;</p>
                     <p>&lt;rdg varSeq="2"/&gt;</p>
                     <p>&lt;/app&gt; when the time came.</p>
                     <p>&lt;/s&gt;</p>
                  </div>
                  <div>
                     <head>Human expectations and algorithmic rules</head>
                     <p>With this TEI-XML transcription as one of the witnesses in the input for
                        HyperCollate, we expect that the collation output retains the information
                        about which words in a witness were in-text additions or deletions.
                        Additions or deletions demarcate the beginning of a split in HyperCollate’s
                        token stream. From that point on there are two substreams: one with the
                        &lt;del&gt; or &lt;add&gt; and their textual content, and one without. </p>
                  </div>
                  <div>
                     <head>Individual witness hypergraphs containing single addition(s) and
                        deletion(s)</head>
                     <p>How HyperCollate internally handles the in-text variation in this version of
                        the sentence can be visualized in a hypergraph. Figure 8 shows the graph of
                        the witness with the &lt;del&gt;/&lt;add&gt; tagging, and figure 9 using the
                        app/rdg method of transcribing.</p>
                     <figure/>
                     <p>
                        <hi rend="italic">Figure 8: internal graph model of the del/add tagging of
                           the example.</hi>
                     </p>
                     <figure/>
                     <p>
                        <hi rend="italic">Figure 9: internal graph model of the app/rdg tagging of
                           the example.</hi>
                     </p>
                  </div>
               </div>
               <div>
                  <head>3.2.2 Instant Revisions</head>
                  <p>“Instant revisions” or<hi rend="italic"> currente calamo</hi> changes, i.e.
                     revisions made within the initial writing of a sentence, with the change
                     occurring on the same line, pose a particular challenge for transcription. They
                     cannot be encoded as a substitution because the demarcation of the added text
                     is problematic. Would all of the text following an instant deletion be an
                     addition? The TEI Guidelines propose to add the attribute @instant with the
                     value "true"’ to the &lt;del&gt; element, to distinguish between a regular
                     correction.</p>
                  <p>In the following example, Beckett wrote “threw up his” and then crossed the
                     three words out to continue the sentence with “gave such a jerk at Russell's
                     arm that that poor little man was nearly pulled off his feet.”</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 10: reconstruction of a fragment from Samuel Beckett:
                        Murphy, Draft notebook, University of Reading, Cat. Nr. 5517/2, page
                        16r</hi>
                  </p>
                  <p>In the example above (see figure 10), it would be incorrect to tag “gave such a
                     jerk” as an addition, and equally incorrect to tag the rest of the sentence as
                     such. </p>
                  <p> We argue that, in fact, an instant revision does <hi rend="italic">not</hi>
                     constitute a case of nonlinear text. In contrast to regular in-text corrections
                     and substitutions, there is no other way of reading the text: the instant
                     revision is part of the same writing campaign as the text surrounding it. </p>
                  <div>
                     <head>Transcription using the TEI del/add method:</head>
                     <p>&lt;s&gt;&amp;amp; now &lt;del instant="true"&gt;threw up his&lt;/del&gt;
                        gave such a jerk&lt;/s&gt;</p>
                  </div>
                  <div>
                     <head>Human expectations and algorithmic rules</head>
                     <p>Following our interpretation of an instant revision, we would <hi
                           rend="italic">not</hi> want HyperCollate to treat it as an instance of
                        nonlinear text. A deletion with the @instant="true" should be considered to
                        be part of the same path as the text surrounding it. We do want the
                        information about the instant revision to be present in the output, so that
                        we can visualize the deletion appropriately. </p>
                  </div>
                  <div>
                     <head>Individual witness hypergraphs containing an instant revision</head>
                     <p>As the instant revision, encoded with &lt;del instant="true"&gt;, does not
                        trigger HyperCollate in the same way a regular &lt;del&gt; does, the
                        individual witness hypergraph has only one path through the text. The
                        information about the deletion is retained (see figure 11).</p>
                     <figure/>
                     <p>
                        <hi rend="italic">Figure 11: internal graph model of an instant
                           revision</hi>
                     </p>
                  </div>
               </div>
               <div>
                  <head>3.2.3 Substitutions</head>
                  <p>Deletions followed by additions that are (semantically) related can be grouped
                     by means of a &lt;subst&gt; (substitution) element, or as two readings in an
                     &lt;app&gt; element. This can be illustrated with a simple example from Beckett
                     (see figure 12).</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 12: reconstruction of a fragment from Samuel Beckett:
                        Murphy, Draft notebook, University of Reading, Cat. Nr. 5517/2, page
                        20r</hi>
                  </p>
                  <div>
                     <head>Transcription using the TEI del/add method:</head>
                     <p>&lt;xml&gt;</p>
                     <p>&lt;subst&gt;</p>
                     <p>&lt;del&gt;Alice&lt;/del&gt;</p>
                     <p>&lt;add&gt;Cathleen&lt;/add&gt;</p>
                     <p>&lt;/subst&gt; came.</p>
                     <p>&lt;/xml&gt;</p>
                  </div>
                  <div>
                     <head>Transcription using the TEI app/rdg method:</head>
                     <p>&lt;xml&gt;</p>
                     <p>&lt;app&gt;</p>
                     <p>&lt;rdg varSeq="1"&gt;Alice&lt;/rdg&gt;</p>
                     <p>&lt;rdg varSeq="2"&gt;Cathleen&lt;/rdg&gt;</p>
                     <p>&lt;/app&gt; came.</p>
                     <p>&lt;/xml&gt;</p>
                  </div>
                  <div>
                     <head>Human expectations and algorithmic rules</head>
                     <p>With this TEI encoded input, we expect HyperCollate to recognize the
                        substitution as a break in the linearity of the text and to treat the two
                        parts in a nonlinear way. Moreover, since not all text encoders gather
                        &lt;del&gt; and &lt;add&gt; elements within a &lt;subst&gt; tag,
                        HyperCollate should differentiate between a substitution and an unconnected
                        deletion and addition by providing clear rules on how to trigger its special
                        treatment of substitutions for transcriptions that don’t include
                        &lt;subst&gt; elements. For now, HyperCollate implements a heuristic: if a
                        &lt;del&gt; element is directly followed by an &lt;add&gt; element,
                        unspaced, we take them as belonging together, so the heuristic places a
                        &lt;subst&gt; around the two. If the &lt;del&gt; and &lt;add&gt; elements
                        are separated by a white space, they are not grouped together, and treated
                        in a linear way. Of course, as with all heuristics, this is not an optimal
                        solution, as some scholarly editors do use a white space between a
                        &lt;del&gt; and an &lt;add&gt; element, even if they consider them to belong
                        to the same substitution.</p>
                     <p>The &lt;subst&gt; or &lt;app&gt; element demarcates the beginning of a split
                        in HyperCollate’s token stream. From that point on there are two substreams
                        of the stream: one substream with the &lt;del&gt; or first &lt;rdg&gt;
                        element and its textual content, and one substream with the &lt;add&gt; or
                        second &lt;rdg&gt; element and its textual content. The &lt;del&gt; and
                        &lt;add&gt; elements are unordered: they have the same ranking vis-à-vis the
                        root node.</p>
                     <p> A &lt;subst&gt; element can contain more than one &lt;del&gt; and more than
                        one &lt;add&gt; element. In principle each &lt;del&gt; and &lt;add&gt;
                        represents a new branch. A &lt;subst&gt; can occur within another
                        &lt;subst&gt;; the result is simply that the stream of text within that
                        branch splits up again. </p>
                  </div>
                  <div>
                     <head>Hypergraph of a substitution</head>
                     <p>Figure 13 shows the internal graph model for the substitution in the example
                        encoded with the &lt;del&gt;/&lt;add&gt; method.</p>
                     <figure/>
                     <p>
                        <hi rend="italic">Figure 13: internal hypergraph model of the </hi>
                        <hi rend="italic">&lt;add&gt;</hi>
                        <hi rend="italic">/</hi>
                        <hi rend="italic">&lt;del&gt;</hi>
                        <hi rend="italic"> tagging of the example.</hi>
                     </p>
                     <p>The &lt;app&gt;/&lt;rdg&gt; method equally divides the token stream up into
                        two paths (see figure 14).</p>
                     <figure/>
                     <p>
                        <hi rend="italic">Figure 14 internal hypergraph model of the app/rdg tagging
                           of the example.</hi>
                     </p>
                  </div>
               </div>
               <div>
                  <head>3.2.4 Multiple Alignment Options in Longer Substitutions</head>
                  <p>In the case of the substitution of a group of words, there will usually be more
                     than one way to align the witnesses. The differences in alignment stem from a
                     difference in focus: does the scholarly editor want to give priority to the
                     unit of the substitution, or should the alignment of matching words receive
                     priority? The traditional approach in collation of starting from exact string
                     matches and grouping the variants in columns between the matches has the
                     advantage of accentuating the similarities between witnesses, but the unit of
                     the substitution can become obscured as it is spread over multiple columns.
                     Holding the substitution together in the alignment, on the other hand, keeps
                     the focus on the nonlinear nature of manuscripts as witnesses. It marks the
                     spot where “something happens” on the manuscript and the totality of a textual
                     operation is presented as one block. The drawback is a potential loss of
                     information if the occurrence of a matching word across witnesses is not
                     indicated in the collation output. </p>
                  <p>Consider the example below in figure 15.</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 15: reconstruction of a fragment from Samuel Beckett:
                        Murphy, Draft notebook, University of Reading, Cat. Nr. 5517/6, page
                        26r</hi>
                  </p>
                  <div>
                     <head>Transcription using the TEI del/add method:</head>
                     <p>&lt;xml&gt;Murphy </p>
                     <p>&lt;subst&gt;</p>
                     <p>&lt;del&gt;seized him by the arm.&lt;/del&gt;</p>
                     <p>&lt;add&gt;stayed his hand.&lt;/add&gt;</p>
                     <p>&lt;/subst&gt;</p>
                     <p>&lt;/xml&gt;</p>
                  </div>
                  <div>
                     <head>Transcription using the TEI app/rdg method:</head>
                     <p>&lt;xml&gt;Murphy </p>
                     <p>&lt;app&gt;</p>
                     <p>&lt;rdg varSeq="1"&gt;seized him by the arm.&lt;/rdg&gt;</p>
                     <p>&lt;rdg varSeq="2"&gt;stayed his hand.&lt;/rdg&gt;</p>
                     <p>&lt;/app&gt;</p>
                     <p>&lt;/xml&gt;</p>
                     <p>Given a collation with two slightly different witnesses (B: “Murphy stayed
                        his hand.”, C: “Murphy stayed the arm.”), different scholarly editors might
                        arrive at different alignment tables, but they will largely fall into one of
                        two categories: alignment on matching tokens or on the unit of the
                        substitution. Currently, HyperCollate aligns the witnesses on the unit of
                        substitution and will produce the following alignment table:</p>
                     <figure/>
                     <p>In the future, HyperCollate aims to offer users two options in its output
                        alignment: to give dominance to the matching of tokens, or to preserve the
                        unit of the substitution as much as possible. Users will be then able to
                        indicate their preference by way of a parameter in the collation command.
                        The collation hypergraph and the two possible alignment options are
                        discussed further in section 3.3.4.</p>
                  </div>
               </div>
            </div>
            <div>
               <head>3.3. Collation Output Visualization</head>
               <p>Now that we have established the types of instances of nonlinearity and made our
                  expectations explicit of how HyperCollate should handle such instances, it is time
                  to discuss the current visualizations of the output of HyperCollate. </p>
               <div>
                  <head>3.3.1 Deletions and Additions</head>
                  <p>The collation hypergraph can be visualized, among other formats, as an
                     alignment table (see figure 16). </p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 16: ascii alignment table of the collation output,
                        with the in-text revisions in witness “A” coded with </hi>
                     <hi rend="italic">&lt;add&gt;</hi>
                     <hi rend="italic"> and </hi>
                     <hi rend="italic">&lt;del&gt;</hi>
                     <hi rend="italic">.</hi>
                  </p>
                  <p>In figure 16 the “[+]” and “[-]” in the “A” version correspond to the
                     &lt;add&gt; and &lt;del&gt; elements in the input XML. In the case of the
                     &lt;app&gt;/&lt;rdg&gt; method, the value of the @varSeq attribute is included
                     in the output, as shown in figure 17.</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 17: ascii alignment table of the collation output,
                        with the in-text revisions in witness “A” coded with </hi>
                     <hi rend="italic">&lt;app&gt;</hi>
                     <hi rend="italic"> and </hi>
                     <hi rend="italic">&lt;rdg&gt;</hi>
                     <hi rend="italic">.</hi>
                  </p>
               </div>
               <div>
                  <head>3.3.2 Instant Revisions</head>
                  <p>Collated against a fictional second witness B, the instant revision produces
                     the following ASCII alignment table (figure 18). Note that the visualization
                     options of the ASCII alignment table are limited, which is why the instant
                     deletion is visualized as a regular deletion and the text that follows, “gave
                     such a”, is placed in the same cell and directly above the instant
                     deletion.</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 18: ASCII alignment tables of the collation output of
                        an instant revision.</hi>
                  </p>
                  <p>The HTML alignment table is more powerful and produces a more accurate
                     visualization of the collation result (see figure 19).</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 19: HTML alignment tables of the collation output of
                        an instant revision.</hi>
                  </p>
                  <p>The collation hypergraph visualization (figure 20), finally, demonstrates once
                     more that the instant deletion does not produce an alternative path through the
                     text of witness A. The graph also shows that even though the text tokens
                     “&amp;” and “and” as well as “jerk” and “pull” are aligned in the alignment
                     table visualization, they are not considered a match by the collation
                     algorithm.</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 20: collation hypergraph of the collation output of an
                        instant revision</hi>
                  </p>
               </div>
               <div>
                  <head>3.3.3 Substitutions</head>
                  <p>Figure 21 shows the ASCII alignment tables for a collation of Beckett’s
                     substitution of “Alice” with “Cathleen” against a witness labeled “B”,
                     “Cathleen came.”. When the substitution is encoded with the
                     &lt;del&gt;/&lt;add&gt; method, the word in the &lt;del&gt; element is preceded
                     by “[-]”, and the word in the &lt;add&gt; element with “[+]”, in the case of a
                     transcription that uses the &lt;app&gt;/&lt;rdg&gt; method, HyperCollate
                     reproduces the values of the @varSeq attributes in the &lt;rdg&gt;
                     elements.</p>
                  <table>
                     <row role="data">
                        <cell>
                           <figure/>
                        </cell>
                        <cell>
                           <figure/>
                        </cell>
                     </row>
                  </table>
                  <p>
                     <hi rend="italic">Figure 21: ASCII alignment tables of the collation output, </hi>
                     <hi rend="italic">del/add</hi>
                     <hi rend="italic"> method on the left, </hi>
                     <hi rend="italic">app/rdg</hi>
                     <hi rend="italic"> on the right.</hi>
                  </p>
                  <p>The collation hypergraph (see figure 22), from which the ASCII alignment tables
                     are derived, holds the most contextual information: each node contains a full
                     XPath expression. In a case where two witnesses match on a word, but are not on
                     the same level of the XML tree, two different XPath expressions are listed in
                     the node, bringing both the similarities and the differences to the user’s
                     attention.</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 22: the collation hypergraph of the substitution
                        example.</hi>
                  </p>
                  <p>The instance of nonlinear text is visualized by two separate edges and nodes
                     labeled with the same siglum, “A”. In order to make it easier to follow the
                     path of a certain revision campaign, the edges contain not only information
                     about the witness sigil, but also whether the text is part of a deleted or
                     added branch. This information is visualized on the edges with [-] and [+]
                     signs for deletions and additions respectively. Furthermore, information that
                     is shared by more than one witness is given a thicker edge and node border (see
                     e.g., Jänicke et al 2015). In this example, the words “Cathleen” and “came” are
                     considered matches between A and B and thus share text nodes with a thicker
                     border. Finally, the information about the location of the tag in the XML tree
                     is added to the node as an XPath expression.</p>
               </div>
               <div>
                  <head>3.3.4 Longer Substitutions</head>
                  <p>In the case of a collation of the Beckett example from section 3.2.4 with two
                     other witnesses (B: “Murphy stayed his hand.”, C: “Murphy stayed the arm.”),
                     the collation hypergraph identifies two variant groups across the witnesses
                     (see figure 23).</p>
                  <figure/>
                  <p>
                     <hi rend="italic">Figure 23: collation hypergraph of an example with three
                        witnesses, one of which contains a long substitution.</hi>
                  </p>
                  <p>HyperCollate can express this graph in two possible alignment tables.</p>
                  <div>
                     <head>Alignment on matching tokens</head>
                     <p>The first option presents an alignment of each of the matching tokens in a
                        separate column (see figure 24). It splits the substitution up into
                        token-per-token units in which a deleted and added token are placed together
                        in a column based solely on their position in the token stream.</p>
                     <figure/>
                     <p>
                        <hi rend="italic">Figure 24: collation output expressed in an ascii table
                           with the alignment favouring matching tokens.</hi>
                     </p>
                     <p>This alignment maximally emphasizes the matching words across witnesses.
                     </p>
                  </div>
                  <div>
                     <head>Alignment on the unit of the substitution</head>
                     <p>Alternatively, HyperCollate can take its lead from the unit of the
                        substitution to group words together in its output options, as in figure
                        25.</p>
                     <figure/>
                     <p>
                        <hi rend="italic">Figure 25: collation output expressed in an ascii table
                           with the alignment favouring the unit of the substitution.</hi>
                     </p>
                     <p>In this particular example the two variant groups from the collation graph
                        are presented as separate columns without further subdivision. A variant of
                        the output in an HTML table draws attention to the matching words in these
                        columns (“stayed”, “his hand” and “the arm”) by way of a corresponding
                        background color (see figure 26).</p>
                  </div>
               </div>
            </div>
            <div>
               <head/>
               <p>
                  <hi rend="italic">Figure 26: collation output expressed in an alignment table in
                     HTML.</hi>
               </p>
            </div>
            <div>
               <head>3.4. Evaluation</head>
               <p>In its genetic modules, the BDMP offers users the option of collating all the
                  prepublication versions of one particular sentence in a work by incorporating
                  on-the-fly collation with CollateX 1.7.1. By using CollateX’s pre-tokenized JSON
                  input feature and attaching the extra properties “del” and “add” to tokens (see
                  section 2.4.1), the BDMP can visualize additions and deletions in the generated
                  alignment tables in the same way as it does in the transcription visualizations:
                  deletions struck through and additions in superscript. A comparison of the
                  alignment tables from CollateX and HyperCollate can illustrate the improvement of
                  HyperCollate’s treatment of witnesses in the collation process (see figure
                  27).</p>
               <table>
                  <row role="data">
                     <cell>
                        <figure/>
                     </cell>
                     <cell>
                        <figure/>
                     </cell>
                  </row>
               </table>
               <p>
                  <hi rend="italic">Figure 27: CollateX alignment (left) versus HyperCollate
                     alignment (right) of the example from section 3.2.3.</hi>
               </p>
               <p>Although the CollateX table adequately intuits the in-text revision on the
                  manuscript through the formatting convention, the alignment that CollateX outputs
                  is still conceptually less correct than a visualization that places “Alice” and
                  “Cathleen” on the same level. HyperCollate combines the advantages of the two
                  current approaches described in 2.4.1 and 2.4.2 and does not have the drawbacks. A
                  witness with in-text variation is treated as one witness both in input and output,
                  and the collation algorithm is able to align the two parts of the substitution
                  vertically instead of horizontally in its output by treating them as unordered
                  during alignment, which is a considerable step forward. </p>
               <table>
                  <row role="data">
                     <cell>
                        <figure/>
                     </cell>
                     <cell>
                        <figure/>
                     </cell>
                  </row>
               </table>
               <p>
                  <hi rend="italic">Figure 28: CollateX alignment (left) versus HyperCollate
                     alignment (right) of the example from section 3.2.4.</hi>
               </p>
               <p>In the case of the example discussed in sections 3.2.4 and 3.3.4, the method of
                  collating as one linear witness with markup “passed along” (section 2.4.1), the
                  CollateX output is inadequate, as the alignment table in figure 28 shows. Treating
                  the two parts of the substitution in a linear way is detrimental to the alignment.
                  The words “the arm” and “stayed” are transposed between the first and third
                  witness, and as “the arm” occurs first in the first witness, CollateX marks “the
                  arm” as invariant between those two witnesses in favor of aligning “stayed” which
                  occurs in all three witnesses. The HyperCollate output succeeds quite well in
                  conveying the nonlinearity in the first witness and grouping and aligning the
                  differences with the subsequent witnesses.</p>
               <p> Splitting the first version up into two (sub)versions (see section 2.4.2)
                  produces the desired alignment (figure 29), but misrepresents the manuscript by
                  including the word “Murphy” in version “A-layer1” as well as in “A-layer2”, as the
                  word “Murphy” only occurs once on the document.</p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 29: CollateX alignment table output with the substitution
                     in version “A” split up into two (sub)versions.</hi>
               </p>
            </div>
         </div>
         <div>
            <head>4. Future Work</head>
            <p>At the moment of writing, HyperCollate can already be used via Github or in a Kotlin
                  notebook.<note> See the GitHub of the project here: <ref
                     target="https://github.com/HuygensING/hyper-collate"
                     >https://github.com/HuygensING/hyper-collate</ref>. HyperCollate can be tested
                  with small XML-TEI samples in this binder: <ref
                     target="https://mybinder.org/v2/gh/HuygensING/hyper-collate/master?filepath=notebooks%2Fhyper-collate-readme.ipynb"
                     >https://mybinder.org/v2/gh/HuygensING/hyper-collate/master?filepath=notebooks%2Fhyper-collate-readme.ipynb</ref>.
                  (last accessed October 22, 2021)</note> The collation tool is still in a prototype
               state and we can identify several areas of further development. On the one hand,
               these developments regard the tool’s functionalities, such as generating different
               output formats and collating witnesses regardless of the order in which they are
               inputted (“order independent collation”). At the moment, we use the progressive
               alignment method, which means that the order in which the witnesses are fed to the
               collation program influences the outcome. Evidently, we do not want the order in
               which the witnesses are inputted to affect the collation output, but this is a
               computationally highly complex issue for which as of yet no clear-cut solution has
               been found. </p>
            <p>Another area of future work is more philological, concerning questions such as “How
               should HyperCollate handle open variants?” and “Can we include other types of markup
               in the collation?” In the following paragraphs, we will briefly expand on these and
               other questions. </p>
            <div>
               <head>4.1. Output Formats</head>
               <p>The output of collation software is often used as the basis for further processing
                  or editorial correction. It is therefore important to offer a myriad of options
                  that can be edited afterwards. HyperCollate can currently output collations either
                  as a hypergraph (expressed in SVG, dot, PNG formats) or as an alignment table in
                  ASCII. An HTML implementation of a comparable table format is in development. </p>
               <p> We are also working on output expressed in XML. With the encoding schema we hope
                  to stay as close to the TEI parallel segmentation method as possible. As a
                  starting point we envisage the following:</p>
               <p>&lt;app&gt;</p>
               <p> &lt;rdg wit="#A-" type="deletion" varSeq="1"&gt;</p>
               <p> &lt;del&gt;Alice&lt;/del&gt;</p>
               <p> &lt;/rdg&gt;</p>
               <p> &lt;rdgGrp type="tag_variation_only"&gt;</p>
               <p> &lt;rdg wit="#A+" type="addition" varSeq="2"&gt;</p>
               <p> &lt;add&gt;Cathleen&lt;/add&gt;&lt;/rdg&gt;</p>
               <p> &lt;rdg wit="#B"&gt;Cathleen&lt;/rdg&gt;</p>
               <p> &lt;/rdgGrp&gt;</p>
               <p> &lt;/app&gt; came.</p>
               <p>This encoding complies with the TEI guidelines except that, like in the collation
                  hypergraphs, a “+” or a “-” is added to the siglum “A” when that version splits up
                  into two branches which are placed in two &lt;rdg&gt; elements. As the XML
                  counterpart of a node in the graph where the witnesses have the same text but a
                  different XML context, they are placed as separate readings in a reading group
                  (&lt;rdgGrp&gt;). The element has a @type attribute with the value
                  “tag_variantion_only” to indicate that the readings only differ in the level of
                  the XML elements. The schema is feasible when it concerns simple substitutions,
                  but we will need to determine how well it handles long substitutions or
                  substitutions within substitutions.</p>
            </div>
            <div>
               <head>4.2. Substitutions Within a Word</head>
               <p>Substitutions on the character-level within a word constitute a particular
                  challenge to the automatic collation process. HyperCollate works at the
                  granularity level of the word as a token, and revisions within a word produce
                  isolated characters as tokens.</p>
            </div>
            <div>
               <head/>
               <p>
                  <hi rend="italic">Figure 30: Samuel Beckett: Murphy, Typescript, Harry Ransom
                     Center, Cat. Nr. SB 5/2, page 11r</hi>
               </p>
               <p>In TEI-XML, Beckett’s typo in “Scratch” (see figure 30) could be transcribed as
                  “Scratc&lt;del&gt;g&lt;/del&gt;&lt;add&gt;h&lt;/add&gt;”. Currently this encoding
                  produces three separate tokens: “Scratc”, “g” and “h”, none of which will be
                  aligned with the occurrence of “Scratch” in another version. This is a very
                  challenging problem for any collation algorithm, because it creates the need for
                  an alignment within an alignment: aligning words in a first step and characters
                  subsequently.</p>
               <p>There are a few avenues of development to consider. An approach of “near-matching”
                  might produce adequate results. Another option would be to encode the entire word
                  within a &lt;mod&gt; element,
                     “&lt;mod&gt;Scratc&lt;del&gt;g&lt;/del&gt;&lt;add&gt;h&lt;/add&gt;&lt;/mod&gt;”,<note>
                     Here we choose &lt;mod&gt; instead of &lt;subst&gt; because a &lt;subst&gt;
                     element cannot contain text.</note> which could trigger HyperCollate to
                  translate this into
                  &lt;subst&gt;&lt;del&gt;Scratcg&lt;/del&gt;&lt;add&gt;Scratch&lt;/add&gt;&lt;/subst&gt;.
                  Finally, using the &lt;app&gt;/&lt;rdg&gt; transcription method, a construction
                  with an extra reading, &lt;rdg type="lit"&gt;,<note> Cf. Barbara Bordalejo: “The
                     Commedia Project Encoding System”. <ref
                        target="http://sd-editions.com/AnaServer?commedia+6215691+viewarticle.anv+printdoc=1"
                        >http://sd-editions.com/AnaServer?commedia+6215691+viewarticle.anv+printdoc=1</ref>.
                     (last accessed October 22, 2021)</note> might be considered: </p>
               <p>&lt;app&gt;</p>
               <p>&lt;rdg wit="A" varSeq="1"&gt;Scratcg&lt;/rdg&gt;</p>
               <p>&lt;rdg wit="B" varSeq="2"&gt;Scratch&lt;/rdg&gt;</p>
               <p>&lt;rdg
                  type="lit"&gt;Scratc&lt;del&gt;g&lt;/del&gt;&lt;add&gt;h&lt;/add&gt;&lt;/rdg&gt;</p>
               <p>&lt;/app&gt;.</p>
            </div>
            <div>
               <head>4.3. Open Variants</head>
            </div>
            <div>
               <head>Open variants are also an example of nonlinearity in text. The TEI guidelines
                  suggest that open variants should be encoded with a &lt;seg&gt; element around the
                  inline part of the open variant, followed by one or more &lt;add&gt; elements. For
                  HyperCollate to apply the same treatment to open variants as to substitutions, it
                  will need to recognize a &lt;seg&gt; element and treat it in a similar way to
                  &lt;del&gt; or &lt;add&gt;. Because the &lt;seg&gt; is a general element with
                  several uses, HyperCollate will have to look for a &lt;seg&gt; element with a
                  @type attribute with the value “alternative”. </head>
            </div>
            <div>
               <head>4.4. Transpositions</head>
               <p>A transposition “occurs when metamarks are found in a document indicating that
                  passages should be moved to a different position.”<note>
                     <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#transpo"
                        >https://tei-c.org/release/doc/tei-p5-doc/en/html/PH.html#transpo</ref>.
                     (last accessed October 22, 2021)</note>
               </p>
               <figure/>
               <p>
                  <hi rend="italic">Figure 31: Samuel Beckett: Malone Dies, Typescript, Washington
                     University, Cat. Nr. MSS008/2/47, page 49r</hi>
               </p>
               <p>To tag transpositions, the TEI proposes that both parts be tagged in an element
                  with a @xml:id attribute (the element most commonly used is &lt;seg&gt;), and that
                  the two tags be declared as a transposition inside the teiHeader, in a
                  &lt;transpose&gt; element within a &lt;listTranspose&gt;. The use of
                  @type="transposition" inside the &lt;seg&gt; is not required.</p>
               <p>A transposition can be said to be a nonlinear textual feature; it signals two
                  possible readings of a fragment with a difference in word order. Transposition
                  metamarks, however, do not violate the linearity of the text, as the text fragment
                  does not have two alternatives for one word or phrase, but merely suggests a
                  reordering of two or more words. A special treatment by HyperCollate of this
                  textual feature is not needed to provide a meaningful result. Currently, the
                  source XML is handled by HyperCollate linearly like all other material. The actual
                  word order is collated, and the second, implied order can still be deduced from
                  the markup in the transcription. The same applies to transpositions of letters
                  within words.</p>
               <p>Making the two word orders explicit in the &lt;app&gt;/&lt;rdg&gt; method of
                  transcription, however, will allow for the two versions to be collated:</p>
               <p>&lt;s&gt;and saw it could &lt;app type="transposition"&gt;&lt;rdg varSeq="1"&gt;be
                  still&lt;/rdg&gt;&lt;rdg varSeq="2"&gt;still be&lt;/rdg&gt;&lt;/app&gt; made to
                  serve.&lt;/s&gt;</p>
            </div>
         </div>
         <div>
            <head>5. Conclusion</head>
            <p>In-text variation is essential for the study of textual variance and the TEI
               Guidelines offer several ways to encode this kind of information. Consequently, the
               need to include the information in the automatic collation of manuscript texts is
               apparent. Up to now, including in-text variation was only possible through
               workarounds that either require significant coding skills from the users – passing
               along markup tags as shadow-tokens on the JSON input of CollateX – or by manually
               creating pseudo-versions from the layers of in-text variation and treating them as
               regular versions. These approaches do ensure that information about the in-text
               variation is present in the collation output so that the nonlinear features of the
               individual witnesses can be visually reconstructed. However, the information is not
               part of the alignment process itself: the collation tools treat the input texts as a
               linear, ordered stream of characters and thus ignore the multilayered character of
               manuscript text.</p>
            <p>In this paper, we argued that in-text variation provides meaningful information about
               the temporality of the writing process. We demonstrated that this type of variation
               constitutes nonlinear, partially ordered data and we argued that it should be treated
               as such by collation software. We therefore set out to develop a collation program,
               HyperCollate, that understands each witness as a stream of text tokens that splits
               into two or more “branches” at the point where the internal variation occurs and
               converges at the end of the variation. The occurrences of variation are marked by the
               scholarly editor with designated TEI-XML tags. HyperCollate thus produces a collation
               output that represents the multidimensional nature of the source text more adequately
               and thus corresponds with how the in-text variation was conceptualized and encoded. </p>
            <p>We first described our understanding of different types of in-text variation, and
               subsequently illustrated how that understanding translates logically. We then
               illustrated how the input of HyperCollate, TEI-XML transcriptions, are transformed
               into individual witness hypergraphs with partially ordered textual data. HyperCollate
               then compares two witness hypergraphs and finds the best match between the branches
               of text. In case of more witnesses, HyperCollate compares them progressively.
               Accordingly, the TEI-XML transcriptions that hold so much scholarly information can
               be used as direct input without any need for pre-processing or flattening. We
               concluded that including the in-text variation produces a more refined output that
               more accurately represents the textual variation as interpreted by the scholarly
               editor during the transcription phase.</p>
            <p>One interesting finding is that in case of a longer substitution, the best way to
               collate versions with in-text variation depends on the preference of the scholarly
               editor. They can either prefer to have the collation program align on the unit of
               substitution, or to align on the individual words within the substitution. Future
               users of HyperCollate will be able to indicate their preference in the collation
               command. We also found that the visualization of HyperCollate’s in- and output may
               depend on the user’s preference. Both the input (a version hypergraph) and the output
               (a collation hypergraph) of HyperCollate can be visualized as variant hypergraphs
               with or without markup nodes as colored hyperedges. These visualizations are an
               attempt to provide more insight into the text and its revisions, but visualizing such
               a complex data structure is quite challenging. The output of HyperCollate simply
               contains a lot of information, and it is difficult to visualize all that information
               in a clear and insightful way. This becomes evident with the alignment table
               visualization: the alignment table allows scholarly editors to see at a glance which
               words are added and deleted, but at the same time using the [-] and [+] signs for
               in-text deletions and additions simplify the revision process. Still, an alignment
               table is generally easier to read than a collation hypergraph, and so far
               user-testing has shown that the alignment table does feel intuitive to scholarly
               editors. We will continue to experiment with the visualizations of the collation
               hypergraph, e.g., by adding [-] and [+] signs on the edges of the collation
               hypergraph or by using thicker edges if a token is present in many versions. </p>
            <p>In conclusion, this article aimed to show how formalizing our understanding of
               in-text variation as nonlinear, partially ordered text can help to communicate our
               human understanding to a collation tool. We trained HyperCollate on two TEI-XML
               suggestions for in-text variation, app/rdg and subst/del/add, in order to illustrate
               that the formalization can work for different encoding styles. The larger argument
               made in this article concerns the benefits of reflecting upon our textual models and
               to what extent they impact our encoding models and subsequently the in- and output of
               text analysis tools. </p>
            <p>The development of HyperCollate was propelled by a knowledge exchange between textual
               scholars and research software engineers. This exchange took the form of long
               discussions, much prototyping, experimenting, and testing. Realizing the value of our
               collaboration and ongoing knowledge exchange, we have tried to be transparent about
               our methodology and detailed our textual theories and expectations of the software as
               well as the decision making process of HyperCollate. Indeed, we found collaborating
               on the development of a collation program an insightful, iterative learning process
               that emphasizes the benefits of including computational methods in manuscript
               research. </p>
         </div>


      </body>
      <back>
         <listBibl>
            <bibl xml:id="andrews2013" label="Andrews 2013">Andrews, Tara. 2013. <title
                  rend="quotes">The third way: philology and critical edition in the digital
                  age.</title>
               <title rend="italic">Variants</title>, vol. 10, pp. 61–76.</bibl>
            <bibl xml:id="andrewsmace2013" label="Andrews and Macé 2013">Andrews, Tara L. and Macé,
               Caroline, 2013. <title rend="quotes">Beyond the tree of texts: Building an empirical
                  model of scribal variation through graph analysis of texts and stemmata.</title>
               <title rend="italic">Literary and Linguistic Computing</title>, vol. 28, issue 4, pp.
               504-521.</bibl>
            <bibl xml:id="barabucci2013" label="Barabucci et al. 2013">Barabucci, Gioele, Borghoff,
               Uwe, Di Iorio, Angelo and Schimmler, Sonja. 2013. <title rend="quotes">Document
                  Changes: Modeling; Detection; Storing and Visualization (DChanges).</title>
               Presented at the 2013 ACM Symposium on Document Engineering (DocEng 2013) in
               September 10-13, 2013, Florence, Italy. DOI: <ref
                  target="http://dx.doi.org/10.1145/2494266.2494322"
                  >http://dx.doi.org/10.1145/2494266.2494322</ref>. </bibl>
            <bibl xml:id="barabucci2018" label="Barabucci 2018">Barabucci, Gioele. 2018. <title
                  rend="quotes">Diffi: diff improved; a preview.</title> Presented at the 2018 ACM
               Symposium on Document Engineering (DocEng 2018), August 28-31, 2018, Halifax, Canada.
                  <title rend="italic">Proceedings of the ACM Symposium on Document Engineering
                  2018</title>, pp. 1-4.</bibl>
            <bibl xml:id="barabucci2020" label="Barabucci 2020">Barabucci, Gioele. 2020. <title
                  rend="quotes">The CMV+ P Document Model, Linear Version.</title>
               <title rend="italic">Versioning Cultural Objects: Digital Approaches</title>, vol.
               13, pp. 153-170.</bibl>
            <bibl xml:id="birnbaum2015" label="Birnbaum 2015">Birnbaum, David. 2015. <title
                  rend="quotes">Using CollateX with XML: Recognizing and Tracking Markup Information
                  During Collation.</title> Computer-supported collation with CollateX. Online: <ref
                  target="http://collatex.obdurodon.org/xml-json-conversion.xhtml"
                  >http://collatex.obdurodon.org/xml-json-conversion.xhtml</ref> (last accessed
               October 22, 2021).]</bibl>
            <bibl xml:id="bleeker2018" label="Bleeker et al. 2018">Bleeker, Elli, Bram Buitendijk,
               Ronald Haentjens Dekker, and Astrid Kulsdom. <title rend="quotes">Including XML
                  markup in the automated collation of literary text.</title> Presented at the XML
               Prague conference 2018, February 8-10, 2018. <title rend="italic">XML Prague
                  Conference Proceedings</title>, pp. 77-96. Available at <ref
                  target="http://archive.xmlprague.cz/2018/files/xmlprague-2018-proceedings.pdf#page=89"
                  >http://archive.xmlprague.cz/2018/files/xmlprague-2018-proceedings.pdf#page=89</ref>
               (last accessed October 22, 2021).</bibl>
            <bibl xml:id="bleeker2019" label="Bleeker et al. 2019">Bleeker, Elli, Bram Buitendijk,
               and Ronald Haentjens Dekker. 2019. <title rend="quotes">From Graveyard to Graph:
                  Visualisation of Textual Collation in a Digital Paradigm.</title>
               <title rend="italic">International Journal of Digital Humanities / Special Issue on
                  Digital Scholarly Editing</title>, vol. 1, issue 2, pp. 141-163.</bibl>
            <bibl xml:id="bleeker2020" label="Bleeker 2020">Bleeker, Elli, Bram Buitendijk and
               Ronald Haentjens Dekker. <title rend="quotes">Marking up microrevisions with major
                  implications: Non-linear text in TAG.</title> 2020. Presented at Balisage: The
               Markup Conference 2020, Washington, DC, July 27 - 31, 2020. <title rend="italic"
                  >Proceedings of Balisage: The Markup Conference 2020. Balisage Series on Markup
                  Technologies</title>, vol. 25. <ref
                  target="https://doi.org/10.4242/BalisageVol25.Bleeker01"
                  >https://doi.org/10.4242/BalisageVol25.Bleeker01</ref>. </bibl>
            <bibl xml:id="bordalejo2013" label="Bordalejo 2013">Bordalejo, Barbara. 2013. <title
                  rend="quotes">The Texts We See and the Works We Imagine: The Shift of Focus of
                  Textual Scholarship in the Digital Age.</title>
               <title rend="italic">Ecdotica </title>10: 64-76.</bibl>
            <bibl xml:id="derose2004" label="DeRose 2004">DeRose, Steve. 2004. <title rend="quotes"
                  >Markup Overlap: a review and a horse.</title> Presented at <title rend="italic"
                  >Extreme Markup Languages 2004</title>. Montréal, Québec, August 2-6, 2004.
                  &lt;<ref target="http://xml.coverpages.org/DeRoseEML2004.pdf"
                  >http://xml.coverpages.org/DeRoseEML2004.pdf</ref>&gt; (last accessed October 22,
               2021).</bibl>
            <bibl xml:id="ciula2014" label="Ciula and Eide 2014">Ciula, Arianna, And Øyvind Eide.
               2014. <title rend="quotes">Reflections on Cultural Heritage and Digital Humanities:
                  Modelling in Practice and Theory.</title>
               <title rend="italic">Proceedings of the First International Conference on Digital
                  Access to Textual Cultural Heritage</title>. New York: ACM.</bibl>
            <bibl xml:id="colwell1964" label="Colwell and Tune 1964">Colwell, Ernest C., and Ernest
               W. Tune. 1964. <title rend="quotes">Variant Readings: Classification and Use.</title>
               <title rend="italic">Journal of Biblical Literature</title> 83.3, pp. 253-261.</bibl>
            <bibl xml:id="haentjens2017" label="Haentjens Dekker and Birnbaum 2017">Haentjens
               Dekker, Ronald, and David J. Birnbaum. 2017. <title rend="quotes">It's more than just
                  overlap: Text As Graph.</title> Presented at Balisage: The Markup Conference 2017,
               Washington, DC, August 1 - 4, 2017. <title rend="italic">Proceedings of Balisage: The
                  Markup Conference 2017. Balisage Series on Markup Technologies</title>, vol. 19.
                  <ref target="https://doi.org/10.4242/BalisageVol19.Dekker01"
                  >https://doi.org/10.4242/BalisageVol19.Dekker01</ref>. </bibl>
            <bibl xml:id="haentjens2018" label="Haentjens et al. 2018">Haentjens Dekker, Ronald,
               Elli Bleeker, Bram Buitendijk, Astrid Kulsdom and David J. Birnbaum. 2018. <title
                  rend="quotes">TAGML: A markup language of many dimensions.</title> Presented at
               Balisage: The Markup Conference 2018, Washington, DC, July 31 - August 3, 2018.
                  <title rend="italic">Proceedings of Balisage: The Markup Conference 2018. Balisage
                  Series on Markup Technologies</title>, vol. 21. <ref
                  target="https://doi.org/10.4242/BalisageVol21.HaentjensDekker01"
                  >https://doi.org/10.4242/BalisageVol21.HaentjensDekker01</ref>.</bibl>
            <bibl xml:id="janicke2015" label="Janicke et al. 2015">Jänicke, Stefan, Annette Geßner,
               Greta Franzini, Melissa Terras, Simon Mahony, and Gerik Scheuermann. 2015. <title
                  rend="quotes">TRAViz: A visualization for variant graphs.</title>
               <title rend="italic">Digital Scholarship in the Humanities</title> vol. 30, issue
               suppl. 1, pp. i83-99.</bibl>
            <bibl xml:id="nury2018" label="Nury 2018">Nury, Elisa. 2018. <title rend="italic"
                  >Automated Collation and Digital Editions: From Theory to Practice</title>. PhD
               thesis, London: King's College London. Available at: <ref
                  target="https://kclpure.kcl.ac.uk/portal/en/theses/automated-collation-and-digital-editions(1ffc4aa0-5ad5-4ca1-869a-ab3d528eed4a).html"
                  >https://kclpure.kcl.ac.uk/portal/en/theses/automated-collation-and-digital-editions(1ffc4aa0-5ad5-4ca1-869a-ab3d528eed4a).html</ref>
               (last accessed October 22, 2021).</bibl>
            <bibl xml:id="peters2005" label="Peters 2005">Peters, Luuk. 2005. <title rend="quotes"
                  >Change detection in XML trees: a survey.</title>
               <title rend="italic">3rd Twente Student Conference on IT</title>. Available at <ref
                  target="http://www-poleia.lip6.fr/~gancarsk/grbd09/2005_03_B_Peters,L.J.-Change_detection_in_XML_trees_a_survey.pdf"
                  >http://www-poleia.lip6.fr/~gancarsk/grbd09/2005_03_B_Peters,L.J.-Change_detection_in_XML_trees_a_survey.pdf</ref>
               (last accessed October 22, 2021). </bibl>
            <bibl>Pierazzo, Elena. 2015. <title rend="italic">Digital Scholarly Editing: Theories,
                  Models and Methods</title>. Surrey: Ashgate Publishing, Ltd.</bibl>
            <bibl>Scheibe, Siegfried. 1995. “On the Editorial Problem of the Text.” <title
                  rend="italic">Contemporary German Editorial Theory</title>. eds. Hans Walter
               Gabler, George Bornstein and Gillian Borland Pierce. Ann Arbor: The University of
               Michigan Press.</bibl>
            <bibl>Schmidt, Desmond and Robert Colomb, 2009. "A data structure for representing
               multi-version texts online." <title rend="italic">International Journal of
                  Human-Computer Studies</title>, vol. 67, issue 6, pp. 497-514. <ref
                  target="http://dx.doi.org/10.1016/j.ijhcs.2009.02.001"
                  >http://dx.doi.org/10.1016/j.ijhcs.2009.02.001</ref>
            </bibl>
            <bibl>Schmidt, Desmond. 2019. "A Model of Versions and Layers". In <title rend="italic"
                  >Digital Humanities Quarterly</title>, vol. 13, no. 3, available from <ref
                  target="http://digitalhumanities.org/dhq/vol/13/3/000430/000430.html"
                  >http://digitalhumanities.org/dhq/vol/13/3/000430/000430.html</ref>. </bibl>
            <bibl>Shillingsburg, Peter, 1996. <title rend="italic">Scholarly Editing in the Computer
                  Age: Theory and Practice </title>(3rd Edition). Ann Arbor, Mich.: University of
               Michigan Press.</bibl>
         </listBibl>
      </back>
   </text>
</TEI>
