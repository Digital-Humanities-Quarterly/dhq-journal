<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="../../common/schema/DHQauthor-TEI.rng" type="xml"?>
<?oxygen SCHSchema="../../common/schema/dhqTEI-ready.sch"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:cc="http://web.resource.org/cc/"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dhq="http://www.digitalhumanities.org/ns/dhq">
	<teiHeader>
		<fileDesc>
			<titleStmt>
				<!-- Author should supply the title and personal information-->
				<title type="article" xml:lang="en">Lilypond Music-Notation Software in the Digital-Humanities Toolbox</title>
				<!-- Add a <title> with appropriate @xml:lang for articles in languages other than English -->
				<dhq:authorInfo>
					<!-- Include a separate <dhq:authorInfo> element for each author -->
					<dhq:author_name>Andrew A. <dhq:family>Cashner</dhq:family></dhq:author_name>
					<idno type="ORCID">https://orcid.org/0000-0002-7468-8579</idno>
					<dhq:affiliation>University of Rochester</dhq:affiliation>
					<email>andrew.cashner@rochester.edu</email>
					<dhq:bio>
						<p>Andrew A. Cashner, PhD (University of Chicago, 2015), is the author of <title rend="italic">Hearing Faith:
								Music as Theology in the Spanish Empire</title> (2020) and the winner of the 2015 Alfred Einstein Award from
							the American Musicological Society. He published two volumes of digital critical editions of <title
								rend="italic">Villancicos about Music from Seventeenth-Century Spain and New Spain</title> with the Web
							Library of Seventeenth-Century Music, and has created digital-humanities projects on music in the history of
							computing (<ref target="https://www.arca6150.info">https://www.arca6150.info</ref>) and on Native American
							music. With the support of a Fellowship for Digital Publication from the National Endowment for the Humanities,
							he and Seneca faithkeeper Bill Crouse, Sr., are coauthoring the website and digital book, <title rend="italic"
								>Songs at the Woods’ Edge: The Earth Songs of the Seneca Nation</title>. He has taught music at the
							University of Southern California and the University of Rochester. He is active as a pianist, organist, and
							ensemble director, and teaches in the ROC Music after-school program in Rochester, New York. For more
							information, see <ref target="http://www.andrewcashner.com/">http://www.andrewcashner.com/</ref>.</p>
					</dhq:bio>
				</dhq:authorInfo>
			</titleStmt>
			<publicationStmt>
				<publisher>Alliance of Digital Humanities Organizations</publisher>
				<publisher>Association for Computers and the Humanities</publisher>
				<!-- This information will be completed at publication -->
				<idno type="DHQarticle-id">000573</idno>
				<idno type="volume"><!-- volume number, with leading zeroes as needed to make 3 digits: e.g. 006 --></idno>
				<idno type="issue"><!-- issue number, without leading zeroes: e.g. 2 --></idno>
				<date><!-- include @when with ISO date and also content in the form 23 February 2024 --></date>
				<dhq:articleType>article</dhq:articleType>
				<availability status="">
					<!-- Need to check about this -->
					<!-- If using a different license from the default, choose one of the following:
                  CC-BY-ND (DHQ default): <cc:License rdf:about="http://creativecommons.org/licenses/by-nd/2.5/"/>     
                  CC-BY:  <cc:License rdf:about="https://creativecommons.org/licenses/by/2.5/"/>
                  CC0: <cc:License rdf:about="https://creativecommons.org/publicdomain/zero/1.0/"/>
-->
					<cc:License rdf:about="http://creativecommons.org/licenses/by-nd/2.5/"/>
				</availability>
			</publicationStmt>
			<sourceDesc>
				<p>This is the source</p>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<classDecl>
				<taxonomy xml:id="dhq_keywords">
					<bibl>DHQ classification scheme; full list available at <ref
							target="http://www.digitalhumanities.org/dhq/taxonomy.xml"
							>http://www.digitalhumanities.org/dhq/taxonomy.xml</ref></bibl>
				</taxonomy>
				<taxonomy xml:id="authorial_keywords">
					<bibl>Keywords supplied by author; no controlled vocabulary</bibl>
				</taxonomy>
				<taxonomy xml:id="project_keywords">
					<bibl>DHQ project registry; full list available at <ref target="http://www.digitalhumanities.org/dhq/projects.xml"
							>http://www.digitalhumanities.org/dhq/projects.xml</ref></bibl>
				</taxonomy>
			</classDecl>
		</encodingDesc>
		<profileDesc>
			<langUsage>
				<language ident="en" extent="original"/>
				<!-- add <language> with appropriate @ident for any additional languages -->
			</langUsage>
			<textClass>
				<keywords scheme="#dhq_keywords">
					<!-- Authors may suggest one or more keywords from the DHQ keyword list, visible at https://github.com/Digital-Humanities-Quarterly/dhq-journal/wiki/DHQ-Topic-Keywords; these may be supplemented or modified by DHQ editors -->
					<!-- Enter keywords below preceeded by a "#". Create a new <term> element for each -->
					<term corresp="#access"/>
					<term corresp="#editing"/>
					<term corresp="#markup"/>
					<term corresp="#minimal_computing"/>
					<term corresp="#music"/>
					<term corresp="#tools"/>
					<term corresp="#users"/>
				</keywords>
				<keywords scheme="#authorial_keywords">
					<!-- Authors may include one or more keywords of their choice -->
					<list type="simple">
						<item>music notation</item>
						<item>open-source software</item>
						<item>free software</item>
						<item>minimal computing</item>
						<item>semantic markup</item>
						<item>conversion and exchange</item>
						<item>musicology</item>
						<item>publishing</item>
						<item>editing</item>
						<item>music encoding</item>
						<item>workflow</item>
					</list>
				</keywords>
				<keywords scheme="#project_keywords">
					<list type="simple">
						<item/>
					</list>
				</keywords>
			</textClass>
		</profileDesc>
		<revisionDesc>
			<change>The version history for this file can be found on <ref
					target="https://github.com/Digital-Humanities-Quarterly/dhq-journal/commits/master/articles/000573/000573.xml"
					>GitHub </ref></change>
		</revisionDesc>
	</teiHeader>
	<!-- If a translation is added to the original article, add an enclosing <text> and <group> element -->
	<text xml:lang="en" type="original">
		<front>
			<dhq:abstract>
				<p>The music-notation software Lilypond generates high-quality music typography from a plain-text input format;
					almost every aspect of the program can be customized and programmed, and the system lends itself well to automation
					and batch processing. Lilypond offers a <q>minimal computing</q> alternative to bloated, costly, and hegemonic
					graphical programs. Like many free software tools, however, Lilypond still exacts a cost in time and training
					needed to overcome an unwieldly interface and adapt the tool for scholarly purposes. The author developed a system
					called <hi rend="monospace">lirio</hi> that enabled the production of two critical editions and a monograph in
					Lilypond (integrated with LaTeX). The system provides a new semantic-markup interface to Lilypond that enables
					scholars to think about typography separately from musical content; a range of expanded Lilypond functionality
					including incipit staves, mensural coloration brackets, and editorial annotations; and a stricter input format that
					makes Lilypond files easier to maintain. The author also developed the prototype <hi rend="monospace">ly2mei</hi>
					compiler to demonstrate how Lilypond files can be converted to MEI-XML, overcoming a major limitation in Lilypond’s
					export abilities. The article argues that scholars will be best served by a simple, consistent, meaningful
					interface in a format that can be shared and converted. An extension of Lilypond like <hi rend="monospace"
						>lirio</hi> demonstrates the considerable potential of this tool for enterprising and patient scholars whose
					needs are not met by other tools. Lilypond provides a case study for how to make open-source, free-license tools
					work for our own needs as digital humanists.</p>
			</dhq:abstract>
			<dhq:teaser>
				<!-- Include a brief teaser, no more than a phrase or a single sentence -->
				<p/>
			</dhq:teaser>
		</front>
		<body>
			<div xml:id="section1">
				<head>1 Making Music-Notation Tools Work for Us</head>
				<div xml:id="section01-0">
					<head/>
					<p>Digital humanists who work with music will need tools for creating music notation that they can integrate into a
						digital workflow. Software designed for the practical needs of working musicians like Finale, Sibelius, and
						Dorico may not immediately meet scholars’ peculiar requirements for projects like critical editions,
						musicological articles, and digital catalogs. Commercial notation software is resource-hungry, file formats
						rapidly become obsolete, and interoperability is limited between proprietary software formats. And graduate
						students and faculty with limited research budgets may blanch at the cost of this software: at the time of
						writing, USD $299 for Finale, $579 for Dorico, and $199 <emph>per year</emph> for Sibelius. The free and
						open-source software MuseScore provides ever-stronger competition to these systems but still lacks many of the
						capabilities that scholars need. Another option might be to use the XML format of the Music Encoding Initiative,
						but MEI was designed as a <q>machine-readable</q> system <ptr target="#mei2022"/> and is prohibitively cumbersome
						to write manually, I can say from experience. Moreover, MEI files still need to be rendered graphically in
						another program like Verovio.</p>
					<p>When I found that these tools did not meet my needs, I turned to the notation software Lilypond, an open-source
						program for what its creators call digital music <q>engraving</q> that is free in terms of both cost and license
							<ptr target="#lilypond2022a"/>. After the model of the LaTeX typesetting system <ptr target="#berry_etal2022"
						/>, Lilypond reads plain-text input files in its own language and outputs a graphical format, typically PDF.
						Lilypond’s developers emphasize the program’s ability to produce elegant, clear notation that meets the highest
						standards of traditional music typography.</p>
					<p>Part of the appeal of other document-preparation systems with plain-text input formats is that they make it
						possible to separate content from presentation through semantic markup. My hope was that that since Lilypond uses
						a plain-text input format inspired by TeX, it would allow a similar separation. I wanted to be able to write an
						input file that encoded the core musical information, and leave the fine points of graphical display to the
						software. This promise may be especially appealing to anyone who has spent hours manually positioning graphical
						objects with the mouse in Finale (the most widely used notation software). I could also imagine incorporating
						Lilypond input files into other text-based authoring formats like LaTeX. Lilypond offers users the ability to
						customize its interface and even program it with an embedded Turing-complete programming language (Scheme).
						Additionally, the free cost and license of the software make it accessible to anyone. Lilypond fits within a
						vision of <q>minimal computing</q>
						<ptr target="#risam_etal2022"/>, and users like me who have been attracted to those ideals have seen Lilypond as
						a way to opt out of bloated and hegemonic proprietary systems, much as LaTeX provides a more powerful alternative
						to word-processors like Microsoft Word.</p>
					<p>What I found, however, is that free software still exacts a cost in time and training. Creating Lilypond files,
						using a text-based system to encode an inherently visual medium, is so unlike the process for other software that
						there is a significant learning curve. Even if scholars figure out how to customize Lilypond to meet their needs,
						their options for sharing the files is limited because Lilypond does not export to XML or proprietary formats.
						Where, then, does Lilypond fit in the digital-humanities toolbox? How can we make open-source tools like this fit
						our specialized needs, and what can we learn from the effort to create tools that work for us?</p>
					<p>Over the last ten years I used Lilypond (integrated with LaTeX) for a musicology dissertation, a monograph, and
						two large critical editions, and in the process I have developed my own system of extensions that create a much
						more useful interface than is provided by default <ptr target="#cashner2017"/>, <ptr target="#cashner2020"/>,
							<ptr target="#cashner2021"/>. I also developed a prototype converter program, <ref
							target="https://github.com/andrewacashner/ly2mei"><hi rend="monospace">ly2mei</hi></ref>, to export Lilypond
						files to MEI-XML. Most of these efforts centered on the goal of creating a user interface that separated semantic
						content from graphical presentation. My goal was not only to produce beautiful publications but also to create a
						sustainable workflow that suited the needs of musicologists, editors, and digital-humanities scholars. In this
						article I provide a frank assessment of the successes and shortcomings of this project as a case study in how to
						make an open-source tool work for scholars’ needs. I focus first on the challenge of creating a semantic
						interface for Lilypond that is intelligible to human users and separates presentation from content. I demonstrate
						that it is possible to create a semantic markup format for Lilypond, and I show how this format proved useful in
						my own digital scholarship, while also discussing its limitations. One of the chief advantages of creating a
						consistent, clean, semantic input format is that it enables conversion to other formats, and therefore, on the
						basis of my converter software I offer a proof of concept for converting Lilypond to MEI-XML while acknowledging
						that a fully general solution is a long way away. My efforts demonstrate the considerable potential of this tool
						for enterprising and patient scholars whose needs are not met by other tools, while also highlighting some
						significant areas for expansion and improvement.</p>
				</div>
				<div xml:id="section01-1">
					<head>1.1 Lilypond, A Tool for Automated Music Typesetting</head>
					<p>Lilypond is an open-source, freely available (<q>libre</q>) music-notation program created by Han Wen Nienhuys
						and Jan Nieuwenhuizen <ptr target="#nienhuys_etal2003"/>. Lilypond does not have a graphical interface like
						Dorico or MuseScore, but instead compiles plain-text source programs into PDF or other output, including several
						graphics formats and MIDI. The developers have emphasized beauty and elegance of automated layout, modeled on
						German editions like Bärenreiter and Henle <ptr target="#lilypond2022b"/>.</p>
					<p>I used Lilypond exclusively for about ten years and developed the best workflow I could come up with for my
						needs. While I have mostly switched over to Dorico in the last few years, Lilypond served me well for my
						dissertation, monograph, articles, and critical editions. I was attracted to Lilypond for several reasons. First,
						as a graduate student I had more time available than money; I could not afford commercial notation software but I
						was willing to take the time to learn Lilypond. Second, I cared about typographical quality. For the same reason
						that I was drawn to LaTeX for text typography, Lilypond promised music typesetting of the highest level. Third, I
						had specific music-typesetting needs because of my research in seventeenth-century music that would require
						customization in any software. Lilypond’s power and flexibility meant that I could notate anything I wanted and I
						would be in control of both the input format and the output display. Fourth, I wanted a solution that I could
						integrate into the plain-text, minimal-computing workflow I had already developed around LaTeX: writing small
						files in a text editor (Vim), tracking modifications with version-control software (Git), and batch-processing
						the files using other single-purpose programs.</p>
					<p>Many others have written about the benefits of plain text, and this article is not meant to fan a flame war over
						tools <ptr target="#siddiqui2022"/>; <ptr target="#montalenti2016"/>; <ptr target="#sivers2022"/>; <ptr
							target="#tenen_etal2014"/>; <ptr target="#roberts2005"/>. But it needs to be acknowledged that for all the
						amazing things that modern graphical notation software can do, using a program like Finale or Dorico locks the
						user’s music into a proprietary format over which the user has no control outside that software, leaving them
						vulnerable to version mismatches and platform compatibility issues. A Sibelius user needs to pay hundreds of
						dollars a year just to be able to open their own files, and what happens if Sibelius is sold (again) or goes
						under? As David Thomas and Andrew Hunt argue, <q>The problem with most binary formats is that the context
							necessary to understand the data is separate from the data itself. You are artificially divorcing the data from
							its meaning. The data may as well be encrypted; it is absolutely meaningless without the application logic to
							parse it. With plain text, however, you can achieve a self-describing data stream that is independent of the
							application that created it</q>
						<ptr target="#thomas_etal2020" loc="74–75"/>.</p>
					<p>In my case I could not afford a fast computer with a lot of storage, and so this workflow enabled me to use a
						minimal computer system and still generate excellent output. The text editor provided a lean, distraction-free
						environment for writing, and I liked the promise of <q>future-proof</q> files, as Thomas and Hunt describe:
							<q>Human-readable forms of data, and self-describing data, will outlive all other forms of data and the
							applications that created them. Period. As long as the data survives, you will have a chance to be able to use
							it — potentially long after the original application that wrote it is defunct</q>
						<ptr target="#thomas_etal2020" loc="75"/>. Moreover, as the same authors point out, a plain-text format allows
						users to search, parse, and manipulate the data in multiple ways, using numerous common shell tools and scripting
						languages. That benefit is significant for digital humanists because while our immediate project may be one of
						notation, we are also interested in cataloging and analyzing music in ways that go beyond what a notation program
						alone can allow.</p>
					<p>The Lilypond program, written in C++, reads source files in its own input language. A source file includes one
						or more music expressions, enclosed in curly braces. The music expression will include a series of notes with
						attached articulations, dynamics, and text <q>markups</q>. There may also be expressions of other types, such as
						for lyrics and figured bass. These expressions are included within a score expression, specifying a layout of
						systems and staves. Every element can be configured by overriding defaults. Users can store expressions in
						variables to reuse them later: for example, music and lyrics for each voice could all be stored in separate
						variables and then the variables can be called in the score expression.</p>
					<p>The following code sample (<ref target="#example01">Example 1</ref>) demonstrates all of these features, the
						output is shown further below (<ref target="#figure01">Figure 1</ref>): <dhq:example xml:id="example01">
							<head>Lilypond input</head>
							<eg lang="nohighlight"><![CDATA[
\version "2.22"
\header {
    title   = "Motherless Child"
    composer = "African-American spiritual"
    tagline = ##f % don't add a Lilypond credit to footer
}
MusicS = {
  \clef "treble"
  \time 4/4
  \key des\major        % that is, d-es, D flat
  | des''4 f''2 des''4  % c' = Helmhotz C4
  | f''2 des''4 es''4
  | f''4. es''4. des''4
  | bes'2. r4
  \bar "|."
}
LyricsS = \lyricmode {
  Some -- times I feel
  like a mo -- ther -- less child
}
\score {
  &lt;&lt;
    \new Staff \with { instrumentName = "Soprano" }
    &lt;&lt;
      \new Voice = "Sop" { \MusicS }
      \new Lyrics \lyricsto "Sop" { \LyricsS }
    &gt;&gt;
  &gt;&gt;
  \layout {
    indent = 1\in       % first-line indent
    ragged-right = ##f  % fill the whole line
  }
}
]]></eg>
						</dhq:example>
						<figure xml:id="figure01">
							<head>Lilypond output with default settings.</head>
							<graphic url="resources/images/figure01.png"/>
							<figDesc>A line of engraved music notes and lyrics corresponding to the code above</figDesc>
						</figure></p>
					<p>For configuration and customization, users can create their own commands reminiscent of LaTeX macros. Lilypond
						includes a configuration layer in a custom dialect of the Scheme programming language, making use of the embedded
						GNU Guile interpreter. Through Scheme users can define their own commands with variable input and modify
						Lilypond’s internal implementation in arbitrary ways. For example, a repeat instruction might be inserted with a
						custom command <code lang="unspecified">\RepeatMsg "D. C. al Coda"</code> or <code lang="unspecified">\RepeatMsg
							"Fine"</code>. This kind of command provides a more meaningful semantic interface that separates content from
						presentation.</p>
				</div>
				<div xml:id="section01-2">
					<head>1.2 Can We Have Semantic Markup for Music Notation?</head>
					<p>Semantic markup may formally be a type of encoding but practically it is a tool for writing that relieves the
						author from the burden of considering the message and the medium at the same time. Semantic markup enables the
						writer to focus on clarity of meaning and defer typographic concerns. It is most helpful in settings where the
						presentation of a text has little bearing on the content of that text, or where the same text needs to be
						presented in multiple ways. Semantic markup enables humanists to break down their task into component parts, just
						as software engineers <q>abstract away</q> lower-level implementation details by putting them in separate
						functions that they can modify without altering the program flow. Uncoupling design problems from the structure
						and meaning of the text means that once authors solve a design problem in one document, they can apply that
						solution in many other documents, just as they can also apply different designs to a single document to produce
						different outputs.</p>
					<p>HTML and LaTeX are two of the most commonly used text-markup systems that separate semantic meaning from
						typographic display. When writing the following in HTML, I only need to know that this text is a single
						paragraph, containing one emphasized phrase and one title citation: <eg lang="code-general"><![CDATA[
<p>
  Why there was no room in <em>six volumes</em> of
  Taruskin's <cite>Oxford History of Western Music</cite>
  to include a single reference to Louis Armstrong?
</p>]]>
						</eg> The browser will load default style sheets to display this appropriately, which can be overridden with
						custom Cascading Style Sheets (CSS) to change how the elements <gi>p</gi>, <gi>em</gi>, and <gi>cite</gi> are
						rendered on screen. If at some point I decide to put all the titles in bold, or all the emphasized phrases in a
						different font, I can load a different CSS file without having to modify the main text source file. The Text
						Encoding Initiative’s XML format, in which this article was written, separates content from display so completely
						that users must develop their own systems for displaying the documents outside of a text editor, such as using
						XSLT to transform the XML to HTML and/or LaTeX <ptr target="#tei2022"/>.</p>
					<p>The principle of semantic markup was central in the design of the LaTeX document-preparation system <ptr
							target="#berry_etal2022"/>. Leslie Lamport originally built LaTeX as a macro package for Donald Knuth’s TeX
						system, to meet the needs of authors in mathematics and the natural sciences. Lamport provided a consistent,
						configurable user interface that enabled authors to write documents with a standard set of commands, and then
						they or publishers could typeset those documents in different ways by loading different <q>document class</q>
						files. User configurations could be put into <q>package</q> files, and both packages and classes could be shared
						among users. From this emerged a robust and thriving global community of LaTeX users, who have adapted this free
						software to do everything from professional book publishing to technical diagrams and music notation. (Lilypond
						began as an extension of a TeX-based system, though the current version is independent of TeX.)</p>
					<p>As an example, I wrote my book and editions in LaTeX using a custom class and several original packages that
						have become part of the shared LaTeX library or distribution, TeXLive. The <hi rend="monospace"
							>semantic-markup</hi> package enables a larger number of meaningful markup commands than were provided in
						default LaTeX, modeled after TEI <ptr target="#tei2022"/>. In this passage, I mark up two titles, a quoted
						phrase, and an editorial abridgement using meaningful commands, and let the <hi rend="monospace"
							>biblatex-chicago</hi> package automatically format a citation: <quote rend="block"><code lang="unspecified">
								On the morning when 10,000 started out from Selma, the people sang about \quoted{that great gettin' up
								morning}. \Dots. They sang \wtitle{Oh, Freedom} and various folksongs, but again and again they came back to
								\wtitle{We Shall Overcome}, making up hundreds of verses to fit the simple
								melody.\autocite[472]{Southern:BlackAmericans} </code>
							<lb/>
							<lb/>On the morning when 10,000 started out from Selma, the people sang about <q>that great gettin’ up
								morning.</q> [. . .] . They sang <title rend="italic">Oh, Freedom</title> and various folksongs, but again
							and again they came back to <title rend="italic">We Shall Overcome,</title> making up hundreds of verses to fit
							the simple melody <ptr target="#southern1997" loc="472"/>.</quote> I only need to include the line <code
							lang="unspecified">\usepackage{semantic-markup}</code> in the preamble (configuration section) of my file to
						gain access to the semantic commands. When submitting to a journal using British-style single quotation marks,
						for example, I do not need to change the input text; I simply change a single line of code in the configuration
						file. In my critical editions, the publisher’s house style required that library abbreviations be put in italics.
						This would have been tedious and error-prone to do by hand in a graphical program, but because I was already
						using a custom command (for example <code lang="unspecified">\sigla{D-Mbs}{Mus. ms. 1234}</code>), it was easy to
						redefine that command to add in the italics.</p>
					<p>Compared with these systems for verbal texts, however, musical notation presents a challenge for semantic markup
						because the notation is graphical by nature and the meaning depends on the presentation more than in other kinds
						of texts. The same musical idea could be shown in different clefs, transpositions, or typefaces, but all of those
						elements directly affect performers’ ability to play what is written: the B-flat clarinet player may struggle to
						read a part in concert pitch, the violist will balk at a part in bass clef, and the classical musician might be
						confused by the brush-pen-style jazz font. Nevertheless, we do often need to present the same musical ideas in
						different ways, such as when producing both a full score and performing parts, or when putting multiple parts on
						a single staff, as in woodwind or choral parts. Moreover, it can still be a help to the composer, arranger, or
						editor to be able to put aside certain typographic concerns and address these separately. This is why Dorico
						provides separate panes for setup, writing, engraving, playback, and printing: when in Write mode, Dorico does
						not allow users to manually fine-tune the placement of objects, and in Engrave mode, users cannot change the
						pitches <ptr target="#steinberg2023"/>. This kind of separation of layers, even if it cannot be done as
						pristinely as in other kinds of texts, makes it possible to institute a <q>house style</q> that would apply to a
						whole series of scores, or to use the same source to generate different outputs.</p>
					<p>A semantic-markup system is a user interface — an abstraction layer through which the user controls the program.
						A semantic interface can allow users to <q>turn on</q> the software’s functions without having to understand the
						underlying implementation, and it can allow them to configure the implementation separately. In LaTeX, a command
						like <code lang="unspecified">\section{Introduction}</code> enables the user to call up predefined typesetting
						instructions to get the style of a section heading; while the <hi rend="monospace">sectsty</hi> package provides
						a simple interface to change those instructions, as in <code lang="unspecified"
							>\allsectionsfont{\sffamily}</code> to set all headings in a sans-serif font. A user who wanted to go farther
						than that could use the LaTeX programming interface to create a new structure or just to simplify the interface
						for common patterns. In modern LaTeX you would define the command for RISM sigla to receive two mandatory
						arguments, apply italics to the first argument, and insert a colon and space between the siglum and the locator
						number: <code lang="unspecified">\NewDocumentCommand{\sigla}{ m m }{\textit{#1}: #2}</code> This is not a
						graphical interface, of course, with visual knobs and switches, but it is still an interface in that it empowers
						the user to control the program, while shielding the user from all the details <q>under the hood</q>.</p>
					<p>Lilypond’s creators understood the importance of creating a user interface that separated formatting from
						musical content. As they put it, <q>Lilypond users have to key in the music by hand, so the input format is the
							user-interface to the program</q>
						<ptr target="#nienhuys_etal2003" loc="1–2"/>. Ideally, the Lilypond format would omit <q>as much non-musical
							information as possible, e.g., formatting instructions</q> until <q>we are left with a format that contains
							exactly the musical information of a piece</q>
						<ptr target="#nienhuys_etal2003" loc="1"/>. As the authors acknowledged, the Lilypond program has never fully
						realized this goal, but the Scheme programming layer would allow users to adapt the interface to their own
						needs.</p>
					<p>In its current form, Lilypond’s interface is still closer to Plain TeX than to LaTeX in that it lacks a
						consistent interface for many common tasks. Going beyond very simple notation still requires specifying a lot of
							<q>non-musical</q> information. There are numerous common tasks for which there is no predefined command, or at
						least not a semantic one, and users have to switch back and forth between higher and lower levels of abstraction.
						Lilypond’s syntax is not always consistent, and even seasoned Scheme programmers will have to learn Lilypond’s
						customized dialect of Scheme.</p>
					<p>Some of Lilypond’s challenges stem from the difficulty noted earlier of separating display from content in music
						notation. There are many times when an apparent formatting question like the exact physical placement of a symbol
						does actually turn out to be part of the <q>musical information of a piece</q>, such as a <term>segno</term> mark
						to mark a repeated passage. The distinction between <q>musical information</q> and <q>formatting</q> may well be
						different in each project, contingent on the conventions of the particular music in question. That means that
						even though I regard Lilypond’s default interface as unfinished, its programmability enabled me to make my own
						decisions about how to encode the music semantically.</p>
				</div>
			</div>
			<div xml:id="section02">
				<head>2 Toward a Scholarly, Semantic Interface for Lilypond</head>
				<div xml:id="section02-0">
					<head/>
					<p>To produce my editions I created a set of extensions to Lilypond that I call the <hi rend="monospace">lirio</hi>
						system (from the Spanish for <word>lily</word>). The system consists of a set of Lilypond files that can be
						included in other files to provide an improved user interface with specific functionality needed for editing
						European music of the sixteenth through eighteenth centuries. (<ref target="#section06-1-1">Appendix 6.1.1</ref>
						includes an example of Lilypond output using <hi rend="monospace">lirio</hi>.) Lilypond does not provide any form
						of packages or modules. While I was writing the <hi rend="monospace">lirio</hi> system for my own use, though,
						Urs Liska and others were developing a promising package infrastructure for Lilypond called openLilyLib, which
						may become the basis for future efforts in this area <ptr target="#liska2020"/>. Liska’s ScholarLY package
						provides mechanisms for annotating Lilypond scores, including footnotes, which were not needed in my project but
						contribute to similar goals.</p>
					<p>The <hi rend="monospace">lirio</hi> packages are separated by function and the user can include only those that
						are needed. Like LaTeX packages, some simply provide new commands while others modify default settings when they
						are loaded. It is easy to create a package that combines multiple functions in one (which could be called a
						package collection) by simply putting multiple <code lang="unspecified">\include</code> commands into one file
						and then including that. (I put all of these packages, like a standard library, into a separate directory, <code
							lang="unspecified">~\lib\ly</code>, and then include it at the command line by invoking <code
							lang="unspecified">lilypond -I ~/lib/ly</code>.)</p>
					<p>The main package collections in <hi rend="monospace">lirio</hi> are <hi rend="monospace"
							>standard-extensions</hi> and <hi rend="monospace">early-music</hi>. The standard extensions, which are useful
						in any Lilypond project, provide more semantic and configurable interfaces for many common tasks that are
						difficult to do with the default interface. These include defining markup expressions (objects with formatted
						text), instrument names, section headings, repeat messages like <q>D. C. al Coda</q>, hidden staves, and multiple
						lines of lyrics.</p>
					<p>A few examples can demonstrate how these packages help authors by creating a semantic interface, and the first
						is creating barlines. Out of the box Lilypond provides an interface for creating barlines that uses symbols to
						represent different line types, so the final double bar would be <code lang="unspecified">\bar "|."</code> and
						the beginning of a repeated section would be <code lang="unspecified">\bar ".|:-||"</code>. This interface is
						simple in the sense that there is only one command to remember, <code lang="unspecified">\bar</code>, but I find
						words easier to think about than symbols, so <hi rend="monospace">lirio</hi>’s <hi rend="monospace">barline</hi>
						package replaces those two commands with <code lang="unspecified">\FinalBar</code> and <code lang="unspecified"
							>\RepeatBarStart</code>. Similary, the <hi rend="monospace">instrument-name</hi> package replaces a cumbersome
						default interface with a simple two-argument command to set the full and abbreviated name of a staff, as in <code
							lang="unspecified">\InstrumentName "Violin" "Vn"</code>.</p>
					<p>The biggest obstacle to separating semantic meaning from graphical implementation comes from commands where the
						default interface requires users to specify graphical elements, as in Lilypond’s <code lang="unspecified"
							>\markup</code> command. Lilypond requires that markup commands (such as a <q>Solo</q> indication) be attached
						to notes with a syntax that specifies whether the markup is above or below the staff (<code lang="unspecified"
							>a'4^\markup "Solo"</code> or <code lang="unspecified">a'4_\markup "Solo"</code>). That syntax poses challenges
						for defining new markup commands because the position of a markup might need to be changed later (such as when
						combining two voices on a single staff for a compressed musical example). The <hi rend="monospace"
							>mark-this-up</hi> package eliminates the explicit display instruction (<code lang="unspecified">^</code> or
							<code lang="unspecified">_</code>) so that you can write <code lang="unspecified">a'4 \MarkThisUp "Solo"</code>
						(or <code lang="unspecified">\MarkThisDown</code>). If needed you could later redefine <code lang="unspecified"
							>\MarkThisUp</code> to mean <code lang="unspecified">\MarkThisDown</code> and thus flip all the markup
						positions.</p>
				</div>
				<div xml:id="section02-1">
					<head>2.1 Customizations for Editing Early Modern Music</head>
					<p>The second package collection in the <hi rend="monospace">lirio</hi> system is <hi rend="monospace"
							>early-music</hi>, and it provides customizations and commands that I needed specifically for my editions of
						seventeenth-century music. These include setting beaming to break at syllables in the older style and providing
						commands to insert markings for editorial lyrics, analytical annotations, and <term>musica ficta</term>
						accidentals above the staff. The <hi rend="monospace">ficta</hi> package allows me to specify editorial
						accidentals manually or automatically. In the manual approach, I use package commands to include the accidental:
						e.g., <code lang="unspecified">f'4\sh</code> for F with a suggested sharp. In the automatic approach, I write the
						accidentals the normal way as part of the pitch but put <code lang="unspecified">\ficta</code> before it: <code
							lang="unspecified">\ficta fis'4</code>.</p>
					<p>No software I am aware of makes it possible to markup lyrics semantically in order to show editorial additions.
						Editors of vocal music often need to distinguish between lyric texts that were explicitly notated in the
						manuscript as opposed to repeated texts indicated with abbreviations. Some house styles put those texts in
						italics, while others enclose them in brackets. In graphical software you would have enter the lyrics using the
						graphical interface and then manually select all of the added lyrics with the mouse and format them. Lilypond
						does not provide a semantic interface for this either; you would have to write as follows: <eg lang="nohighlight"><![CDATA[
\lyricmode {
   Sanc -- tus,
   \override Lyrics.LyricText.font-shape = #'italic
   sanc -- tus
   \revert Lyrics.LyricText.font-shape
   sanc -- tus
}
]]></eg> The <hi rend="monospace">lirio</hi> command <code lang="unspecified">\EdLyrics</code> is far simpler to write and
						can be reconfigured: <eg lang="nohighlight"><![CDATA[
\lyricmode { Sanc -- tus, \EdLyrics { sanc -- tus, } sanc -- tus }
]]></eg></p>
					<p>Another non-standard notation made possible by <hi rend="monospace">lirio</hi> is preparatory or incipit staves.
						The <hi rend="monospace">incipit-staves</hi> package demonstrates not only that Lilypond is capable of complex
						layouts that would strain any notation software, but that with a semantic interface it is possible to abstract
						away all of that complexity. Early-music editions often start with a short staff showing the original clefs,
						signatures, and starting notes in the source, something that takes some creativity to accomplish in any software.
						In Lilypond I found I could hack the staff-name interface so that instead of just printing the name, it prints
						both a text label and a separate little staff to the left of the real staff. Being able to program Lilypond meant
						that I could hide all of that under the single command <code lang="unspecified">\IncipitStaff</code>, which takes
						three arguments for the full staff name, abbreviated staff name, and a music expression. Because the music
						expression can also be defined as a separate command, I can further separate the musical content from the
						specification of score layout. To set up the Chorus I, Tiple (boy soprano) I part of Miguel de Irízar’s
						villancico <title rend="italic">Qué música celestial</title>, I put this line of code into the score expression:
							<eg lang="nohighlight"><![CDATA[
\IncipitStaff "TIPLE I-1" "Ti. I-1" { \IncipitSIi }
]]></eg> Then separately I defined the variable with the musical content: <eg lang="nohighlight"><![CDATA[
% Chorus I, Soprano 1 incipit
IncipitSIi = {
  \MSclefGii % treble clef
  \MeterCZ   % Spanish CZ meter symbol (= C3)
  a''2       % first note
}
]]></eg> This example also made use of another <hi rend="monospace">lirio</hi> package that provides semantically-labeled
						glyphs for non-standard early time signatures like C3 and the Spanish cursive CZ symbol, using an actual symbol I
						traced digitally from the manuscript of that 1678 Irízar villancico.</p>
					<p>While much of the actual Lilypond code inside the packages fits easily in the <q>ugly hacks</q> category, the
						interface hides all that from the user. The packages make a lot of new functionality available, while they also
						greatly simplify the interface for using and configuring it.</p>
				</div>
				<div xml:id="section02-2">
					<head>2.2 Under the Hood: Implementation with Lilypond and Scheme</head>
					<p>In order to create these packages, I used both types of programmability that Lilypond provides: those already
						included in the Lilypond language, and those made possible by the embedded Scheme subsystem. We have already seen
						that Lilypond allows you to define variables that can substitute for music expressions or other types of content.
						These are not as flexible as LaTeX macros because they are assigned different internal types and users can only
						use each in the appropriate place for that type. The Lilypond language also allows users to override internal
						properties to change the default values, as in the Sanctus example in the previous section.</p>
					<p>Lilypond also provides a built-in extension language, Scheme, which enables users to create commands of much
						greater complexity. Scheme, a dialect of LISP, is a minimalist but powerful programming language built on
						concepts of lambda calculus <ptr target="#dybvig2009"/>. Outside of Lilypond, Scheme programs are lists in prefix
						notation, and to simplify, Scheme functions take a number of arguments and insert them into the body of the
						function definition. You could use the <hi rend="monospace">define</hi> command to create a function that takes a
						single argument and inserts that argument into a string: <eg lang="nohighlight"><![CDATA[
(define mezzo
  (lambda (dynamic)
    (string-append "mezzo" dynamic)))]]>
						</eg> Given the input <code lang="unspecified">(mezzo "forte")</code>, the Scheme interpreter will evaluate this
						expression and return the string <code lang="unspecified">"mezzoforte"</code>. Scheme within Lilypond allows you
						to make similar substitutions within Lilypond code, though the syntax is different in Lilypond’s custom version
						of Scheme. In the common scenario that Lilypond requires the same long series of override commands every time you
						want to create a particular object, you can put all that code inside a Scheme function so that the user only
						needs to supply the variable information needed to create the object.</p>
					<p>The <hi rend="monospace">lirio</hi> package for semantic section headings models the process of creating a new
						interface. It would be nice to be able to write the LaTeX-like command <code lang="unspecified">\Section
							"Introduction"</code> and have a formatted heading appear. The Lilypond code required to create and style such
						a heading is nasty, but using Lilypond’s modified Scheme syntax, we can hide it in a function that takes one
						argument — the text of the heading — and inserts the text into the required code. The body of the expression can
						still be in Lilypond syntax if it is enclosed in <code lang="unspecified">#{...#}</code> and the function
						argument is preceded by a dollar sign. So we can create this function: <eg lang="nohighlight"><![CDATA[
Section =
#(define-scheme-function
  (SectionText) (markup?)
  "Print a section title"
  #{
    \once \override Score.RehearsalMark.self-alignment-X = #LEFT
    \once \override Score.RehearsalMark.padding = #6
    \once \override Score.RehearsalMark.outside-staff-priority = #2000
    \mark \markup \fontsize #1.5 $SectionText
  #})
]]></eg></p>
					<p>The Scheme interface makes it possible to insert and modify values deep inside Lilypond’s mechanics. Figuring
						out what to put inside the function (that is, how to wrench your way into a particular system without breaking
						everything) can be a nightmare, but once you’ve done it, using the command is easy and can be as user-friendly as
						you make it. Scheme functions can greatly simplify an verbose, cumbersome, or inconsistent interface.</p>
					<div xml:id="section02-2-1">
						<head>2.2.1 A Semantic Interface for a New Feature: Mensural Coloration Brackets</head>
						<p>The <hi rend="monospace">lirio</hi> solution for notating mensural coloration brackets demonstrates one way to
							extend Lilypond’s functionality and create semantic markup for the new feature. Composers in the Spanish Empire
							continued to use mensural rhythmic notation through the end of the seventeenth century, in which a ternary
							meter like C3 was generally notated without barlines, and scribes alerted performers to deviations from the
							normal three-beat groups by blackening in the noteheads. Most modern editors show this with small square
							brackets that frame sequences of colored notes.</p>
						<p>Coloration brackets are not a default feature in any notation software I know of, and so any editor will need
							to create a solution. In a GUI system, I would want to be able to, say, highlight a group of notes and click a
								<q>Coloration</q> button or menu, or hit a custom key command, without having to manually apply and position
							the brackets for every single note. Similarly, in a plain-text workflow, a semantic solution would mean that I
							could indicate the coloration in a way that is independent of how the brackets are ultimately displayed. The
							interface I developed was to use <code lang="unspecified">\color</code> after the first note in the group and
								<code lang="unspecified">\endcolor</code> after the last note. When there was coloration on a single note, I
							wrote <code lang="unspecified">\colorOne</code> after it. This notation is clear, consistent, and easy to type,
							as shown in this sample from my edition of <title rend="italic">Si los sentidos queja forman del pan
								divino</title> by Jerónimo de Carrión (see <ref target="#section06-1-2">Appendix 6.1.2</ref>): <eg
								lang="nohighlight"><![CDATA[
MusicT = {
  \clef "treble"
  \MeterTriple
  | a'2 b'2 c''2
  | f'2\color e'1
  | a'1.~
  | a'2 gis'1\endcolor
  | b'2 c''2 d''2
  | cis''2. cis''4 d''2~\color
  | d''2 e''1\endcolor
}
]]></eg></p>
						<p>Having established a workable interface, how should it be implemented? We need two symbols — a left and right
							short square bracket — and they should be arranged as though on a horizontal line extending over the affected
							notes, as the start and end markers for an octavation line would be. In a GUI program, I would look for the
							tools for creating such lines and create a custom line with the symbols I needed at the ends. In Lilypond, I
							needed to find which built-in capabilities I could hack. As it turns out, Lilypond provides the concept of a
								<q>text span</q>, a horizontal line over a range of notes with optional text on either end, indicated with
							the commands <code lang="unspecified">\startTextSpan</code> and <code lang="unspecified">\stopTextSpan</code>.
							Lilypond does not, however, provide any interface for creating multiple text spanners other than to override
							the <hi rend="monospace">TextSpanner</hi> object’s properties each time. So I needed to create the brackets,
							build the text spanner using the brackets, and define a command that would apply the text spanner to a range of
							notes.</p>
						<p>To draw the brackets, one option would be to use Unicode font characters in a font like Bravura that conforms
							to the Unicode music-notation specification known as SmuFL <ptr target="#steinberg2022"/>. With the font
							properly installed, one could use the Unicode characters at codepoints <code lang="unspecified">U+EA0C</code>
								(<hi rend="monospace">mensuralColorationStartSquare</hi>) and <code lang="unspecified">U+AE0D</code> (<hi
								rend="monospace">mensuralColorationEndSquare</hi>). But introducing new fonts and dealing with character
							offsets and scaling can be difficult in Lilypond; instead I opted to draw them myself. I created two <code
								lang="unspecified">\markup</code> commands using Lilypond’s built-in drawing commands: <eg lang="nohighlight"><![CDATA[
ColorBracketLeft =
\markup { \combine
  \draw-line #'(0 . -1)
  \draw-line #'(1.5 . 0)
}

ColorBracketRight =
\markup { \combine
  \draw-line #'(0 . -1)
  \draw-line #'(-1.5 . 0)
}
]]></eg> (An additional command, <code lang="unspecified">\ColorBracketLeftRight</code>, includes both brackets in one symbol
							to use with <code lang="unspecified">\colorOne</code>). This process is equivalent to going into a symbol
							editor in a GUI program and creating a new symbol with a line-drawing tool, something I have done many times in
							Finale, Sibelius, and Dorico.</p>
						<p>To create the custom text spanner, first I defined a command that would override the defaults to accomplish
							these goals:<list type="ordered">
								<item>Specify that the built-in dashes in the horizontal line should be of length zero, i.e., an invisible
									line</item>
								<item>Include the bracket symbols as the left-hand and right-hand text at the ends of the lines</item>
								<item>Adjust spacing of the line and text as needed</item>
							</list> The code to do this looks like this: <eg lang="nohighlight"><![CDATA[
DrawColorBrackets = {
  \override TextSpanner.dash-period = #0
  \override TextSpanner.bound-details.left.text = \ColorBracketLeft
  \override TextSpanner.bound-details.right.text = \ColorBracketRight
  \override TextSpanner.bound-details.left.attach-dir = #-1
  \override TextSpanner.bound-details.right.attach-dir = #1
  \override TextSpanner.bound-details.left-broken.text = ##f
  \override TextSpanner.bound-details.right-broken.text = ##f
  \override TextSpanner.staff-padding = #2
}
]]></eg></p>
						<p>This of course is the kind of syntax that turns people off to Lilypond, and for good reason. The basic syntax
							here is Lilypond’s own, with backslash commands, but the object-oriented syntax for the text-spanner properties
							comes from C++, and the syntax for the values is from Scheme (hence the pound signs that precede all Scheme
							expressions used within Lilypond). Where do you look up all of the properties that can be overridden or find
							their default values? Why are some values numeric (<code lang="unspecified">#-1</code>) and others are Booleans
								(<code lang="unspecified">##f</code>)? How would someone know that the <code lang="unspecified">#1</code> for
							the <code lang="unspecified">attach-dir</code> property is symbolic (-1 means right edge, 1 means left), while
							the <code lang="unspecified">#2</code> for <code lang="unspecified">staff-padding</code> indicates an actual
							quantity of some unspecified unit?</p>
						<p>An ideal interface would include a command that could create new text-spanner commands and set the default
							properties in a consistent and intelligible way (such as a key-value interface), but since my project only
							needed one text spanner, it was enough to wrap the overrides in the semantic command <code lang="unspecified"
								>\DrawColorBrackets</code>. Thus I was able to set this configuration once and forget it.</p>
						<p>Now all that remained was to define commands to start and stop the text span, which end up just being semantic
							replacements for Lilypond’s built in commands: <eg lang="nohighlight"><![CDATA[
color = \startTextSpan
endcolor = \stopTextSpan
colorOne  = \MarkThisUp \ColorBracketLeftRight
]]></eg> Finally, the package needed to activate the override command to make this the default text spanner. Since in my
							files, coloration brackets were the only kind of text spanner I needed, I override them globally in the whole
							score by including this code: <eg lang="nohighlight"><![CDATA[
\layout {
  \context {
    \Score
    \DrawColorBrackets
  }
}
]]></eg> I put all of the above in a file, <code lang="unspecified">coloration-brackets.ly</code>, and then all I have to do
							is write <code lang="unspecified">\include "coloration-brackets.ly"</code> and I will have access to these
							commands. Including the file will make Lilypond use the layout block above and then the input syntax with <code
								lang="unspecified">\color</code> and <code lang="unspecified">\endcolor</code> will work. The results look
							excellent and I have used them for several years without ever needing to revise the code or to manually adjust
							any of the results. <ref target="#figure02">Figure 2</ref> shows the output of the code at the start of this
								<ref target="#section02-2-1">Subsection 2.2.1</ref>.</p>
						<figure xml:id="figure02">
							<head>Lilypond output with <hi rend="monospace">Lirio</hi> system, including mensural coloration
								brackets.</head>
							<graphic url="resources/images/figure02.png"/>
							<figDesc>Music notes on a staff with small brackets above groups of notes.</figDesc>
						</figure>
					</div>
				</div>
				<div xml:id="section02-3">
					<head>2.3 Crafting Consistent Input Syntax</head>
					<p>The programmable flexibility of Lilypond is a great help in that it makes a custom semantic interface possible,
						but that same flexibility has a cost when the input syntax becomes hard to understand and debug. To further make
						Lilypond work for me, I needed to develop conventions for default Lilypond syntax that would increase
						comprehensibility, reduce errors, and make the project easier to maintain. One obstacle came from Lilypond’s
						allowance for abbreviations, like omitting subsequent rhythms when they are the same (<code lang="unspecified"
							>a'8 b' c''</code> for all eighth notes) and using relative pitches instead of notating the octaves (<code
							lang="unspecified">\relative c'' { a8 b c }</code>). <q>Bar checks</q> (indicated with <code lang="unspecified"
							>|</code>) are optional and many other aspects of the syntax are flexible. These accommodations can make it
						easy to type the code but maddening to debug it. My code conventions, by contrast, were explicit, consistent, and
						— in the best way — boring.</p>
					<p>In my editions I adopted these policies: <list type="unordered">
							<item>No abbreviations</item>
							<item>Write out every rhythm</item>
							<item>Write out every octave (no relative pitches)</item>
							<item>Write one bar per line, with an explicit bar check at the beginning of the line</item>
							<item>Mark measure numbers with comments and spaces (at least every ten bars)</item>
							<item>Use variables to separate out different portions</item>
							<item>Keep notes, lyrics, figured bass, and other markings in different variables</item>
							<item>Do not interperse any low-level typesetting commands or configuration; put all such code in separate
								files (what became the <hi rend="monospace">lirio</hi> library) and call it with semantically meaningful
								commands</item>
						</list>Ideally, the interface would be so consistent, straightforward, and semantically clear that anyone could
						understand its meaning. Someone should be able to notate the music by hand from a printout of the source code
						without needing to know much Lilypond syntax beyond the basics of pitch notation and score-definition commands.
						If the syntax were consistent enough, one could even write a parser or converter program to extract data from it
						independently of the Lilypond program (see <ref target="#section03-1">Section 3.1</ref> below on XML
						conversion.)</p>
					<p>These conventions are demonstrated by the source code of my edition of the Carrión villancico featured earlier
						(see <ref target="#section06-1">Appendix 6.1</ref>). The master file includes the library and the local files
						containing the different layers (notes, words, title metadata, and score layout). The music source file begins
						with variable definitions for the preparatory staves. Next come definitions of the music, one per voice, and a
						separate variable for each of the major sections, the <term>estribillo</term> and <term>coplas</term> (omitted in
						the appendix excerpt). The lyrical text is input in a separate file; in a work for more voices there would be
						separate lyrics expressions per voice. Finally, the score file uses these variables to place the music on staves
						and group the systems.</p>
					<p>Separate files and appropriate use of variables makes it so that the user only thinks about one layer at a time.
						The variable names and the numbered bars make it easy to find specific locations for maintenance and
						corrections.</p>
				</div>
				<div xml:id="section02-4">
					<head>2.4 Configuring a House Style</head>
					<p>Separating out display from semantic content means that you can apply the same <q>house style</q> to a large
						number of scores and batch-process them. The <hi rend="monospace">lirio</hi> font packages make it possible to
						change the font just by loading the package, as in LaTeX. Using the same typeface in the portions typeset by
						LaTeX and Lilypond — the beautiful EB Garamond font, based on sixteenth-century typefaces — gave the edition
						coherence and elegance. A headings package contained the specific layout for titles, headers, and footers. For
						example, a custom footer on the first page includes the manuscript sources and copyright information that were
						previously specified in the <code lang="unspecified">\header</code> expression, plus a page number on certain
						pages: <eg lang="nohighlight"><![CDATA[
\paper {
  % ...
  oddFooterMarkup = \markup {
    \if \on-first-page {
      \vspace #2
      \fontsize #1.5
      \column {
        \line { \fromproperty #'header:source }
        \line { \fromproperty #'header:copyright }
      }
    }
    \if \should-print-page-number {
      \fill-line { \fontsize #4 \fromproperty #'page:page-number-string }
    }
  }
  % ...
}
]]></eg> Simply including the package applies this page format and establishes a coherent look across a set of scores.</p>
				</div>
				<div xml:id="section02-5">
					<head>2.5 Successes and Challenges</head>
					<p>The <hi rend="monospace">lirio</hi> system enabled me to create editions that were typographically beautiful and
						clear, by means of a semantic interface that separated typesetting concerns from thoughts of structure and
						meaning. Lilypond’s plain-text, programmable input format enabled me to reuse the same source files to produce
						different layouts and to redefine commands as needed without having to change the main source. I was able to
						create a consistent house style throughout the editions, and once a certain aspect was configured the way I
						wanted it, I never needed to return to it. Using plain-text source files also meant that I could write programs
						to generate those source files or transform them in ways that could not be done with the proprietary formats of
						graphical software. The minimal computing power required to edit plain-text files meant that I could easily work
						on scores in the airplane or at a conference, on a small screen, without a MIDI keyboard and (using Vim) even
						without a mouse.</p>
					<p>There were also significant challenges, however, some of which remain. Lilypond is free of cost, but it consumed
						countless hours over many years to learn it and adapt it to my needs. The documentation can be confusing and
						inconsistent, like the interface itself. Scheme programmers will quickly discover that Scheme-in-Lilypond is
						really its own domain-specific language with limited capabilities. There is also no standard package or module
						system for sharing, and one is constantly having to reinvent the wheel for what might seem like trivial tasks.
						Lilypond’s frequent updates often break backwards compatibility and change the syntax, which makes it difficult
						to maintain a package library.</p>
					<p>Lilypond’s separation of layers, for all its other benefits, also created problems for debugging and
						maintenance, since data were decoupled and could be spread out among disparate locations in the plain-text
						source. Simple errors in data entry could be difficult to find and correct. In a graphical program, if you
						entered one note in the wrong octave, you would see it immediately and fix it. In Lilypond, it was easy to type
							<code lang="unspecified">a'4 b'4 c'4 b'4</code> and not realize until much later that the third note should
						have been <code lang="unspecified">c''4</code>. My conventions for the input file were essential for searching
						the haystack of code for the tiny needle of an error, which often came down to a single wrong character. Since
						Lilypond’s interface for lyrical text keeps the words separate from the notes, if one syllable is wrong then all
						the subsequent lyrics will be displaced, and it is maddening to sift through many repeated words to find which
						one is out of place.</p>
					<p>Another challenge came from creating performing parts and transpositions. Much as I tried to avoid explicit
						layout commands, some line or page breaks had to be inserted manually, but these would be different in parts as
						opposed to score. Lilypond does provide a mechanism (its <q>tag</q> system) for dealing with this, but it adds to
						the complexity of the project and requires careful discipline to keep the different layers of input separate.
						Transposition is possible, in that you can take a part written in C and change the pitch level of the graphical
						output as needed; but once you’ve written the code in C there is no simple way to change the source.</p>
					<p>Lilypond, in my experience, works best as a pure typesetting tool: I had the fewest problems when I first
						transcribed a piece by hand, and then only used Lilypond to digitally <q>engrave</q> it. I found it prohibitively
						cumbersome to do anything more interactive, such as composition or arranging.</p>
					<p>The last major drawback is with interoperability. There are very limited options for sharing Lilypond files with
						anyone else. Lilypond files of arbitrary complexity cannot currently be converted to XML, whether MusicXML or
						MEI, or to other graphical software formats like Finale or Dorico. Even within the Lilypond world, because there
						is no module system, there is no consistent way to share a code library like <hi rend="monospace">lirio</hi> to
						ensure that everything will work on someone else’s system. This problem is made worse than it needs to be,
						though, by excessively narrow and rigid attitudes toward Lilypond within the scholarly community, a point to
						which I will return.</p>
				</div>
			</div>
			<div xml:id="section03">
				<head>3 Integrating and Exchanging Lilypond Files</head>
				<div xml:id="section03-0">
					<head/>
					<p>For any music-notation software to be an effective tool, it must be possible to integrate its output into
						document-preparation software, and it must be possible to exchange the files with the outside world. There are
						numerous ways to integrate Lilypond with software for text typesetting, but the possibilities for exchanging the
						actual source files are more limited.</p>
					<p>Like other music-notation programs, Lilypond includes only minimal features for text typesetting beyond the
						title block at the top of a score. There are two main strategies for using Lilypond in text documents: <list
							type="ordered">
							<item>Use Lilypond to generate graphics files (PDF or other) and include these in a document-preparation
								program like any other graphic.</item>
							<item>Include the Lilypond code directly in the source code of a document-preparation language like LaTeX and
								use tools to generate the graphics and the document at the same time.</item>
						</list>For the first option, it is important to note that Lilypond-generated graphics could be imported into any
						other software exactly the same way that graphics generated by Dorico or Verovio would be. You could include
						Dorico graphics in LaTeX or you could include Lilypond graphics in Microsoft Word. Once you have generated
						graphics it no longer matters how you produced them.</p>
					<p>For my critical editions I included complete Lilypond PDFs into the full LaTeX document using the <hi
							rend="monospace">pdfpages</hi> package. The edition required running page headings with page numbers that
						needed to be consistent across both text and music portions, so it made more sense to create this formatting in
						LaTeX. I set up the page formatting in Lilypond to leave space for those headings and omit page numbers and then
						generated PDFs of the scores. In LaTeX I pulled in the pages from the PDF and automatically added the relevant
						headings.</p>
					<p>A similar approach works for including smaller portions of music, such musicological examples. I wrote my
						monograph in LaTeX and used Lilypond for all the examples; the publisher converted the LaTeX to their own custom
						TeX system but still used my Lilypond graphics files (PDFs) for the examples. In the <hi rend="monospace"
							>lirio</hi> system I need only include the <hi rend="monospace">example</hi> package to set appropriate
						page-layout options for generating short examples. While Lilypond does provide some faculties for selecting only
						a range of measures out of a full score, I found it easier simply to copy the relevant code for an excerpt into a
						separate input file. Usually I needed to display examples in a different arrangement than the original edition,
						such as putting two voices to a staff for a reduced layout. I used an external program to crop the PDF images
						before including them (<hi rend="monospace">pdfcrop</hi>, available through the TeXLive distribution).</p>
					<p>I found the simplest approach was to generate the PDF output from these Lilypond files separately, one per
						example, and then include them in LaTeX like any other graphics. There is no Lilypond code, then, in my LaTeX
						files; instead there is just a modified <code lang="unspecified">\includegraphics</code> command (from the <hi
							rend="monospace">graphicx</hi> package).</p>
					<p>It would not be very efficient if I had to manually open dozens of files, export them to graphics, crop each
						graphics file, and then import each one into the text-document software. Using Lilypond together with LaTeX on a
						Linux system made it fairly straightforward to automate that whole process using the GNU Make build utility. A
						Makefile spells out the instructions for first building each score PDF, cropping it, and moving it to an output
						directory; then compiling the text document, which includes those images (see <ref target="#section06-1-1"
							>Appendix 6.1.1</ref>). Then I only need to type the command <code lang="unspecified">make</code> in the
						terminal, and the whole document will be generated with all its examples. This system provides the additional
						advantage that I have both the PDF of the full document and a directory with all the PDFs of the individual music
						examples, in case a publisher wants those files submitted separately. A similar approach could be used to
						integrate Lilypond with other scriptable document processors, such as using <hi rend="monospace">pandoc</hi> to
						generate multiple output formats from source files in Markdown.</p>
					<p>Instead of generating the Lilypond output separately, there are a few ways to take the second approach listed
						earlier and insert the Lilypond code directly in a LaTeX file. Lilypond provides a <hi rend="monospace"
							>lilypond-book</hi> script that extracts Lilypond code from a LaTeX file, generates graphics for each excerpt,
						and then includes these graphics back into a main file. The LaTeX package <hi rend="monospace">lyluatex</hi> was
						designed as a replacement for <hi rend="monospace">lilypond-book</hi>; it uses the LuaLaTeX engine, an extension
						of LaTeX that incorporates the Lua scripting language, to integrate Lilypond in LaTeX in a streamlined way <ptr
							target="#peron_etal2019"/>. Users can put inline code inside a <code lang="unspecified">\lilypond{}</code>
						command or complete scores inside the environment <code lang="unspecified"
							><![CDATA[\begin{lilypond} ... \end{lilypond}]]></code>. There is also an <hi rend="monospace">OOoLilypond</hi>
						plugin that allows integration with LibreOffice and OpenOffice. While I found <hi rend="monospace"
							>lilypond-book</hi> to be cumbersome and buggy, <hi rend="monospace">lyluatex</hi> enables true integration of
						LaTeX and Lilypond source code that is ideal for musicological writing, as long as you are comfortable using the
							<hi rend="monospace">lualatex</hi> engine. Also worthy of mention here is the <hi rend="monospace"
							>lilyglyphs</hi> package, which allows LaTeX users to utilize Lilypond’s font glyphs in their text documents,
						allowing more typographic consistency between text and music.</p>
					<p>Musicologists hoping to use Lilypond examples in their journal articles should be aware, however, that most
						journals today do not accept Lilypond output for music examples. Every journal I have published with has had a
						different system: one journal required me to reset the examples in GUI software, while another journal insisted
						on having someone else reset all my examples, producing nearly identical results but introducing numerous errors
						that caused delays.</p>
				</div>
				<div xml:id="section03-1">
					<head>3.1 Conversion and Sharing: Lilypond to XML</head>
					<p>There have been significant efforts in the last decades to develop ways of converting to and from the Lilypond
						format, but no one has yet achieved a comprehensive and functional solution. Lilypond can import from MusicXML
						and MIDI, and in addition to its graphical output it can generate MIDI output. Other projects have achieved
						limited, experimental support for MusicXML output, including a converter tool written in Python and Urs Liska’s
						Scheme module in the openLilyLib, which manipulates Lilypond’s internal Scheme representation of the music file
							<ptr target="#berendson_etal2020"/>; <ptr target="#liska2020"/>; <ptr target="#napoleslopez_etal2019"/>.</p>
					<p>In order to better understand the problem of Lilypond conversion and test the user interface I developed, I
						developed a prototype Lilypond-to-MEI converter, <hi rend="monospace">ly2mei</hi>. The program is a compiler for
						the strict subset of the Lilypond language defined in the <hi rend="monospace">lirio</hi> system. It is written
						in Object Pascal (using the Free Pascal Compiler), a fast, object-oriented, strongly typed, compiled language.
						Without using the actual Lilypond program at all, <hi rend="monospace">ly2mei</hi> parses and converts the
						Lilypond input into XML.</p>
					<p>One of the main obstacles to this conversion is that Lilypond and MEI files follow opposed structures. Lilypond
						files are structured first by voice and then by note (optionally, by measure); MEI files are structure first by
						measure, then by staff and voice. This program transforms one structure into the other.</p>
					<p>The program first reads the variable definitions in the file, and then replaces the variables in the input text
						with their definitions (in other words, it treats them as simple macros). All the information needed for MEI’s
							<gi>meiHead</gi> element is extracted from the Lilypond <code lang="unspecified">\header</code> expression.
						Then <hi rend="monospace">ly2mei</hi> parses the <code lang="unspecified">\score</code> expression and stores it
						in a internal structure. The program converts the score expression to a binary tree of objects that store all the
						necessary information in data structures (lists of pitches, grouped in lists of measures; lists of lyrics and
						different types of lines). From that structure it extracts the information it needs to generate the MEI
							<gi>scoreDef</gi> element (specifying number of staves, key signature, and other top-level information).</p>
					<p>Converting pitches, rhythms, and other basic notations is fairly straightforward. Since pitches in Lilypond
						input are separated by spaces, it is simple to break the music input into space-delimited sections, and then
						parse each. Because the program requiring consistent input, it assumes that every pitch is in the format
							<emph>(pitch name, including accidental)(octave tick marks)(duration number)(optional rhythm dot)(attached
							lines and markups)</emph>, as in <code lang="unspecified">cis''4.\fermata</code>. The program extracts these
						data and stores them in its own data structures. The <hi rend="monospace">TPitch</hi> object includes fields for
						pitch name, accidental, octave, duration, dots; attached ties, slurs, coloration, ligatures, articulations, and
						other markups; and a syllable of lyric text (see <ref target="#section06-3-1">Appendix 06.3.1</ref>).</p>
					<p>Since this class also contains all the information needed for an MEI <gi>note</gi> element, it is
						straightforward to generate MEI data from it. The <hi rend="monospace">TMeiNoteRest</hi> type is used for an
						internal representation of an MEI node, and its constructor function knows how to create a node from a <hi
							rend="monospace">TPitch</hi> object (see <ref target="#section06-3-2">Appendix 06.3.2</ref>). Calling the
						method <hi rend="monospace">XMLString</hi> of the resulting node will yield the proper MEI, such as the
						following: <code lang="xml">&lt;note pname="c" oct="4" accid="s" dur="4" dots="1" /&gt;</code></p>
					<p>The real challenge is in converting the structure of a Lilypond file to that of MEI. In Lilypond, the tree is
						initially structured hierarchically by staff and voice (StaffGroup/Staff/Voice/Measure/Pitch). The program
						converts this to the MEI structure of Measure/StaffGroup/Staff/Layer/Pitch. The program finds the first list of
						measures in the tree, and then recurses through the tree to find the same measure in each voice. It copies the
						tree structure leading to that voice, but selects only the relevant measure at the bottom level; it attaches
						these branches to a new root for that measure, and then attaches all the measures to a common score root. <ref
							target="#section06-3-3">Appendix 6.3.3</ref> includes the core function for flipping the tree structure.</p>
					<p>To deal with Lilypond variables, the program implements a basic macro expander that actually allows more
						flexibility than Lilypond itself. With the definition <code lang="unspecified">macro = "string"</code> or <code
							lang="unspecified">macro = { expression in braces }</code> starting on a new line, you can use <code
							lang="unspecified">\macro</code> anywhere, even before the definition, without worrying about the mode or type
						of expression.</p>
					<p>The program’s parsing functions are fairly limited. It works only if the Lilypond input is limited primarily to
						pitches, rhythms, slurs, and lyrics, and if the conventions described <ref target="#section02-3">Section
							2.3</ref> above are followed strictly (no abbreviations, every bar marked with <code lang="unspecified"
							>|</code>). Further work could combine this basic approach with a more robust parser that could understand more
						of Lilypond or even Scheme, and could include a configuration interface whereby users could specify conversions
						for their own commands. A different approach would hook into Lilypond’s own parsing algorithm, probably making
						use of the internal Scheme representation it develops for the whole input program.</p>
				</div>
			</div>
			<div xml:id="section04">
				<head>4 Conclusions</head>
				<p>Where does Lilypond fit in the digital-humanities toolbox? If music notation of high typographical quality is
					needed and a plain-text format is amenable to a project’s goals, then Lilypond can be a powerful tool. Its
					programmability means that the input interface can be adapted to suit the project’s needs, while the graphical
					output can separately be fine-tuned and extended to cover nearly any notation. For large editing projects that need
					a consistent house style, Lilypond can work well if best practices like those used in the <hi rend="monospace"
						>lirio</hi> system are maintained strictly to separate out the layers of information and make it easier to
					correct and adjust. Lilypond excels at generating smaller musical examples such as for musicological articles, and
					it lends itself well for integration with LaTeX, not only because of the plain-text format but because of tools
					developed in the LaTeX community designed for this purpose. Rather than having to fire up a graphical program and
					work with a large file, a music example can be generated in just a few lines of code, and with the appropriate
					Makefile, a complex article with many examples can be generated just by typing <code lang="unspecified"
					>make</code>.</p>
				<p>With a converter to XML like <hi rend="monospace">ly2mei</hi>, Lilypond files could be used for typesetting
					digital editions while still using XML for archival preservation, or as input to a machine-learning system. Using
					Lilypond together with XML would not only separate content from presentation but would allow further separation of
					authoring, publishing, storage, and post-processing, including data mining. Lilypond could also be used as an input
					format for library-science and cataloguing projects in digital humanities. The input file would just define
					Lilypond variables (such as <code lang="unspecified">title = "Je ne vis oncques la pareille"</code> and <code
						lang="unspecified">melody = { d'2. e'4 f'2 g'2 b'2. a'4 a'2 }</code>), and these could be inserted into a
					Lilypond score template that uses those variables. Graphical output and MEI could be generated by running Lilypond
					and <hi rend="monospace">ly2mei</hi> on that same file. Compared with MEI, the Lilypond source is much easier for
					humans to understand and edit, though the XML could still be used in the database as the machine-readable form. For
					the same reasons, along with Lilypond’s high-quality graphical output, Lilypond could serve as an input language
					and backend rendering system for digital interactive music publications.</p>
				<p>Given all these applications and possibilities for further extension, Lilypond is a versatile tool for
					digital-humanities research. We should not overlook the economic reality that notation software is expensive, and a
					tool that is free both in terms of cost and license can be more accessible to people in historically disadvantaged
					groups. Lilypond’s open-source code will always be available for inspection and modification in ways that are not
					possible with proprietary commercial software. If its input files are written carefully, they can be parsed by a
					tool like <hi rend="monospace">ly2mei</hi> that does not even use Lilypond, effectively future-proofing them.
					Lilypond shines in settings that benefit from automation, if users are willing to configure it to their needs.</p>
				<p>Digital tools are meant to make our lives easier by automating and simplifying tasks that would otherwise be
					drudgery — and our responsibility in using those tools is to ensure that they are in fact reducing our problems and
					not increasing them. When we find that we are sacrificing ourselves at the altar of any program and contorting our
					thinking to fits its structures, we are not making the best use of our technology. There are numerous situations
					for which a graphical notation program is not the best tool, and in which a machine-readable format like MEI is not
					amenable to a human user’s needs. Lilypond offers the possibility of a human-writable format for complex, automated
					notation, and when the interface can be made reasonable, it allows a productive separation of elements. At the same
					time, wrangling with Lilypond can become a burden of its own. When Lilypond syntax enters into a realm of
					incomprehensible, ugly hacks full of Scheme-as-adapted-by-Lilypond, then it is no longer a system suited to humans.
					If we can hide those hacks behind the abstraction layer of a reasonable semantic interface, however, then we gain
					the power of a tool customized to our specific needs and preferences.</p>
				<p>The digital literacy gained from wrangling open-source software like Lilypond can only help scholars in an
					ever-more-digital world of research and publication. At a time when AI seems likely to reduce technological
					literacy even further, scholars who can control their digital tools will have an advantage. My effort to learn
					Lilypond further motivated me to learn two other programming languages and numerous command-line tools, while
					prompting the critical reflections on semantic encoding, content vs. presentation, user-interface design, and music
					engraving that I am communicating here. Having more tools in the toolbox means that I can face a wider variety of
					challenges and be creative in developing my own solutions, not just the ones available off the shelf for a $200
					annual subscription.</p>
				<p>Digital humanists will often find, however, that free and open-source software has a double edge: we
						<emph>can</emph> customize it to make it work for us, but we also <emph>have to</emph> customize it and that
					comes with a cost. Not only does it take time and training to optimize these tools for our needs; it also means
					that we can end up essentially creating our own software tool that no one else can use. Our colleagues will likely
					be unwilling to make a similar investment to understand our bespoke toolchain, and in the end we must often take on
					the additional burden of converting our systems to the proprietary formats that we started out trying to avoid
					(Finale, MS Word).</p>
				<p>We need more middle ground between the specialized, highly technical computer-science research related to music,
					on the one hand, and the practical concerns of most music scholars on the other. The learning curve for humanists
					interested in a deeper understanding of digital tools is prohibitively steep. Given that very few musicologists
					even know how to use a text editor, there is a great need to develop better interfaces that people who <q>only</q>
					know musicology and not computer science can actually use. The people who most need a software features like
					coloration brackets are not generally the people best suited to implement it in software, and we do not have enough
					ways for non-experts to configure software.</p>
				<p>By the same token, though, scholars who opt not to keep up with the development of digital tools should not impose
					their own limitation on others. There is no good reason why journals should still be requiring all text submissions
					in Microsoft Word and all music submissions in Finale or Sibelius. If journals would accept <q>camera-ready</q>
					graphics files of music examples from authors, for example, it would democratize access. Does an editor really need
					to be able to edit the source of a music example directly? For my editions with the Web Library of
					Seventeenth-Century Music, the editor and reviewers had no problem proofreading the PDFs and instructing me to make
					changes. In an era in which few people page through a full paper journal volume, is a house style so important that
					every music example must be produced in the same software, no matter what the cost to authors? If an edition is
					going to be printed in a book and purchased mainly by libraries, does it really matter what software it was
					produced in? If the goal is just producing beautiful output, then all that matters is what best served the author.
					On the other hand, if the goal is to produce some kind of interactive, flexible format that can be modified,
					adapted, and extended <ptr target="#grunacher2022"/>, then do any of our systems really provide that? There are
					even times in our largely paperless world when in my work as an ensemble director I have it found faster to write
					out a part by hand, take a picture on my phone, and text it to a performer, than to mess with any notation
					software.</p>
				<p>In this area as in many others, we need to stand against prejudice and narrowness in academia, against the fear of
					difference as well as inordinate pride in our own ways of doing things (i.e., tool evangelism). We need to advocate
					for a supportive community that respects people’s time and resources and allows them the flexibility to use
					whatever tools work best for them, and we need to provide resources for people to learn those tools (such as in PhD
					programs). To adapt Monteverdi’s maxim about words and music, the author should be the master of the tools; the
					tools should not operate the master.</p>
				<p>Above all, digital humanists should be choosing tools based on the ultimate goal of sharing information as widely
					as possible and enabling intellectual discourse. That was the purpose of print publishing when printing something
					was the most effective way to disseminate it. Academic publishing today too often serves the opposite purpose,
					slowing down production times through inordinately long peer review and editing phases and locking the results
					behind paywalls and proprietary formats. Today we have many media through which to disseminate information
					instantly, and most of us have on our personal computers enough technology to run our own publishing companies. But
					too often our software takes much more from us than it gives back. When our <q>publishing</q> tools and systems
					actually serve to slow down the flow of information, are they really serving us?</p>
			</div>
			<div type="appendix" xml:id="section05">
				<head>5 Acknowledgments</head>
				<p>This work was completed on the ancestral land of the Onöndowa’ga:’ (Seneca) Nation, one of the Six Nations of the
					Haudenosaunee (Iroquois) Confederacy. Thanks are due to Devin Burke, the editors, and the anonymous reviewers for
					their helpful feedback. Thank you to Kris Shaffer for introducing me to Lilypond, and to Jeanette Tilley for
					allowing me to use the system I describe here with the Web Library of Seventeenth-Century Music. I would also like
					to thank all the contributors to the open-source software I used in this project, including Lilypond, TeX and
					LaTeX, Free Pascal, GNU Make and Guile (Scheme interpreter), Vim, and Debian and Fedora Linux.</p>
			</div>
			<div type="appendix" xml:id="section06">
				<head>6 Appendix</head>
				<div xml:id="section06-1">
					<head>6.1 Example Music Edition in Lilypond with <hi rend="monospace">lirio</hi> System</head>
					<div xml:id="section06-1-1">
						<head>6.1.1 Graphical Output</head>
						<figure>
							<graphic url="resources/images/figure03.png"/>
							<figDesc>Sheet music for "Si los sentidos queja forman del Pan Divino"</figDesc>
						</figure>
					</div>
					<div xml:id="section06-1-2">
						<head>6.1.2 Complete Lilypond Source Code (Excluding <term>Coplas</term> Section)</head>
						<eg lang="nohighlight"><![CDATA[
% file master.ly

%% JERONIMO DE CARRION
%% SI LOS SENTIDOS QUEJA FORMAN DEL PAN DIVINO
%% E-SE: 28/25

\version "2.19"
\include "villancico.ly"
\include "include/music.ly"
\include "include/lyrics.ly"
\include "include/header.ly"
\include "include/score.ly"

% ----------------------------------
% file include/header.ly

\header {
  title    = "Si los sentidos queja forman del Pan Divino"
  subtitle = "Villancico al Santísimo Sacramento. Solo."
  composer = "JERÓNIMO DE CARRIÓN"
  dates    = "(1660–1721)"
  poet     = "Attr. Vicente Sánchez"
  source   = \markup { \concat { 
    "Segovia, Cathedral Archive ("
    \italic "E-SE"
    ": 28/25)" }
  }
}

% ----------------------------------
% file include/lyrics.ly

LyricsEstribilloSolo = \lyricmode {
  Si los sen -- ti -- dos
  que -- ja for -- man del Pan Di -- vi -- no,
  por -- que lo que~e -- llos sien -- ten 
  no~es de Fe con -- sen -- ti -- do,
  \EdLyrics { no~es de Fe con -- sen -- ti -- do, }
  to -- dos hoy con la Fe se -- an o -- í -- dos,
  to -- dos hoy con la Fe se -- an o -- í -- dos.
  No se den, no se den por sen -- ti -- dos los __ sen -- ti -- dos,
  no se den, \EdLyrics { no se den } por sen -- ti -- dos
  los __ sen -- ti -- dos.
}

%% ALL TOGETHER
LyricsSolo = \lyricmode {
  \LyricsEstribilloSolo
}

% ----------------------------------
% file include/music.ly

IncipitGlobal = {
  \MeterZ
}

IncipitSolo = {
  \MSclefCii
  a'2
}

IncipitAc = {
  \MSclefCiv
  a1.
}


EstribilloSolo = {
  \clef "treble"
  \MeterTriple

  \Section "ESTRIBILLO"
  | a'2 b'2 c''2
  | f'2\color e'1
  | a'1.~
  | a'2 gis'1\endcolor
  | b'2 c''2 d''2
  \break
  | cis''2. cis''4 d''2~\color 
  | d''2 e''1\endcolor
  | R1.
  | r2 c''2 g'2

  % m. 10
  | a'2 f'2 g'2
  | e'1.~\color
  | e'2 d'1\endcolor
  \break
  | r2 e'2 g'2
  | fis'2. g'4 a'2
  | a'2\color gis'1\endcolor
  | r2 a'2 c''2
  | b'2. c''4 d''2
  | d''2\color cis''1\endcolor
  | R1.

  % m. 20
  | r2 e''2 b'2
  | c''2 a'2 b'2
  | gis'1.
  | e''2 c''2 d''4( c''4)
  | b'2\color c''1\endcolor
  | R1.
  | r2 c''2 g'2
  | a'2 f'2 g'2
  | e'1 r2
  | c''2 a'2 b'4( a'4)

  % m. 30
  | gis'2\color a'1\endcolor
  | R1.
  | r2 a'2 d''2
  | cis''2 r2 r2
  | r2 a'2 d''2
  | cis''2 d''2 e''2
  | f''1.
  | e''2\color e''1~
  | e''2\endcolor d''2 d''2~\color
  | d''2 cis''1\endcolor

  % m. 40
  | R1.
  | r2 e'2 a'2
  | gis'2 r2 r2
  | r2 e'2 a'2
  | gis'2 a'2 b'2
  | c''1.
  | b'2\color b'1~
  | b'2\endcolor a'2 a'2~( 
  | a'2 gis'1)

  % m. 49
  | a'1.
  \Fine
  \FinalBar
}

EstribilloAc = {
  \clef "bass"
  \MeterTriple
  | a1.
  | d'2\color c'1\endcolor
  | f1.
  | e1. 
  | gis1.
  | a1\color d'2~
  | d'2\endcolor c'2 g2
  | a2 f2 g2
  | e2 a2 e2

  % m. 10
  | f2 d2 e2
  | c2 c'2 g2 
  | a2 f2 g2
  | e1.
  | d1.
  | e1.
  | a1.
  | gis1.
  | r2 a2 e2 
  | f2 d2 e2

  % m. 20
  | c2\color e1
  | a2 f1\endcolor
  | e2 e'2 b2
  | c'2 a2 b2
  | gis2 a2 e2 
  | f2 d2 e2
  | c2\color e1 
  | f2 d1\endcolor
  | c2 c'2 g2
  | a2 f2 g2

  % m. 30
  | e2 f2 c2
  | d2 b,2 c2
  | a,2\color d1\endcolor
  | a,2 a2 d'2
  | cis'2\color d'1\endcolor
  | a2 b2 c'2
  | f2 a,2 d2
  | cis2 d2 e2
  | f1. 
  | g2\color a1\endcolor

  % m. 40
  | e'2 e2 a2
  | gis2\color a1\endcolor
  | e'2 e2 a2
  | gis2\color a1\endcolor
  | e2 f2 g2
  | c2 e2 a2
  | gis2 a2 b2
  | c'1.
  | d'2\color e'1\endcolor

  % m. 49
  | a1.
  \FinalBar
}

FiguresEstribilloAc = \figuremode {
  \MeterTriple
  | s1.
  | s1.
  | s1.
  | &lt;4&gt;1.
  | s1.
  | s1. 
  | s1 &lt;6&gt;2
  | s1.
  | s1.

  % m. 10
  | s1. 
  | s1 &lt;6&gt;2
  | s2 &lt;6&gt;2 s2
  | s1.
  | &lt;_+&gt;1.
  | &lt;4&gt;1.
  | s1.
  | s1.
  | s2 &lt;_+&gt;2 &lt;6&gt;2
  | s1. 

  % m. 20
  | s1. 
  | s1.
  | &lt;_+&gt;2 s1
  | s1.
  | s1 &lt;6&gt;2
  | s1.
  | s2 &lt;6&gt;1
  | s1. 
  | s1. 
  | s1. 

  % m. 30
  | s1. 
  | s1. 
  | s1. 
  | &lt;_+&gt;2 s1
  | s1.
  | &lt;_+&gt;2 s1
  | s2 &lt;6&gt;2 s2
  | s1.
  | &lt;7&gt;1.
  | s1. 

  % m. 40
  | s1. 
  | s1. 
  | s1. 
  | s1.
  | &lt;_+&gt;2 s1
  | s2 &lt;6&gt;2 s2
  | s1.
  | &lt;7&gt;1.
  | s1.

  % m. 49
  | s1.
}

%************************
% ALL TOGETHER

MusicSolo = { 
  \EstribilloSolo
}
MusicAc = {
  \EstribilloAc
}
FiguresAc = {
  \FiguresEstribilloAc
}

% ----------------------------------
% file include/score.ly

\score {
  &lt;&lt;
    \new Staff
    &lt;&lt;
      \IncipitStaff "SOLO" "" { \IncipitSolo }
      \new Voice = "Solo" { \MusicSolo }
      \new Lyrics \lyricsto "Solo" { \LyricsSolo }
    &gt;&gt;
    \new ChoirStaff 
    &lt;&lt;
      \ShowChoirStaffBracket
      \new Staff
      &lt;&lt;
        \IncipitStaff "ACOMP." "" { \IncipitAc }
        \new Voice = "Acomp" { \MusicAc }
        \new FiguredBass { \FiguresAc }
      &gt;&gt;
    &gt;&gt;
  &gt;&gt;
  \layout {
    indent = 1.5\in
    short-indent = 0\in
  }
}]]></eg>
					</div>
				</div>
				<div xml:id="section06-2">
					<head>6.2 Example Makefile for a LaTeX Project including Lilypond PDFs</head>
					<eg lang="nohighlight"><![CDATA[
# Makefile for LaTeX document that includes Lilypond examples

# Output directories
dirs = aux aux/img build build/img

# Input files
## Lilypond
ly_in    = $(wildcard music-examples/*.ly)

## LaTeX
tex_in   = $(wildcard *.tex)
tex_conf = $(wildcard *.sty *.cls)
bib      = $(wildcard *.bib)

# Output files
ly_img   = $(addprefix build/img/, $(notdir $(ly_in:%.ly=%.pdf)))
pdf_out  = $(addprefix build/,$(tex_in:%.tex=%.pdf))

.PHONY : all view clean

# Command `make` to generate all outputs
all : $(pdf_out)

$(pdf_out) : $(ly_img)

$(dirs) :
        mkdir -p $(dirs)

# Build LaTeX PDF including Lilypond PDFs
build/%.pdf : aux/%.pdf
        cp -u $&lt; $@

aux/%.pdf : %.tex $(bib) $(tex_conf) $(ly_img) | $(dirs)
        latexmk -outdir=aux -pdf $&lt;

# Build cropped Lilypond PDFs
build/img/%.pdf : aux/img/%.pdf
        pdfcrop $&lt; $@

aux/img/%.pdf : music-examples/%.ly | $(dirs)
        lilypond -I ~/lib/ly -o $@ $&lt;

# `make view` to see output PDF
view : $(pdf_out)
        evince $(pdf_out) &amp;

# `make clean` to delete output and start over
clean :
        rm -rf $(dirs)
]]></eg>
				</div>
				<div xml:id="section06-3">
					<head>6.3 Key Data Structures and Functions of the <hi rend="monospace">ly2mei</hi> Lilypond–MEI Converter</head>
					<div xml:id="section06-3-1">
						<head>6.3.1 <hi rend="monospace">TPitch</hi>, the Internal Structure for a Single Note</head>
						<eg lang="nohighlight"><![CDATA[
type
  TPitch = class
  private
    var
      { From automatically generated GUID }
      FID: String;

      { Label for pitch name, e.g., @link(pkC) or if rest, @link(pkRest) }
      FPitchName: TPitchName;

      { Label for accidental, e.g., @link(akNatural) }
      FAccid: TAccidental;

      { Label for accidental type (explicitly written out or implied by key
      signature) }
      FAccidType: TAccidType;

      { Helmholtz octave number }
      FOct: Integer;

      { Label for duration, e.g., @link(dkMinim) }
      FDur: TDuration;

      { Label indicates whether tied or not, and if so, what is the position
        (start/middle/end)? }
      FTie: TMarkupPosition;

      { Label indicates whether a slur is connected to this note, and if so,
         its position }
      FSlur: TMarkupPosition;

      { Label indicates position of note in a coloration bracket, if any }
      FColoration: TMarkupPosition;

      { Label indicates position of note in a ligature bracket, if any }
      FLigature: TMarkupPosition;

      { Record with boolean flags for possible articulation labels }
      FArticulations: TArticulationSpec;

      { A string with additional text paired with this pitch. }
      FAnnotation: String;

      { One syllable of text to be sung to this note, with indication of
      syllable position }
      FSyllable: TSyllable;

  public
    constructor Create();

    { Create from a Lilypond input string; set the accidental relative to the
      given key. }
    constructor Create(LyInput: String; Key: TKeyKind);

    { ... }
  end;

{ ... }

constructor TPitch.Create(LyInput: String; Key: TKeyKind);
var
  NoteStr, PitchNameLy, OctLy, DurLy, EtcLy, Test: String;
begin
  Create;
  NoteStr := LyInput;

  { Clean up input: Move ligatures to after note (where Lilypond docs admit
  they should be!) }
  if NoteStr.StartsWith('\[') then
  begin
    NoteStr := NoteStr.Substring(2) + '\[';
  end;

  { Extract pitch-name string }
  PitchNameLy := ExtractWord(1, NoteStr,
                [',', '''', '1', '2', '4', '8', '\']);
  NoteStr := StringDropBefore(NoteStr, PitchNameLy);

  { Extract octave string }
  OctLy := '';
  Test := FirstCharStr(NoteStr);
  case Test of
    '''', ',' :
    begin
      OctLy := ExtractWord(1, NoteStr, ['1', '2', '4', '8', '\']);
      NoteStr := StringDropBefore(NoteStr, OctLy);
    end;
  end;

  { Extract duration string }
  DurLy := '';
  Test := FirstCharStr(NoteStr);
  case Test of
    '1', '2', '4', '8' :
    begin
      DurLy := ExtractWord(1, NoteStr,
                ['(', ')', '~', '\', '[', ']', '*', '&lt;', '-']);
      NoteStr := StringDropBefore(NoteStr, DurLy);
      EtcLy := NoteStr;
    end;
  end;

  { Convert input strings to internal values and store them in this object }
  FPitchName := GetPitchName(PitchNameLy);
  FOct       := GetOctave(OctLy);
  FDur       := GetDurationKind(DurLy);

  { Set accidental fields from the pitch-name input string }
  FAccid     := akNatural;
  FAccidType := akImplicit;
  if IsValid and not IsRest then
  begin
  FAccid     := GetAccid(PitchNameLy);
  FAccidType := GetAccidType(FPitchName, FAccid, Key);
  end;

  { Set other fields based on string after the pitch }
  FTie           := GetTie(EtcLy);
  FSlur          := GetSlur(EtcLy);
  FColoration    := GetColoration(EtcLy);
  FLigature      := GetLigature(EtcLy);
  FArticulations := GetArticulations(EtcLy);
  FAnnotation    := EtcLy; { TODO placeholder for surplus text }
end;]]></eg>
					</div>
					<div xml:id="section06-3-2">
						<head>6.3.2 Creating a <hi rend="monospace">TMeiNoteRest</hi> Structure from a <hi rend="monospace">TPitch</hi>
							Object</head>
						<eg lang="nohighlight"><![CDATA[
constructor TMeiNoteRest.Create(Pitch: TPitch);
begin
  inherited Create();

  case Pitch.Name of
    pkRest        : Name := 'rest';
    pkMeasureRest : Name := 'mRest';
    else
    begin
      Name := 'note';
      AddAttribute('xml:id', Pitch.ID);
      AddMeiPnameAttribute(Pitch);
      AddMeiAccidAttribute(Pitch);
      AddMeiOctAttribute(Pitch);
      AddMeiArticulation(Pitch);
    end;
  end;

  AddMeiDurDotsAttributes(Pitch);
  AddMeiSyllable(Pitch);
end;]]></eg>
					</div>
					<div xml:id="section06-3-3">
						<head>6.3.3 <hi rend="monospace">BuildMeiMeasureTree</hi>, The Core Function to Convert Tree Structures between
							Lilypond and MEI</head>
						<eg lang="nohighlight"><![CDATA[
{ Given the internal representation of a Lilypond score input tree, the root of
  the internal representation of an MEI output tree, and a measure number, build
  the MEI tree for that measure.
  Convert from Lilypond staff/voice/measure/note hierarchy to MEI
  measure/staff/voice/note structure.
}
function BuildMeiMeasureTree(LyTree: TLyObject; MeiTree: TMeiNode;
  MeasureNum: Integer): TMeiNode;
var
  LyStaff, LyLayer: TLyObject; { nodes in Lilypond input tree }
  MeiLayerPath, MeiMusicNode: TMeiNode; { nodes in MEI output tree }
begin
  Assert(Assigned(MeiTree));

  if Assigned(LyTree) then
  begin
    { Select the given measure in the first layer of the Lilypond score tree }
    LyStaff := LyTree.FindFirstStaff;
    LyLayer := LyStaff.FindFirstLayer;

    { Store the tree path to the selected staff node. }
    MeiLayerPath := LyStaff.ToMeiLayerPath;

    { Create the MEI elements for this measure, this voice, and add it to the
      MEI tree. Process lines and add them in their own elements. }
    MeiMusicNode := CreateMeiMeasure(LyLayer, MeasureNum);
    MeiLayerPath := MeiLayerPath.AppendLastChild(MeiMusicNode);
    MeiTree := MeiTree.AppendChild(MeiLayerPath);
    MeiTree := AddMeiFermatasAndLines(LyLayer, MeiTree, MeasureNum);

    { Process the other staves in this group, siblings to the current LyStaff }
    if Assigned(LyStaff.Sibling) then
      MeiTree := BuildMeiMeasureTree(LyStaff.Sibling, MeiTree, MeasureNum);

    { If we are at the top of the tree, move down one level so we can check
      staff groups or staves }
    if (LyTree.LyType = ekScore) and Assigned(LyTree.Child) then
      LyTree := LyTree.Child;

    { Find staves in the other staff groups }
    if (LyTree.LyType &lt;&gt; ekStaff) and Assigned(LyTree.Sibling) then
      MeiTree := BuildMeiMeasureTree(LyTree.Sibling, MeiTree, MeasureNum);
  end;
  result := MeiTree;
end;]]></eg>
					</div>
				</div>
			</div>
		</body>
		<back>
			<listBibl>
				<bibl xml:id="berendson_etal2020" label="Berendson et al 2020">Berendsen, Wilbert et al. (2020) <title rend="quotes"
						>python-ly</title>. Available at: <ref target="https://pypi.org/project/python-ly/"
						>https://pypi.org/project/python-ly/</ref>.</bibl>
				<bibl xml:id="cashner2020" label="Cashner 2020">Cashner, Andrew A. (2020) <title rend="italic">Hearing Faith: Music
						as Theology in the Spanish Empire</title> Leiden: Brill.</bibl>
				<bibl xml:id="cashner2017" label="Cashner 2017">Cashner, Andrew A. (2017) <title rend="quotes">Villancicos about
						Music from Seventeenth-Century Spain and New Spain</title>, <title>Web Library of Seventeenth-Century
						Music</title> (32). Available at: <ref target="http://www.sscm-wlscm.org/"
					>http://www.sscm-wlscm.org/</ref>.</bibl>
				<bibl xml:id="cashner2021" label="Cashner 2021">Cashner, Andrew A. (2021) <title rend="quotes">Villancicos about
						Music from Seventeenth-Century Spain and New Spain</title>, <title>Web Library of Seventeenth-Century
						Music</title> (36). Available at: <ref target="http://www.sscm-wlscm.org/"
					>http://www.sscm-wlscm.org/</ref>.</bibl>
				<bibl xml:id="dybvig2009" label="Dybvig 2009">Dybvig, R. Kent. (2009) <title rend="italic">The Scheme Programming
						Language</title> Available at: <ref target="https://www.scheme.com/tspl4/">https://www.scheme.com/tspl4/</ref>.
					Cambridge, MA: MIT Press.</bibl>
				<bibl xml:id="grunacher2022" label="Grunacher 2022">Grünbacher, Paul. (2022) <title rend="quotes">A Study on
						Variability for Multi-Device Rendering in Digital Music Publishing</title>, <title rend="italic">Proceedings of
						the 16th International Working Conference on Variability Modelling of Software-Intensive Systems (VAMOS
						’22)</title>. Available at: <ref target="https://doi.org/10.1145/3510466.3510482"
						>https://doi.org/10.1145/3510466.3510482</ref>.</bibl>
				<bibl xml:id="berry_etal2022" label="Berry, Gilmore, and Martinsen 2022">Berry, Carl, Stephen Gilmore, and Torsten
					Martinsen. (2022) <title rend="italic">LaTeX2e: An Unofficial Reference Manual</title> Available at: <ref
						target="https://latexref.xyz">https://latexref.xyz</ref>.</bibl>
				<bibl xml:id="lilypond2022b" label="Lilypond 2022b">Lilypond development team. (2022) <title rend="quotes"
						>Introduction</title>. Available at: <ref target="http://lilypond.org/intro.html"
						>http://lilypond.org/intro.html</ref>.</bibl>
				<bibl xml:id="lilypond2022a" label="Lilypond 2022a">Lilypond development team. (2022) <title rend="quotes">Essay on
						Automatic Music Engraving</title>. Available at: <ref target="http://lilypond.org/essay.html"
						>http://lilypond.org/essay.html</ref>.</bibl>
				<bibl xml:id="liska2020" label="Liska et al 2020">Liska, Urs et al. (2020) <title rend="quotes">openLilyLib:
						Introduction</title> Available at: <ref target="https://github.com/openlilylib/oll-core/wiki"
						>https://github.com/openlilylib/oll-core/wiki</ref>.</bibl>
				<bibl xml:id="mei2022" label="MEI 2022" sortKey="Music">Music Encoding Initiative. (2022) <title rend="quotes"
						>Guidelines (4.0.1)</title> Available at: <ref target="https://music-encoding.org/guidelines/v4/content/"
						>https://music-encoding.org/guidelines/v4/content/</ref>.</bibl>
				<bibl xml:id="montalenti2016" label="Montalenti 2016">Montalenti, Andrew. (2016) <title rend="quotes">Simple and
						Universal: A History of Plain Text, and Why It Matters</title>, <title rend="italic">Muckhacker</title>.
					Available at: <ref target="https://muckhacker.com/elements-of-the-web-text-519c1028ffce"
						>https://muckhacker.com/elements-of-the-web-text-519c1028ffce</ref>.</bibl>
				<bibl xml:id="napoleslopez_etal2019" label="Nápoles López, Vigliensoni, and Fujinaga 2019" sortKey="Napoles">Nápoles
					López, Néstor, Gabriel Vigliensoni, and Ichiro Fujinaga. (2019) <title rend="quotes">The Effects of Translation
						between Symbolic Music Formats: A Case Study with Humdrum, Lilypond, MEI, and MusicXML</title>, <title
						rend="italic">Proceedings of the 2019 Music Encoding Conference</title>. Available at: <ref
						target="https://music-encoding.org/conference/abstracts/abstracts_mec2019/The%20effects%20of%20translation%20between%20the%20Humdrum%20%20Lilypond%20%20MEI%20%20and%20MusicXML.pdf"
						>https://music-encoding.org/conference/abstracts/abstracts_mec2019/The%20effects%20of%20translation%20between%20the%20Humdrum%20%20Lilypond%20%20MEI%20%20and%20MusicXML.pdf</ref></bibl>
				<bibl xml:id="nienhuys_etal2003" label="Nienhuys and Nieuwenhuizen 2003">Nienhuys, Han-Wen and Jan Nieuwenhuizen.
					(2003) <title rend="quotes">Lilypond, A System for Automated Music Engraving</title>, <title rend="italic"
						>Proceedings of the XIV Colloquim on Musical Informatics (XIV CIM 2003), 1–6.</title> Available at: <ref
						target="https://lilypond.gitlab.io/static-files/media/xivcim.pdf"
						>https://lilypond.gitlab.io/static-files/media/xivcim.pdf</ref>.</bibl>
				<bibl xml:id="peron_etal2019" label="Peron, Liska, and Springuel 2019">Peron, Jacques, Urs Liska, and Samuel
					Springuel. (2019) <title rend="quotes">lyLuaTeX</title>. Available at: <ref target="https://ctan.org/pkg/lyluatex"
						>https://ctan.org/pkg/lyluatex</ref>.</bibl>
				<bibl xml:id="risam_etal2022" label="Risam and Gil 2022">Risam, Roopika and Alex Gil. (2022) <title rend="quotes"
						>Introduction: The Questions of Minimal Computing</title> Available at: <ref
						target="http://www.digitalhumanities.org/dhq/vol/16/2/000646/000646.html"
						>http://www.digitalhumanities.org/dhq/vol/16/2/000646/000646.html</ref>. <title rend="italic">Digital Humanities
						Quarterly</title>, 16 (2).</bibl>
				<bibl xml:id="roberts2005" label="Roberts 2005">Roberts, Andrew. (2005) <title rend="quotes">LaTeX Isn’t for Everyone
						But It Might Be for You</title>, <title rend="italic">OS News</title>. Available at: <ref
						target="https://www.osnews.com/story/10766/latex-isnt-for-everyone-but-it-could-be-for-you/"
						>https://www.osnews.com/story/10766/latex-isnt-for-everyone-but-it-could-be-for-you/</ref>.</bibl>
				<bibl xml:id="siddiqui2022" label="Siddiqui 2022">Siddiqui, Nabeel. (2022) <title rend="quotes">Hidden in Plain-TeX:
						Investigating Minimal Computing Workflows</title>, <title rend="italic">Digital Humanities Quarterly</title>,
					16(2). Available at: <ref target="http://digitalhumanities.org/dhq/vol/16/2/000588/000588.html"
						>http://digitalhumanities.org/dhq/vol/16/2/000588/000588.html</ref>.</bibl>
				<bibl xml:id="sivers2022" label="Sivers 2022">Sivers, Derek. (2022) <title rend="quotes">Write Plain Text
						Files</title>, <title rend="italic">Derek Sivers Tech Blog</title>. Available at: <ref
						target="https://sive.rs/plaintext">https://sive.rs/plaintext</ref>.</bibl>
				<bibl xml:id="southern1997" label="Southern 1997">Southern, Eileen. (1997) <title rend="italic">The Music of Black
						Americans: A History</title>. New York: Norton.</bibl>
				<bibl xml:id="steinberg2023" label="Steinberg 2023">Steinberg. (2023) <title rend="quotes">User Interface</title>,
						<title rend="italic">Dorico Pro 4 User Manual</title>. Available at: <ref
						target="https://steinberg.help/dorico_pro/v4/en/dorico/topics/user_interface/user_interface_introduction_c.html"
						>https://steinberg.help/dorico_pro/v4/en/dorico/topics/user_interface/user_interface_introduction_c.html</ref>.</bibl>
				<bibl xml:id="steinberg2022" label="Steinberg 2022">Steinberg. (2022) <title rend="quotes">Introducing SMuFL</title>,
						<title rend="italic">SMuFL: Standard Music Font Layout</title>. Available at: <ref
						target="https://www.smufl.org/about/">https://www.smufl.org/about/</ref>.</bibl>
				<bibl xml:id="tei2022" label="TEI 2022" sortKey="Text">Text Encoding Initiative. (2022) <title rend="italic">P5:
						Guidelines for Electronic Text Encoding and Interchange</title>. Available at: <ref
						target="https://tei-c.org/release/doc/tei-p5-doc/en/html/index.html"
						>https://tei-c.org/release/doc/tei-p5-doc/en/html/index.html</ref>.</bibl>
				<bibl xml:id="tenen_etal2014" label="Tenen and Wythoff 2014">Tenen, Dennis and Grant Wythoff. (2014) <title
						rend="quotes">Sustainable Authorship in Plain Text using Pandoc and Markdown</title>, <title rend="italic"
						>Programming Historian</title>. Available at: <ref
						target="https://programminghistorian.org/en/lessons/sustainable-authorship-in-plain-text-using-pandoc-and-markdown"
						>https://programminghistorian.org/en/lessons/sustainable-authorship-in-plain-text-using-pandoc-and-markdown</ref></bibl>
				<bibl xml:id="thomas_etal2020" label="Thomas and Hunt 2020">Thomas, Dave and Andy Hunt. (2020) <title rend="italic"
						>The Pragmatic Programmer: Your Journey to Mastery</title>. Boston: Addison-Wesley.</bibl>
			</listBibl>
		</back>
	</text>
</TEI>
