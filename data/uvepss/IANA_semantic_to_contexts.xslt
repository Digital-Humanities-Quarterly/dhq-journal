<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:math="http://www.w3.org/2005/xpath-functions/math"
  xmlns="http://hcmc.uvic.ca/ns/staticSearch"
  exclude-result-prefixes="#all"
  version="3.0">
  
  <!--
    Read in the “semantic” XML version of the IANA language subtag registry
    (itself generated by running my IANA_lang_registry_in_XML.xslt over the
    JSON version of the IANA registry generated by running `make update` in
    the https://github.com/mattcg/language-subtag-registry/ directory; and
    write out a UVEPSS <contexts> element with one <context> for each lang-
    uage that matches one of the language tags provided in the $languageTags
    parameter. That parameter is a *single* string that contains a sequence
    of comma-separated BCP47 language tags (no spaces!).
    (A good way to derive that list of tags for $languageTags is to run
    `xmlstarlet sel -t -m "//@xml:lang[not(normalize-space(.)='')]" -v "." -n`
    over the collection of files of interest, then select only one of each and
    convert to comma-separated. For example something like
    saxon -xsl:IANA_semantic_to_contexts.xslt
          -s:/tmp/IANA_language_subtag_registry_semantic.xml
          -o:/tmp/contexts.xml
          languageTags=
            $(xmlstarlet sel -t -m "//@xml:lang[not(normalize-space(.)='')]" -v "." -n
              articles/0*/0*.xml 2>/dev/null
              | sort | uniq | perl -pe 's;\n;,;g;')"
    but all on one line, of course.
    Written 2024-03-23 by Syd Bauman. Copyleft by the author.
  -->
  
  <xsl:output method="xml" indent="yes"/>
  <xsl:mode on-no-match="deep-skip"/>
  
  <xsl:param name="languageTags" select="'am,ar,ca,crk,de,el,en,es,fi,fir,fr,grc,haw,in,it,iw,ja,ko,la,myn,nap,nl,pt,ru,sa,sv,tr,xzp,yi,zh'"/>
  <xsl:param name="languageTagSeq" select="for $lt in tokenize( $languageTags, ',') return substring-before( $lt||'-', '-')"/>
  
  <xsl:template match="/">
    <contexts>
      <xsl:apply-templates select="/*/language[ @subtag = $languageTagSeq ]"/>
    </contexts>
  </xsl:template>
  
  <xsl:template match="language">
    <xsl:variable name="description" as="xs:string" select='translate( normalize-space(.), "&apos;","’")'/>
    <context label="language: {$description}" match="text()[ lang(&apos;{@subtag}&apos;) ]"/>
  </xsl:template>
  
</xsl:stylesheet>