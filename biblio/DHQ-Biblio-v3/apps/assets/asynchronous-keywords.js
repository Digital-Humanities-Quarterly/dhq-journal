// Asynchronous keywords

// Set up namespace for DHQ functions
var bibjs = bibjs || {};
bibjs.search = {};

// Create an anonymous function containing search-related functions.
(function() {
  /* Capture the current context so these functions can refer to themselves even 
    when the context changes. */
  var that = this;
  
  /*** Private functions ***/
  
  /* Use a Link HTTP header to prepare navigation buttons for search results. */
  var assignResultsNav = function(xhr) {
    var linkHdr = xhr.getResponseHeader('Link');
    if ( linkHdr !== null ) {
      var hdrObj = that.parseLinkHeader(linkHdr),
          relKeys = Object.keys(hdrObj);
      //console.log(hdrObj);
      // For each link relation, attempt to enable nav buttons.
      relKeys.forEach( function(relation) {
        var controls = $('.results-pg-'+relation+" button"),
            relURL = hdrObj[relation]['url'];
        if ( controls.length > 0 ) {
          controls.prop('disabled', false);
          controls.data('relLink', relURL);
        }
      }, this);
    }
  }; // assignResultsNav()
  
  
  /*** Public functions ***/
  
  /* When a nav button is acted upon, retrieve a new page of search results. */
  this.pageThroughResults = function(e) {
    var newLink = $(e.target).data('relLink');
    console.log(newLink);
    that.requestBiblioResults(newLink);
  }; // this.pageThroughResults()
  
  /* Parse a Link header for links related to the current HTTP response. See 
    RFC 5988: https://tools.ietf.org/html/rfc5988. */
  this.parseLinkHeader = function (linkStr) {
    // In a Link header, URIs are separated by commas.
    var uris = linkStr.split(/\s*,\s*/g),
        headerObj = {};
    //console.log(uris);
    uris.forEach( function(uri) {
      var relation,
          linkObj = {},
          parts = uri.split(/\s*;\s*/g),
          /* The link itself should always be the first part of the string, within 
            carets. */
          link = parts[0].replace(/\s*<([^<>]+)>\s*/, '$1');
      // Remove the URI from any optional link parameters.
      parts.shift();
      //console.log(parts);
      // Each link parameter should be formatted "NAME=VALUE", in URI fashion.
      parts.forEach( function(param) {
        var paramName, paramValue,
            regex = /^\s*(\w+)="?([^"]+)"?\s*$/;
        if ( regex.test(param) ) {
          paramName = param.replace(regex, '$1');
          paramValue = param.replace(regex, '$2');
          if ( paramName === 'rel' ) {
            relation = paramValue;
          }
          linkObj[paramName] = paramValue;
        }
      });
      linkObj['url'] = link;
      /* The value of the "rel" parameter should be used as the key for this part of 
        the Link header. If it's not present, use the URI as the key. */
      if ( relation !== undefined ) {
        headerObj[relation] = linkObj;
      } else {
        var existingLinkObj = headerObj[link];
        if ( existingLinkObj === undefined ) {
          headerObj[link] = linkObj;
        /* Biblio shouldn't ever need to create "rel"-less Link headers, much less 
          arrays of objects for the same URI, but the code is here in case it 
          becomes necessary or desirable to support Link headers generated by other 
          APIs. */
        } else if ( existingLinkObj.length !== undefined ) {
          headerObj[link] = [ linkObj ].concat(existingLinkObj);
        } else {
          headerObj[link] = [ linkObj ].push(existingLinkObj);
        }
      }
    });
    //console.log(headerObj);
    return headerObj;
  }; // this.parseLinkHeader()
  
  this.requestBiblioResults = function (url, params) {
    var params,
        ajaxReqObj = {
          url: url,
          datatype: 'html',
          success: function (fragment, status, xhr) {
            var results = $(fragment).find('span.citation'),
                resultsModule = document.getElementById('search-results'),
                resultsPane = document.getElementById('search-results-pane'),
                closeBtn = document.getElementById('search-results-toggle');
            if ( results.length >= 0 ) {
              $(resultsPane).find('.citation-group').html(results);
                bibjs.a11y.toggleCollapsible(closeBtn, 'true');
              $(closeBtn).prop('disabled', false);
              if ( results.length === 0 ) {
                bibjs.a11y.toggleCollapsible(closeBtn, 'false');
                $(closeBtn).prop('disabled', true);
              }
            }
            $(resultsModule).find('.info-count').html('(showing '+results.length+')');
            resultsModule.classList.remove('noshow');
            assignResultsNav(xhr);
          },
          error: function () {
            console.warn('Something went wrong!');
          }
        };
    if ( params !== null ) {
      ajaxReqObj['data'] = params;
    }
    // Reset all nav buttons.
    $('.results-pg-nav button').prop('disabled', true)
      .data('relLink', null);
    $.get(ajaxReqObj);
  }; // this.requestBiblioResults()
  
  this.submitForm = function (event) {
    event.preventDefault();
    var form = event.target,
        url = form.attributes['action'].value,
        params = $(form).serialize();
    this.requestBiblioResults(url, params);
  }; // this.submitForm()
  
}).apply(bibjs.search); // Apply the "bibjs.search" namespace to the anonymous function.


$(document).ready( function() {
  $('#search-module').submit( function(e) {
    bibjs.search.submitForm(e);
  });
});
